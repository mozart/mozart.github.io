<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>3 Basics</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.opi">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.equality">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.basics"><H1><A name="chapter.basics">3 Basics</A></H1><P>We will initially restrict ourselves to the sequential programming style of Oz. At this stage you may think of Oz computations as performed by a sequential process that executes one statement after the other. We call this process a <EM>thread</EM>. This thread has access to the <EM>store</EM>. It is able to manipulate the store by reading, adding, and updating information stored in the store. Information is accessed through the notion of <EM>variables</EM>. A thread can access information only through the variables visible to it, directly or indirectly. Oz variables are <EM>single-assignment</EM> variables or more appropriately logic variables. In imperative languages like C and Java, a variable can be assigned multiple times. In contrast, single assignment variables can be assigned only once. This notion is known from many languages including dataflow languages and concurrent logic programming languages. A single assignment variable has a number of phases in its lifetime. Initially it is introduced with unknown value, and later it might be assigned a value, in which case the variable becomes <EM>bound</EM>. Once a variable is bound, it cannot itself be changed. A <EM>logic variable</EM> is a single assignment variable that can also be equated with another variable. Using logic variables does not mean that you cannot model state-change because a variable, as you will see later, could be bound to a cell, which is stateful, i.e., the content of a cell can be changed.</P><P>A thread executing the statement: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;S&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>will introduce three single assignment variables <CODE>X</CODE>, <CODE>Y</CODE>, <CODE>Z</CODE> and execute the statement <CODE>S</CODE> in the scope of these variables. A variable normally starts with an upper-case letter, possibly followed by an arbitrary number of alphanumeric characters. Variables may also be presented textually as any string of printable characters enclosed within back-quote characters, e.g. <CODE><SPAN class="string">`this&nbsp;$&nbsp;is&nbsp;a&nbsp;variable`</SPAN></CODE>. Before the execution of <CODE>S</CODE> the variables declared will not have any associated values. We say that the variables are <EM>unbound</EM>. Any variable in an Oz program must be introduced, except for certain pattern matching constructs to be shown later. </P><P>Another form of declaration is: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;S</CODE></BLOCKQUOTE><P> </P><P>This is an open-ended declaration that makes <CODE>X</CODE>, <CODE>Y</CODE>, and <CODE>Z</CODE> visible globally in <CODE>S</CODE>, as well as in all statements that follow <CODE>S</CODE> textually, unless overridden again by another variable declaration of the same textual variables. <CODE>X</CODE>, <CODE>Y</CODE>, <CODE>Z</CODE> are global variables.</P><H2><A name="label14">3.1 Primary Oz Types</A></H2><P></P><DIV class="figure" id="typehier"><HR><P><A name="typehier"></A></P><P> </P><DIV align="center"><IMG alt="" src="image33.gif"></DIV><P> </P><P class="caption"><STRONG>Figure&nbsp;3.1:</STRONG> Oz Type Hierarchy</P><HR></DIV><P> </P><P>Oz is a dynamically typed language. <A href="node3.html#typehier">Figure&nbsp;3.1</A> shows the type hierarchy of Oz. Any variable, if it ever gets a value, will be bound to a value of one of these types. Most of the types seem familiar to experienced programmers, except probably <EM>Chunk</EM>, <EM>Cell</EM>, <EM>Space</EM>, <EM>FDInt</EM> and <EM>Name</EM>. We will discuss all of these types in due course. For the impatient reader here are some hints. The <EM>Chunk</EM> data type allows users to introduce new abstract data types. <EM>Cell</EM> introduces the primitive notion of state-container and state modification. <EM>Space</EM> will be needed for advanced problem solving using search techniques. <EM>FDInt</EM> is the type of finite domain that is used frequently in constraint programming, and constraint satisfaction. <EM>Name</EM> introduces anonymous unique unforgeable tokens. </P><P>The language is dynamically-typed in the sense that when a variable is introduced, its type as well as its value are unknown. Only when the variable is bound to an Oz value, does its type become determined. </P><H2><A name="label15">3.2 Adding Information</A></H2><P>In Oz, there are few ways of adding information to the store or (said differently) of binding a variable to a value. The most common form is using the <EM>equality</EM> infix operator <CODE>=</CODE>. For example, given that the variable <CODE>X</CODE> is declared the following statement: </P><BLOCKQUOTE class="code"><CODE>X&nbsp;=&nbsp;1</CODE></BLOCKQUOTE><P> </P><P>will bind the unbound variable <CODE>X</CODE> to the integer <CODE>1</CODE>, and add this information to the store. Now, if <CODE>X</CODE> is already assigned the value <CODE>1</CODE>, the operation is considered as performing a test on <CODE>X</CODE>. If <CODE>X</CODE> is already bound to an incompatible value, i.e. to any other value different from <CODE>1</CODE>, a proper <EM>exception</EM> will be raised. Exception handling is described later. </P><H2><A name="label16">3.3 Data Types with Structural Equality</A></H2><P>The hierarchy starting from <EM>Number</EM> and <EM>Record</EM> in <A href="node3.html#typehier">Figure&nbsp;3.1</A> defines the data types of Oz whose members (values) are equal only if they are structurally similar. For example two numbers are equal if they have the same type, or one is a subtype of the other, and have the same value. For example, if both are integers and are identical numbers or both are lists and their head elements are identical as well as their respective tail lists. Structural equality allows values to be equivalent even if they are replicas occupying different physical memory location. </P><H2><A name="label17">3.4 Numbers</A></H2><P>The following program, introduces three variables <CODE>I</CODE>,<CODE>F</CODE> and <CODE>C</CODE>. It assigns <CODE>I</CODE> an integer, <CODE>F</CODE> a float, and <CODE>C</CODE> the character <SPAN class="key">t</SPAN> in this order. It then displays the list consisting of <CODE>I</CODE>,<CODE>F</CODE>, and <CODE>C</CODE>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;I&nbsp;F&nbsp;C&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;I&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;F&nbsp;=&nbsp;5<SPAN class="keyword">.</SPAN>5<BR>&nbsp;&nbsp;&nbsp;C&nbsp;=&nbsp;<SPAN class="string">&amp;t</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;[I&nbsp;F&nbsp;C]}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Oz supports binary, octal, decimal and hexadecimal notation for integers, which can be arbitrary large. An octal starts with a leading <SPAN class="key">0</SPAN>, and a hexadecimal starts with a leading <SPAN class="key">0x</SPAN> or <SPAN class="key">0X</SPAN>. Floats are different from integers and must have decimal points. Other examples of floats are shown where <CODE><SPAN class="keyword">~</SPAN></CODE> is unary minus: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">~</SPAN>3<SPAN class="keyword">.</SPAN>141&nbsp;&nbsp;&nbsp;4<SPAN class="keyword">.</SPAN>5E3&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">~</SPAN>12<SPAN class="keyword">.</SPAN>0e<SPAN class="keyword">~</SPAN>2</CODE></BLOCKQUOTE><P> </P><P>In Oz, there is no automatic type conversion, so <CODE>5<SPAN class="keyword">.</SPAN>0&nbsp;=&nbsp;5</CODE> will raise an exception. Of course, there are primitive procedures for explicit type conversion. These and many others can be found in <A href="bib.html#schulte98">[Shu98]</A>. Characters are a subtype of integers in the range of <CODE>0<SPAN class="keyword">,</SPAN>&nbsp;<SPAN class="keyword">...,</SPAN>&nbsp;255</CODE>. The standard ISO 8859-1 coding is used (not Unicode). Printable characters have external representation, e.g. <CODE><SPAN class="string">&amp;0</SPAN></CODE> is actually the integer <CODE>48</CODE>, and <CODE><SPAN class="string">&amp;a</SPAN></CODE> is <CODE>97</CODE>. Some control characters have also a representation e.g. <CODE><SPAN class="string">&amp;\n</SPAN></CODE> is a new line. All characters can be written as <CODE>&amp;\</CODE><EM>ooo</EM>, where <EM>o</EM> is an octal digit. </P><P>Operations on characters, integers, and floats can be found in the library modules <A href="../base/char.html#section.text.characters"><CODE>Char</CODE></A>, <A href="../base/float.html#section.numbers.floats"><CODE>Float</CODE></A>, and <A href="../base/int.html#section.numbers.integers"><CODE>Int</CODE></A>. Additional generic operations on all numbers are found in the module <A href="../base/number.html#section.numbers.general"><CODE>Number</CODE></A>. </P><H2><A name="label18">3.5 Literals</A></H2><P>Another important category of atomic types, i.e. types whose members have no internal structure, is the category of literals. Literals are divided into atoms and names. An Atom is symbolic entity that has an identity made up of a sequence of alphanumeric characters starting with a lower case letter, or arbitrary printable characters enclosed in quotes. For example: </P><BLOCKQUOTE class="code"><CODE>a&nbsp;&nbsp;&nbsp;foo&nbsp;&nbsp;&nbsp;<SPAN class="string">'='</SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="string">':='</SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="string">'OZ&nbsp;3.0'</SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN></CODE></BLOCKQUOTE><P> </P><P>Atoms have an ordering based on lexicographic ordering. </P><P>Another category of elementary entities is <CODE>Name</CODE>. The only way to create a name is by calling the procedure <CODE>{NewName&nbsp;X}</CODE> where <CODE>X</CODE> is assigned a new name that is guaranteed to be worldwide unique. Names cannot be forged or printed. As will be seen later, names play an important role in the security of Oz programs. A subtype of <CODE>Name</CODE> is <CODE>Bool</CODE>, which consists of two names protected from being redefined by having the reserved keywords <CODE><SPAN class="keyword">true</SPAN></CODE> and <CODE><SPAN class="keyword">false</SPAN></CODE>. Thus a user program cannot redefine them, and mess up all programs relying on their definition. There is also the type <CODE>Unit</CODE> that consists of the single name <CODE><SPAN class="keyword">unit</SPAN></CODE>. This is used as synchronization token in many concurrent programs. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;B&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;foo<BR>&nbsp;&nbsp;&nbsp;{NewName&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;[X&nbsp;Y&nbsp;B]}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H2><A name="label19">3.6 Records and Tuples</A></H2><P>Records are structured compound entities. A record has a <EM>label</EM> and a fixed number of components or arguments. There are also records with a variable number of arguments that are called <EM>open records</EM>. For now, we restrict ourselves to 'closed' records. The following is a record: </P><BLOCKQUOTE class="code"><CODE>tree(key:&nbsp;I&nbsp;value:&nbsp;Y&nbsp;left:&nbsp;LT&nbsp;right:&nbsp;RT)</CODE></BLOCKQUOTE><P> </P><P>It has four arguments, and the label <CODE>tree</CODE>. Each argument consists of a pair <EM>Feature:Field</EM>, so the features of the above record are <CODE>key</CODE>, <CODE>value</CODE>, <CODE>left</CODE>, and <CODE>right</CODE>. The corresponding fields are the variables <CODE>I</CODE>,<CODE>Y</CODE>,<CODE>LT</CODE>, and <CODE>RT</CODE>. It is possible to omit the features of a record reducing it to what is known from logic programming as a compound term. In Oz, this is called a <EM>tuple</EM>. So, the following tuple has the same label and fields as the above record: </P><BLOCKQUOTE class="code"><CODE>tree(I&nbsp;Y&nbsp;LT&nbsp;RT)</CODE></BLOCKQUOTE><P> </P><P>It is just a syntactic notation for the record: </P><BLOCKQUOTE class="code"><CODE>tree(1:I&nbsp;2:Y&nbsp;3:LT&nbsp;4:RT)</CODE></BLOCKQUOTE><P> </P><P>where the features are integers starting from <CODE>1</CODE> up to the number of fields in the tuple. The following program will display a list consisting of two elements one is a record, and the other is tuple having the same label and fields: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;T&nbsp;I&nbsp;Y&nbsp;LT&nbsp;RT&nbsp;W&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>T&nbsp;=&nbsp;tree(key:I&nbsp;value:Y&nbsp;left:LT&nbsp;right:RT)<BR>I&nbsp;=&nbsp;seif<BR>Y&nbsp;=&nbsp;43<BR>LT&nbsp;=&nbsp;nil<BR>RT&nbsp;=&nbsp;nil<BR>W&nbsp;=&nbsp;tree(I&nbsp;Y&nbsp;LT&nbsp;RT)<BR>{Browse&nbsp;[T&nbsp;W]}</CODE></BLOCKQUOTE><P> </P><P>The display will show: </P><BLOCKQUOTE class="code"><CODE>[tree(key:seif&nbsp;value:43&nbsp;left:nil&nbsp;right:nil)<BR>&nbsp;tree(seif&nbsp;43&nbsp;nil&nbsp;nil)]</CODE></BLOCKQUOTE><P> </P><H2><A name="label20">3.7 Operations on records</A></H2><P>We discuss some basic operations on records. Most operations are found in the module <A href="../base/record.html#section.records.records"><CODE>Record</CODE></A>. To select a field of a record component, we use the infix dot operator, e.&nbsp;g. <I>Record</I><CODE><SPAN class="keyword">.</SPAN></CODE><I>Feature</I> </P><BLOCKQUOTE class="code"><CODE>%&nbsp;<SPAN class="comment">Selecting&nbsp;a&nbsp;Component<BR></SPAN>{Browse&nbsp;T<SPAN class="keyword">.</SPAN>key}<BR>{Browse&nbsp;W<SPAN class="keyword">.</SPAN>1}<BR>%&nbsp;<SPAN class="comment">will&nbsp;show&nbsp;seif&nbsp;twice&nbsp;in&nbsp;the&nbsp;browser<BR></SPAN>seif<BR>seif</CODE></BLOCKQUOTE><P> </P><P>The <EM>arity</EM> of a record is a list of the features of the record sorted lexicographically. To display the arity of a record we use the procedure <CODE>Arity</CODE>. The procedure application <CODE>{Arity&nbsp;R&nbsp;X}</CODE> will execute once <CODE>R</CODE> is bound to a record, and will bind <CODE>X</CODE> to the arity of the record. Executing the following statements </P><BLOCKQUOTE class="code"><CODE>%&nbsp;<SPAN class="comment">Getting&nbsp;the&nbsp;Arity&nbsp;of&nbsp;a&nbsp;Record<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Arity&nbsp;T&nbsp;X}&nbsp;{Browse&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Arity&nbsp;W&nbsp;X}&nbsp;{Browse&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>will display </P><BLOCKQUOTE class="code"><CODE>[key&nbsp;left&nbsp;right&nbsp;value]<BR>[1&nbsp;2&nbsp;3&nbsp;4]</CODE></BLOCKQUOTE><P> </P><P>Another useful operation is conditionally selecting a field of a record. The operation <CODE>CondSelect</CODE> takes a record <CODE>R</CODE>, a feature <CODE>F</CODE>, and a default field-value <CODE>D</CODE>, and a result argument <CODE>X</CODE>. If the feature <CODE>F</CODE> exists in <CODE>R</CODE>, <CODE>X</CODE> is bound to <CODE>R<SPAN class="keyword">.</SPAN>F</CODE>, otherwise <CODE>X</CODE> is bound to the default value <CODE>D</CODE>. <CODE>CondSelect</CODE> is not really a primitive operation. It is definable in Oz. The following statements: </P><BLOCKQUOTE class="code"><CODE>%&nbsp;<SPAN class="comment">Selecting&nbsp;a&nbsp;component&nbsp;conditionally<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{CondSelect&nbsp;W&nbsp;key&nbsp;eeva&nbsp;X}&nbsp;{Browse&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{CondSelect&nbsp;T&nbsp;key&nbsp;eeva&nbsp;X}&nbsp;{Browse&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>will display </P><BLOCKQUOTE class="code"><CODE>eeva<BR>seif</CODE></BLOCKQUOTE><P> </P><P>A common infix tuple-operator used in Oz is <CODE><SPAN class="keyword">#</SPAN></CODE>. So, <CODE>1<SPAN class="keyword">#</SPAN>2</CODE> is a tuple of two elements, and observe that <CODE>1<SPAN class="keyword">#</SPAN>2<SPAN class="keyword">#</SPAN>3</CODE> is a single tuple of three elements: </P><BLOCKQUOTE class="code"><CODE><SPAN class="string">'#'</SPAN>(1&nbsp;2&nbsp;3)</CODE></BLOCKQUOTE><P> </P><P>and not the pair <CODE>1<SPAN class="keyword">#</SPAN>(2<SPAN class="keyword">#</SPAN>3)</CODE>. With the <CODE><SPAN class="keyword">#</SPAN></CODE> operator, you cannot directly write an empty or a single element tuple. Instead, you must fall back on the usual prefix record syntax: the empty tuple must be written <CODE><SPAN class="string">'#'</SPAN>()</CODE> or just <CODE><SPAN class="string">'#'</SPAN></CODE>, and a single element tuple <CODE><SPAN class="string">'#'</SPAN>(X)</CODE>. </P><P>The operation <CODE>{AdjoinAt&nbsp;R1&nbsp;F&nbsp;X&nbsp;R2}</CODE> binds <CODE>R2</CODE> to the record resulting from adjoining the field <CODE>X</CODE> to <CODE>R1</CODE> at feature <CODE>F</CODE>. If <CODE>R1</CODE> already has the feature <CODE>F</CODE>, the resulting record <CODE>R2</CODE> is identical to <CODE>R1</CODE> except for the field <CODE>R1<SPAN class="keyword">.</SPAN>F</CODE> whose value becomes <CODE>X</CODE>. Otherwise the argument <CODE>F:X</CODE> is added to <CODE>R1</CODE> resulting in <CODE>R2</CODE>. </P><P>The operation <CODE>{AdjoinList&nbsp;R&nbsp;LP&nbsp;S}</CODE> takes a record <CODE>R</CODE>, a list of feature-field pairs, and returns in <CODE>S</CODE> a new record such that: </P><UL><LI><P>The label of R is equal to the label of S.</P></LI><LI><P>S has the components that are specified in LP in addition to all components in R that do not have a feature occurring in LP.</P></LI></UL><P> </P><P>This operation is of course defined by using <CODE>AdjointAt</CODE>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;S&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{AdjoinList&nbsp;tree(a:1&nbsp;b:2)&nbsp;[a<SPAN class="keyword">#</SPAN>3&nbsp;c<SPAN class="keyword">#</SPAN>4]&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;{Show&nbsp;S}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>%&nbsp;<SPAN class="comment">gives&nbsp;S=tree(a:3&nbsp;b:2&nbsp;c:4)</SPAN></CODE></BLOCKQUOTE><P> </P><H2><A name="label21">3.8 Lists</A></H2><P>As in many other symbolic programming languages, e.g. Scheme and Prolog, <EM>lists</EM> form an important class of data structures in Oz. The category of lists does not belong to a single data type in Oz. They are rather a conceptual structure. A list is either the atom <CODE>nil</CODE> representing the empty list, or is a tuple using the infix operator <CODE><SPAN class="keyword">|</SPAN></CODE> and two arguments which are respectively the head and the tail of the list. Thus, a list of the first three positive integers is represented as: </P><BLOCKQUOTE class="code"><CODE>1<SPAN class="keyword">|</SPAN>2<SPAN class="keyword">|</SPAN>3<SPAN class="keyword">|</SPAN>nil</CODE></BLOCKQUOTE><P> </P><P>Another convenient special notation for a <EM>closed list</EM>, i.&nbsp;e. a list with a determined number of elements is: </P><BLOCKQUOTE class="code"><CODE>[1&nbsp;2&nbsp;3]</CODE></BLOCKQUOTE><P> </P><P>The above notation is used only for closed list, so a list whose first two elements are <CODE>1</CODE> and <CODE>2</CODE>, but whose tail is the variable <CODE>X</CODE> looks like: </P><BLOCKQUOTE class="code"><CODE>1<SPAN class="keyword">|</SPAN>2<SPAN class="keyword">|</SPAN>X</CODE></BLOCKQUOTE><P> </P><P>One can also use the standard record notation for lists: </P><BLOCKQUOTE class="code"><CODE><SPAN class="string">'|'</SPAN>(1&nbsp;<SPAN class="string">'|'</SPAN>(2&nbsp;X))</CODE></BLOCKQUOTE><P> </P><P>Further notational variant is allowed for lists whose elements correspond to character codes. Lists written in this notation are called <EM>strings</EM>, e.g. </P><BLOCKQUOTE class="code"><CODE><SPAN class="string">&quot;OZ&nbsp;3.0&quot;</SPAN></CODE></BLOCKQUOTE><P> </P><P>is the list </P><BLOCKQUOTE class="code"><CODE>[79&nbsp;90&nbsp;32&nbsp;51&nbsp;46&nbsp;48]</CODE></BLOCKQUOTE><P> </P><P>or equivalently </P><BLOCKQUOTE class="code"><CODE>[<SPAN class="string">&amp;O</SPAN>&nbsp;<SPAN class="string">&amp;Z</SPAN>&nbsp;<SPAN class="string">&amp;&nbsp;</SPAN>&nbsp;<SPAN class="string">&amp;3</SPAN>&nbsp;<SPAN class="string">&amp;.</SPAN>&nbsp;<SPAN class="string">&amp;0</SPAN>]</CODE></BLOCKQUOTE><P> </P><H2><A name="label22">3.9 Virtual Strings</A></H2><P>A virtual string is a special tuple that represents a string with virtual concatenation, i.e. the concatenation is performed when really needed. Virtual strings are used for I/O with files, sockets, and windows. All atoms, except <CODE>nil</CODE> and <CODE><SPAN class="string">'#'</SPAN></CODE>, as well as numbers, strings, or <CODE><SPAN class="string">'#'</SPAN></CODE>-labeled tuples can be used to compose virtual strings. Here is one example: </P><BLOCKQUOTE class="code"><CODE>123<SPAN class="keyword">#</SPAN><SPAN class="string">&quot;-&quot;</SPAN><SPAN class="keyword">#</SPAN>23<SPAN class="keyword">#</SPAN><SPAN class="string">&quot;&nbsp;is&nbsp;&quot;</SPAN><SPAN class="keyword">#</SPAN>100</CODE></BLOCKQUOTE><P> </P><P>represents the string </P><BLOCKQUOTE class="code"><CODE><SPAN class="string">&quot;123-23&nbsp;is&nbsp;100&quot;</SPAN></CODE></BLOCKQUOTE><P> </P><P class="warning"><STRONG>Warning:</STRONG>For each data type discussed in section, there is a corresponding module in the Mozart system. The modules define operations on the corresponding data type. You may find more about these operations in <A href="../base/index.html">The Oz Base Environment documentation</A> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.opi">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.equality">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzén</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
