<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>11 Objects and Concurrency</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node10.html#chapter.classes">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node12.html#chapter.lp">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.objectscc"><H1><A name="chapter.objectscc">11 Objects and Concurrency</A></H1><P>As we have seen, objects in Oz are stateful data structures. Threads are the active computation entities. Threads can communicate either by message passing using ports, or through common shared objects. Communication through shared objects requires the ability to serialize concurrent operations on objects so that the object state is kept coherent after each such an operation. In Oz, we separate the issue of acquiring exclusive access of an object from the object system. This gives us the ability to perform coarse-grain atomic operation on a set of objects, a very important requirement, e.g. in distributed database systems. The basic mechanism in Oz to get exclusive access is through locks. </P><DIV id="section.objectscc.lock"><H2><A name="section.objectscc.lock">11.1 Locks</A></H2><P>The purpose of a lock is to mediate exclusive access to a shared resource between threads. Such a mechanism is typically made safer and more robust by restricting this exclusive access to a critical region. On entry into the region, the lock is secured and the thread is granted exclusive access rights to the resource, and when execution leaves the region, whether normally or through an exception, the lock is released. A concurrent attempt to obtain the same lock will block until the thread currently holding it has released it. </P><H3><A name="label60">11.1.1 Simple Locks</A></H3><P>In the case of a simple lock, a nested attempt by the same thread to reacquire the same lock during the dynamic scope of a critical section guarded by the lock will block. We say <EM>reentrancy</EM> is not supported. Simple locks can be modeled in Oz as follows, where <CODE>Code</CODE> is a nullary procedure encapsulating the computation to be performed in the critical section. The lock is represented as a procedure: when applied to some code, it tries to get the lock by waiting until <CODE>Old</CODE> gets bound to <CODE><SPAN class="keyword">unit</SPAN></CODE>. Notice that the lock is released upon normal as well as abnormal exit. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewSimpleLock</SPAN>&nbsp;?Lock}<BR>&nbsp;&nbsp;&nbsp;Cell&nbsp;=&nbsp;{NewCell&nbsp;<SPAN class="keyword">unit</SPAN>}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Lock</SPAN>&nbsp;Code}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Old&nbsp;New&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Exchange&nbsp;Cell&nbsp;Old&nbsp;New}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Wait&nbsp;Old}&nbsp;{Code}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">finally</SPAN>&nbsp;New=<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label61">11.1.2 Atomic Exchange on Object Attributes</A></H3><P>Another implementation is using an object as shown below to implement a lock. Notice the use of the construct: </P><BLOCKQUOTE class="code"><CODE>Old&nbsp;=&nbsp;lck&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;New</CODE></BLOCKQUOTE><P> </P><P>Similar to the Exchange operation on cells, this is an atomic exchange on an object attribute. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">SimpleLock</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;lck:<SPAN class="keyword">unit</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="string">'lock'</SPAN>(Code)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Old&nbsp;New&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Old&nbsp;=&nbsp;lck&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;New<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Wait&nbsp;Old}&nbsp;{Code}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">finally</SPAN>&nbsp;New=&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.objectscc.reentrant"><H2><A name="section.objectscc.reentrant">11.2 Thread-Reentrant Locks</A></H2><P>In Oz, the computational unit is the thread. Therefore an appropriate locking mechanism should grant exclusive access rights to threads. As a consequence the non-reentrant simple lock mechanism presented above is inadequate. A thread-reentrant lock allows the same thread to reenter the lock, i.e. to enter a dynamically nested critical region guarded by the same lock. Such a lock can be acquired by at most one thread at a time. Concurrent threads that attempt to get the same lock are queued. When the lock is released, it is granted to the thread standing first in line etc. Thread-reentrant locks can be modeled in Oz as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ReentrantLock</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;SimpleLock</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;Current:<SPAN class="keyword">unit</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="string">'lock'</SPAN>(Code)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThisThread&nbsp;=&nbsp;{Thread<SPAN class="keyword">.</SPAN>this}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;ThisThread&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>Current&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Code}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Code1</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;ThisThread<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Code}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">finally</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleLock<SPAN class="keyword">,</SPAN>&nbsp;<SPAN class="string">'lock'</SPAN>(Code1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Thread reentrant locks are given syntactic and implementational support in Oz. They are implemented as subtype of chunks. Oz provides the following syntax for guarded critical regions: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">lock</SPAN>&nbsp;</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><I>E</I> is an expression that evaluates to a lock. The construct blocks until <I>S</I> is executed. If <I>E</I> is not a lock, then a type error is raised. </P><UL><LI><P><CODE>{NewLock&nbsp;L}</CODE> creates a new lock <CODE>L</CODE>. </P></LI><LI><P><CODE>{IsLock&nbsp;E</CODE>} returns true iff <CODE>E&nbsp;</CODE>is a lock. </P></LI></UL><P> </P><H3><A name="label62">11.2.1 Arrays</A></H3><P>Oz has arrays as chunk subtype. Operations on arrays are defined in module <CODE>Array</CODE>. </P><UL><LI><P><CODE>{NewArray&nbsp;<SPAN class="keyword">+</SPAN>L&nbsp;<SPAN class="keyword">+</SPAN>H&nbsp;<SPAN class="keyword">+</SPAN>I&nbsp;?A}</CODE> creates an array <CODE>A</CODE>, where <CODE>L</CODE> is the lower-bound index, <CODE>H</CODE> is the higher-bound index, and <CODE>I</CODE> is the initial value of the array elements. </P></LI><LI><P><CODE>{Array<SPAN class="keyword">.</SPAN>low&nbsp;<SPAN class="keyword">+</SPAN>A&nbsp;?L}</CODE> returns the lower index. </P></LI><LI><P><CODE>{Array<SPAN class="keyword">.</SPAN>high&nbsp;<SPAN class="keyword">+</SPAN>A&nbsp;?L}</CODE> returns the higher index. </P></LI><LI><P><CODE>R<SPAN class="keyword">:=</SPAN>A<SPAN class="keyword">.</SPAN>I</CODE> returns <CODE>A[I]</CODE> in <CODE>R</CODE>. </P></LI><LI><P><CODE>A<SPAN class="keyword">.</SPAN>I<SPAN class="keyword">:=</SPAN>X</CODE> assigns <CODE>X</CODE> to the entry <CODE>A[I]</CODE>. </P></LI></UL><P> </P><P>As a simple illustration of the use of locks consider the program in <A href="node11.html#usinglock">Figure&nbsp;11.1</A>. The procedure <CODE>Switch</CODE> transforms negative elements of an array to positive, and zero elements to the atom <CODE>zero</CODE>! The procedure <CODE>Zero</CODE> resets all elements to zero. </P><P></P><DIV class="figure" id="usinglock"><HR><P><A name="usinglock"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;A&nbsp;L&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>A&nbsp;=&nbsp;{NewArray&nbsp;1&nbsp;100&nbsp;<SPAN class="keyword">~</SPAN>5}<BR>L&nbsp;=&nbsp;{NewLock}<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Switch</SPAN>&nbsp;A}<BR>&nbsp;&nbsp;&nbsp;{For&nbsp;{Array<SPAN class="keyword">.</SPAN>low&nbsp;A}&nbsp;{Array<SPAN class="keyword">.</SPAN>high&nbsp;A}&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;A<SPAN class="keyword">.</SPAN>I&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X<SPAN class="keyword">&lt;</SPAN>0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;A<SPAN class="keyword">.</SPAN>I&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">~</SPAN>X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;0&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;A<SPAN class="keyword">.</SPAN>I&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;zero&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Delay&nbsp;100}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Zero</SPAN>&nbsp;A}<BR>&nbsp;&nbsp;&nbsp;{For&nbsp;{Array<SPAN class="keyword">.</SPAN>low&nbsp;A}&nbsp;{Array<SPAN class="keyword">.</SPAN>high&nbsp;A}&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;A<SPAN class="keyword">.</SPAN>I&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;0&nbsp;{Delay&nbsp;100}&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;</CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;11.1:</STRONG> Using a lock</P><HR></DIV><P> </P><P>Try the following program. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Zero&nbsp;A}&nbsp;X&nbsp;=&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Switch&nbsp;A}&nbsp;Y&nbsp;=&nbsp;X&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Wait&nbsp;Y}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;10&nbsp;1&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;{Browse&nbsp;A<SPAN class="keyword">.</SPAN>I}&nbsp;<SPAN class="keyword">end</SPAN>}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>The elements of the array will be mixed <CODE>0</CODE> and <CODE>zero</CODE>. </P><P>Assume that we want to perform the procedures <CODE>Zero</CODE> and <CODE>Switch</CODE>, each atomically but in an arbitrary order. To do this we can use locks as in the following example. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Delay&nbsp;100}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;L&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Zero&nbsp;A}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;L&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Switch&nbsp;A}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;X&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Wait&nbsp;Y}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;10&nbsp;1&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;{Browse&nbsp;&nbsp;A<SPAN class="keyword">.</SPAN>I}&nbsp;<SPAN class="keyword">end</SPAN>}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>By Switching the delay statement above between the first and the second thread, we observe that all the elements of the array either will get the value <CODE>zero</CODE> or <CODE>0</CODE>. We have no mixed values. </P><P class="warning"><STRONG>Warning:</STRONG>*** Write an example of an atomic transaction on multiple objects using multiple locks. </P></DIV><DIV id="section.objectscc.lockobject"><H2><A name="section.objectscc.lockobject">11.3 Locking Objects</A></H2><P>To guarantee mutual exclusion on objects one may use the locks described in the previous subsection. Alternatively, we may declare in the class that its instance objects can be locked with a default lock existing in the objects when they are created. A class with an implicit lock is declared as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;</CODE><I>C</I><CODE>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">....</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">prop</SPAN>&nbsp;locking<BR>&nbsp;&nbsp;<SPAN class="keyword">....</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>This does not automatically lock the object when one of its methods is called. Instead we have to use the construct: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">lock</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>inside any method to guarantee exclusive access when <I>S</I> is executed. Remember that our locks are thread-reentrant. This implies that: </P><UL><LI><P>if we take all objects that we have constructed and enclose each method body with <CODE><SPAN class="keyword">lock</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE>, and </P></LI><LI><P>execute our program with only one thread, then </P></LI><LI><P>the program will behave exactly as before </P></LI></UL><P> </P><P>Of course, if we use multiple threads calling methods in multiple objects, we might deadlock if there is any cyclic dependency. Writing nontrivial concurrent programs needs careful understanding of the dependency patterns between threads. In such programs deadlock may occur whether locks are used or not. It suffices to have a cyclic communication pattern for deadlock to occur. </P><P>The program in <A href="node10.html#counterclass">Figure&nbsp;10.3</A> can be refined to work in concurrent environment by refining it as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">CCounter</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Counter</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">prop</SPAN>&nbsp;locking<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">inc</SPAN>(Value)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;Counter<SPAN class="keyword">,</SPAN>inc(Value)&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(Value)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;Counter<SPAN class="keyword">,</SPAN>init(Value)&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Let us now study a number of interesting examples where threads not only perform atomic transactions on objects, but also synchronize through objects. </P></DIV><DIV id="section.objectscc.fifo"><H2><A name="section.objectscc.fifo">11.4 Concurrent FIFO Channel</A></H2><P>The first example shows a concurrent channel, which is shared among an arbitrary number of threads. Any producing thread may put information in the channel asynchronously. A consuming thread has to wait until information exists in the channel. Waiting threads are served fairly. <A href="node11.html#asyncchannel">Figure&nbsp;11.2</A> shows one possible realization. This program relies on the use of logical variables to achieve the desired synchronization. The method <CODE>put<SPAN class="keyword">/</SPAN>1</CODE> inserts an element in the channel. A thread executing the method <CODE>get<SPAN class="keyword">/</SPAN>1</CODE> will wait until an element is put in the channel. Multiple consuming threads will reserve their place in the channel, thereby achieving fairness. Notice that <CODE>{Wait&nbsp;I}</CODE> is done outside an exclusive region. If waiting was done inside <CODE><SPAN class="keyword">lock</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> the program would deadlock. So, as a rule of thumb: </P><UL><LI><P>Do not wait inside an exclusive region, if the waking-up action has to acquire the same lock. </P></LI></UL><P> </P><P></P><DIV class="figure" id="asyncchannel"><HR><P><A name="asyncchannel"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Channel</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">prop</SPAN>&nbsp;locking<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;f&nbsp;r<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;f&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X&nbsp;r&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">put</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>r=I<SPAN class="keyword">|</SPAN>X&nbsp;r<SPAN class="keyword">:=</SPAN>X&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">get</SPAN>(?I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>f=I<SPAN class="keyword">|</SPAN>X&nbsp;f<SPAN class="keyword">:=</SPAN>X&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;{Wait&nbsp;I}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;11.2:</STRONG> An Asynchronous Channel Class</P><HR></DIV><P></P></DIV><DIV id="section.objectscc.monitor"><H2><A name="section.objectscc.monitor">11.5 Monitors</A></H2><P>The next example shows a traditional way to write <EM>monitors</EM>. We start by defining a class that defines the notion of events and the monitor operations <CODE>notify(Event)</CODE> and <CODE>wait(Event)</CODE> by specializing the class <CODE>Channel</CODE>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Event</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Channel</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">wait</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Channel&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;get(_)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">notify</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Channel&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;put(<SPAN class="keyword">unit</SPAN>)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>We show here an example of a unit buffer in the traditional monitor style. The unit buffer behaves in a way very similar to a channel when it comes to consumers. Each consumer waits until the buffer is full. In the case of producers only one is allowed to insert an item in the empty buffer. Other producers have to suspend until the item is consumed. The program in <A href="node11.html#ubmonitor">Figure&nbsp;11.3</A> shows a single buffer monitor. Here we had to program a signaling mechanism for producers and consumers. Observe the pattern in <CODE>put<SPAN class="keyword">/</SPAN>1</CODE> and <CODE>get<SPAN class="keyword">/</SPAN>1</CODE> methods. Most execution is done in an exclusive region. If waiting is necessary it is done outside the exclusive region. This is done by using an auxiliary variable <CODE>X</CODE>, which gets bound to <CODE>yes</CODE>. The <CODE>get<SPAN class="keyword">/</SPAN>1</CODE> method notifies one producer at a time by setting the <CODE>empty</CODE> flag and notifying one producer (if any). This is done as an atomic step. The <CODE>put<SPAN class="keyword">/</SPAN>1</CODE> method does the reciprocal action. </P><P></P><DIV class="figure" id="ubmonitor"><HR><P><A name="ubmonitor"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">UnitBufferM</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;item&nbsp;empty&nbsp;psignal&nbsp;csignal<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">prop</SPAN>&nbsp;locking<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;psignal&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Event&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;csignal&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Event&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">put</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>empty&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;I<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;yes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>csignal&nbsp;notify}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;X&nbsp;=&nbsp;no&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;no&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>psignal&nbsp;wait}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;put(I)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">get</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">lock</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{Not&nbsp;<SPAN class="keyword">@</SPAN>empty}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>item<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>psignal&nbsp;notify}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;yes<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;X&nbsp;=&nbsp;no&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;no&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>csignal&nbsp;wait}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;get(I)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;11.3:</STRONG> A Unit Buffer Monitor</P><HR></DIV><P> </P><P>Try the above example by running the following code: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;UB&nbsp;=&nbsp;{New&nbsp;UnitBufferM&nbsp;init}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{For&nbsp;1&nbsp;15&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{UB&nbsp;put(I)}&nbsp;{Delay&nbsp;500}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;{For&nbsp;1&nbsp;15&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{UB&nbsp;get({Browse}}{Delay&nbsp;500}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label63">11.5.1 Bounded Buffers Oz Style</A></H3><P>In Oz, it is very rare to write programs in the monitor style shown above. In general it is very awkward. There is a simpler way to write a <CODE>UnitBuffer</CODE> class that is not traditional. This is due to the combination of objects and logic variable, <A href="node11.html#unitbuffer">Figure&nbsp;11.4</A> shows a simple definition. No locking is needed directly. </P><P></P><DIV class="figure" id="unitbuffer"><HR><P><A name="unitbuffer"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">UnitBuffer</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;prodq&nbsp;buffer<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Channel&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prodq&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Event&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>prodq&nbsp;notify}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">put</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>prodq&nbsp;wait}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>buffer&nbsp;put(I)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">get</SPAN>(?I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>buffer&nbsp;get(I)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>prodq&nbsp;notify}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;11.4:</STRONG> Unit Buffer</P><HR></DIV><P> </P><P>A simple generalization of the above program leads to an arbitrary size bounded buffer class. This is shown in below. The put and get methods are the same as before. Only the initialization method is changed. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">BoundedBuffer</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;UnitBuffer</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;prodq&nbsp;buffer<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(N)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Channel&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prodq&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Event&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;N&nbsp;1&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;_}&nbsp;{<SPAN class="keyword">@</SPAN>prodq&nbsp;notify}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.objectscc.active"><H2><A name="section.objectscc.active">11.6 Active Objects</A></H2><P>An active object is a thread whose behavior is described by a class definition. Communication with active objects is through asynchronous message passing. An active object reacts to received messages by executing the corresponding methods in its associated class. An active object executes one method at a time. Therefore locking is not needed for methods performed by an active object. The interface to an active object is through Oz ports. Clients of an active object send messages to the object by sending messages to its associated port. We will show how to create generically this abstraction. Since active objects resemble servers receiving messages from clients though a network we call this abstraction the server abstraction. To create a server <CODE>S</CODE> from a class Class we execute: </P><BLOCKQUOTE class="code"><CODE>S&nbsp;=&nbsp;{NewServer&nbsp;Class&nbsp;init}</CODE></BLOCKQUOTE><P> </P><P>Here <CODE>init</CODE> is the initial object construction method. To get the basic idea we show first a simplified form of the <CODE>NewServer</CODE> function. The following function: </P><UL><LI><P>creates a port <CODE>Port</CODE>, </P></LI><LI><P>creates an object <CODE>Object</CODE>, and finally </P></LI><LI><P>creates a thread that serves messages sent to the port, by applying the corresponding class methods. </P></LI></UL><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewServer</SPAN>&nbsp;Class&nbsp;Init}<BR>&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">The&nbsp;stream&nbsp;of&nbsp;the&nbsp;port<BR></SPAN>&nbsp;&nbsp;&nbsp;Port&nbsp;=&nbsp;{NewPort&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;Object&nbsp;=&nbsp;{New&nbsp;Class&nbsp;Init}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{ForAll&nbsp;S&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;M}&nbsp;{Object&nbsp;M}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Port<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>We would like to add the ability of terminating the thread by making a protected method <CODE>Close</CODE> accessible to the method in <CODE>Class</CODE>. This leads us to the following extension of the above function. We use the exception handling mechanism to jump out of the receiving loop. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Server</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;close:Close<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">Close</SPAN>&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;closeException&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewServer</SPAN>&nbsp;Class&nbsp;Init}<BR>&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">The&nbsp;stream&nbsp;of&nbsp;the&nbsp;port<BR></SPAN>&nbsp;&nbsp;&nbsp;Port&nbsp;=&nbsp;{NewPort&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;Object&nbsp;=&nbsp;{New&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">$</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Server&nbsp;Class</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;Init}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;&nbsp;{ForAll&nbsp;S&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;M}&nbsp;{Object&nbsp;M}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;closeException&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Port<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node10.html#chapter.classes">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node12.html#chapter.lp">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzén</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
