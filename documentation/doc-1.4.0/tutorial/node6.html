<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>6 Functions</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node5.html#chapter.control">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node7.html#chapter.modules">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.functional"><H1><A name="chapter.functional">6 Functions</A></H1><H2><A name="label41">6.1 Functional Notation</A></H2><P>Oz provides functional notation as syntactic convenience. We have seen that a procedure call: </P><BLOCKQUOTE class="code"><CODE>{P&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn&nbsp;R}</CODE></BLOCKQUOTE><P> could be used in a nested expression as a function call: </P><BLOCKQUOTE class="code"><CODE>{P&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}</CODE></BLOCKQUOTE><P> Oz also allows functional abstractions directly as syntactic notation for procedures. Therefore, the following function definition: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">F</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}&nbsp;</CODE><I>S</I><CODE>&nbsp;</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> where <I>S</I> is a statement and <I>E</I> is an expression corresponds to the following procedure definition: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">F</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn&nbsp;R}&nbsp;</CODE><I>S</I><CODE>&nbsp;R=</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P class="warning"><STRONG>Warning:</STRONG>The exact syntax for functions as well as their transformation into procedure definitions is defined in the <A href="../notation/index.html"><EM>The Oz Notation Reference Manual</EM></A>. </P><P>Here we rely on the reader's intuition. Roughly speaking, the general rule for syntax formation of functions looks very similar to how procedures are formed. With the exception that, whenever a thread of control in a procedure ends in a statement, the corresponding function ends in an expression. </P><P>The program shown in <A href="node6.html#checkbintreelazy3">Figure&nbsp;6.1</A> is the functional equivalent to the program shown in <A href="node5.html#checkbintreelazy">Figure&nbsp;5.7</A>. Notice how the function <CODE>AndThen<SPAN class="keyword">/</SPAN>2</CODE> is unfolded into the procedure <CODE>AndThen<SPAN class="keyword">/</SPAN>3</CODE>. Below we show a number of steps that give some intuition of the transformation process. All the intermediate forms are legal Oz programs. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{BP2}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Make a procedure by introducing a result variable <CODE>B</CODE>: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2&nbsp;B}<BR>&nbsp;&nbsp;&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{BP2}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Move the result variable into the outer <EM>if-expression</EM> to make it an <EM>if-statement</EM>: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2&nbsp;B}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;{BP2}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P></P><DIV class="figure" id="checkbintreelazy3"><HR><P><A name="checkbintreelazy3"></A></P></DIV><BLOCKQUOTE class="code"><CODE>%&nbsp;<SPAN class="comment">Syntax&nbsp;Convenience:&nbsp;functional&nbsp;notation<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{BP2}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">BinaryTree</SPAN>&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K&nbsp;V&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{AndThen<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{BinaryTree&nbsp;T1}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{BinaryTree&nbsp;T2}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;6.1:</STRONG> Checking a binary tree lazily</P><HR></DIV><P> </P><P>If you are a functional programmer, you can cheer up! You have your functions, including higher-order ones, and similar to lazy functional languages Oz allows certain forms of tail-recursion optimizations that are not found in certain strict functional languages <A href="node6.html#label44"><SUP>1</SUP></A> including Standard ML, Scheme, and the concurrent functional language Erlang. However, standard function definitions in Oz are not lazy. Lazy functions are also supported in Oz<A href="node6.html#label45"><SUP>2</SUP></A>. </P><P>Here is an example of the well-known higher order function <CODE>Map<SPAN class="keyword">/</SPAN>2</CODE>. It is tail recursive in Oz but not in Standard ML or in Scheme. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Map</SPAN>&nbsp;Xs&nbsp;F}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{F&nbsp;X}<SPAN class="keyword">|</SPAN>{Map&nbsp;Xr&nbsp;F}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>{Browse&nbsp;{Map&nbsp;[1&nbsp;2&nbsp;3&nbsp;4]&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;X<SPAN class="keyword">*</SPAN>X&nbsp;<SPAN class="keyword">end</SPAN>}}</CODE></BLOCKQUOTE><P> </P><H3><A name="label42">6.1.1 <CODE><SPAN class="keyword">andthen</SPAN></CODE> and <CODE><SPAN class="keyword">orelse</SPAN></CODE></A></H3><P>After all, we have been doing a lot of work for nothing! Oz already provides the Boolean lazy (non-strict) versions of the functions <CODE>And<SPAN class="keyword">/</SPAN>2</CODE> and <CODE>Or<SPAN class="keyword">/</SPAN>2</CODE> as the Boolean operators <CODE><SPAN class="keyword">andthen</SPAN></CODE> and <CODE><SPAN class="keyword">orelse</SPAN></CODE> respectively. The former behaves like the function <CODE>AndThen<SPAN class="keyword">/</SPAN>2</CODE>, and the latter evaluates its second argument only if the first argument evaluates to <CODE><SPAN class="keyword">false</SPAN></CODE>. As usual, these operators are not primitives, they are defined in Oz. <A href="node6.html#checkbintreelazy4">Figure&nbsp;6.2</A> defines the final version of the function <CODE>BinaryTree</CODE>. </P><P></P><DIV class="figure" id="checkbintreelazy4"><HR><P><A name="checkbintreelazy4"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">BinaryTree</SPAN>&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K&nbsp;V&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{BinaryTree&nbsp;T1}&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;{BinaryTree&nbsp;T2}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;6.2:</STRONG> Checking a binary tree lazily</P><HR></DIV><P> </P><H3><A name="label43">6.1.2 To Function or not to function?</A></H3><P>Since now, in principal, we have some syntactic redundancy by either using procedures or functions, the question is when to use functional notation, and when not. The honest answer is that it is up to you! I will tell you my personal opinion. Here are some rules of thumb: </P><UL><LI><P>First, what I do not like. Given that you defined a procedure <CODE>P&nbsp;</CODE>do not call it as a function, i.e. do not use functional nesting for procedures. Use instead procedural nesting, with nesting marker, as in the <CODE>SMerge</CODE> example. Moreover, given that you defined a function, call it as function. </P></LI><LI><P>I tend to use function definitions when things are really functional, i.e. there is one output and, possibly many inputs, and the output is a mathematical function of the input arguments. </P></LI><LI><P>I tend to use procedures in most of the other cases, i.e. multiple outputs or nonfunctional definition due to stateful data types or nondeterministic definitions<A href="node6.html#label46"><SUP>3</SUP></A>. </P></LI><LI><P>One may relax the previous rule and use functions when there is a clear direction of information-flow although the definition is not strictly functional. After all functions are concise. </P></LI></UL><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node5.html#chapter.control">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node7.html#chapter.modules">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label44">1. </A>Strict functional languages evaluate all its argument first before executing the function</DIV><DIV class="footnote"><A name="label45">2. </A>We will discuss them later when talking about <EM>futures</EM> and by need synchronization</DIV><DIV class="footnote"><A name="label46">3. </A>In fact, in those cases the use of the object-oriented style of Oz is most appropriate</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzén</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
