<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>The Actual Real-Interval Constraint</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node15.html#ct.casestudy.impl.profilewakeup">&lt;&lt; Prev</A></TD><TD><A href="node13.html">- Up -</A></TD><TD><A href="node17.html#ct.casestudy.impl.rivar">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="ct.casestudy.impl.constraint"><H4><A name="ct.casestudy.impl.constraint">The Actual Real-Interval Constraint</A></H4><P>The actual real-interval constraint is represented by instances of the class <CODE>RI</CODE>. It stores the upper and lower bound, to approximate a real number. Apart from constructors and initialization functions a couple of general functions are defined. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">RI</SPAN>&nbsp;:&nbsp;<SPAN class="keyword">public</SPAN>&nbsp;<SPAN class="type">OZ_Ct</SPAN>&nbsp;{<BR><SPAN class="keyword">private</SPAN>:<BR>&nbsp;&nbsp;<SPAN class="type">ri_float</SPAN>&nbsp;<SPAN class="variablename">_l</SPAN>,&nbsp;<SPAN class="variablename">_u</SPAN>;<BR>&nbsp;<BR><SPAN class="keyword">public</SPAN>:<BR>&nbsp;&nbsp;<SPAN class="functionname">RI</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{}<BR>&nbsp;&nbsp;<SPAN class="functionname">RI</SPAN>(<SPAN class="type">ri_float</SPAN>&nbsp;<SPAN class="variablename">l</SPAN>,&nbsp;<SPAN class="type">ri_float</SPAN>&nbsp;<SPAN class="variablename">u</SPAN>)&nbsp;:&nbsp;_l(l),&nbsp;_u(u)&nbsp;{}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>)&nbsp;{&nbsp;_l&nbsp;=&nbsp;_u&nbsp;=&nbsp;OZ_floatToC(t);&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="type">ri_float</SPAN>&nbsp;<SPAN class="functionname">getWidth</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;_u&nbsp;-&nbsp;_l;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">OZ_Ct</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">leastConstraint</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">RI</SPAN>&nbsp;<SPAN class="variablename">ri</SPAN>(RI_FLOAT_MIN,&nbsp;RI_FLOAT_MAX);<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;&amp;ri;<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isValidValue</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">f</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;OZ_isFloat(f);<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isTouched</SPAN>(<SPAN class="type">RIProfile</SPAN>&nbsp;<SPAN class="variablename">rip</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(rip._l&nbsp;&lt;&nbsp;_l)&nbsp;||&nbsp;(rip._u&nbsp;&gt;&nbsp;_u);<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;...<BR></PRE></BLOCKQUOTE><P> </P><P> The member functions <CODE>leastConstraint()</CODE> and <CODE>isValidValue()</CODE> are used by class <CODE>RIDefinition</CODE> and their definition is self-explanatory. Note that <CODE>ri_float</CODE> values have to be compatible with Oz float such that <CODE>OZ_float()</CODE> is used for testing compatibility. </P><P>Most of the definitions of virtual member functions and operators used for implementing constraint propagation are self-explanatory. Note that <CODE>copy()</CODE> uses the <CODE>new</CODE> operator provided by <CODE>OZ_Ct</CODE> and the constructor <CODE>RI(ri_float<SPAN class="keyword">,</SPAN>ri_float)</CODE>. The function <CODE>isValue()</CODE> assumes a global variable <CODE>ri_float&nbsp;ri_precision;</CODE> that holds the current precision. </P><BLOCKQUOTE class="linenumbers"><PRE>&nbsp;&nbsp;...<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">char</SPAN>&nbsp;*&nbsp;toString(<SPAN class="type">int</SPAN>);<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">size_t</SPAN>&nbsp;<SPAN class="functionname">sizeOf</SPAN>(<SPAN class="type">void</SPAN>);<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Ct</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">copy</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">RI</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">ri</SPAN>&nbsp;=&nbsp;<SPAN class="keyword">new</SPAN>&nbsp;(<SPAN class="keyword">sizeof</SPAN>(ri_float))&nbsp;<SPAN class="type">RI</SPAN>(_l,&nbsp;_u);<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;ri;<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isValue</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(getWidth()&nbsp;&lt;&nbsp;ri_precision);<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">toValue</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">double</SPAN>&nbsp;<SPAN class="variablename">val</SPAN>&nbsp;=&nbsp;(_u&nbsp;+&nbsp;_l)&nbsp;/&nbsp;2.0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;OZ_float(val);<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isValid</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;_l&nbsp;&lt;=&nbsp;_u;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;...<BR></PRE></BLOCKQUOTE><P> </P><P>The function <CODE>getWakeUpDescriptor()</CODE> computes from the current state of the constraint and a given constraint profile <CODE>p</CODE> a wake-up descriptor. Therefore, it creates an empty one and sets the appropriate events successively. Finally it returns the descriptor. </P><BLOCKQUOTE class="linenumbers"><PRE>&nbsp;&nbsp;...<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;RIProfile&nbsp;*&nbsp;getProfile(<SPAN class="type">void</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">RIProfile</SPAN>&nbsp;<SPAN class="variablename">rip</SPAN>;<BR>&nbsp;&nbsp;&nbsp;&nbsp;rip.init(<SPAN class="keyword">this</SPAN>);<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;&amp;rip;<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="type">OZ_CtWakeUp</SPAN>&nbsp;<SPAN class="functionname">getWakeUpDescriptor</SPAN>(<SPAN class="type">OZ_CtProfile</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">p</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">OZ_CtWakeUp</SPAN>&nbsp;<SPAN class="variablename">d</SPAN>;<BR>&nbsp;&nbsp;&nbsp;&nbsp;d.init();<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">RIProfile</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">rip</SPAN>&nbsp;=&nbsp;(<SPAN class="type">RIProfile</SPAN>&nbsp;*)&nbsp;p;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;(_l&nbsp;&gt;&nbsp;rip-&gt;_l)&nbsp;d.setWakeUp(0);<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;(_u&nbsp;&lt;&nbsp;rip-&gt;_u)&nbsp;d.setWakeUp(1);<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;d;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;...<BR>&nbsp;<BR></PRE></BLOCKQUOTE><P> </P><P>The function <CODE>isWeakerThan()</CODE> simply compares the widths of two real-interval constraints to detect whether the constraint <CODE><SPAN class="keyword">*</SPAN>this</CODE> is subsumed by <CODE><SPAN class="keyword">*</SPAN>r</CODE>. This makes sense since <CODE><SPAN class="keyword">*</SPAN>this</CODE> represents never values not represented by <CODE><SPAN class="keyword">*</SPAN>r</CODE> which is ensured by the runtime system. </P><P>The unification routine for two real-interval constraints computes the intersection of the values approximated by <CODE><SPAN class="keyword">*</SPAN>this</CODE> and <CODE><SPAN class="keyword">*</SPAN>r</CODE>. The result is stored in a static variable and eventually a pointer to this variable is returned. </P><BLOCKQUOTE class="linenumbers"><PRE>&nbsp;&nbsp;...<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;OZ_Boolean&nbsp;isWeakerThan(OZ_Ct&nbsp;*&nbsp;r)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">RI</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">ri</SPAN>&nbsp;=&nbsp;(<SPAN class="type">RI</SPAN>&nbsp;*)&nbsp;r;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(ri-&gt;getWidth()&nbsp;&lt;&nbsp;getWidth());<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Ct</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">unify</SPAN>(<SPAN class="type">OZ_Ct</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">r</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">RI</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">x</SPAN>&nbsp;=&nbsp;<SPAN class="keyword">this</SPAN>,&nbsp;*&nbsp;<SPAN class="variablename">y</SPAN>&nbsp;=&nbsp;(<SPAN class="type">RI</SPAN>&nbsp;*)&nbsp;r;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">RI</SPAN>&nbsp;<SPAN class="variablename">z</SPAN>;&nbsp;&nbsp;<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;z._l&nbsp;=&nbsp;max(x-&gt;_l,&nbsp;y-&gt;_l);<BR>&nbsp;&nbsp;&nbsp;&nbsp;z._u&nbsp;=&nbsp;min(x-&gt;_u,&nbsp;y-&gt;_u);<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;&amp;z;<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">unify</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">rvt</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;(isValidValue(rvt))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">double</SPAN>&nbsp;<SPAN class="variablename">rv</SPAN>&nbsp;=&nbsp;OZ_floatToC(rvt);<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(_l&nbsp;&lt;=&nbsp;rv)&nbsp;&amp;&amp;&nbsp;(rv&nbsp;&lt;=&nbsp;_u);<BR>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;0;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;...<BR></PRE></BLOCKQUOTE><P> The unification routine of a real-interval constraint and a value checks if the value is compatible with float numbers and then, if the value is contained in the set of values represented by the constraint. Note that this function indicates only if a unification is successful and does not update the constraint. </P><P>The operators for constraint propagation are straight-forward. They return the width of the computed constraint. In case the width is less zero, the constraint is inconsistent and thus can be easily tested. </P><BLOCKQUOTE class="linenumbers"><PRE>&nbsp;&nbsp;...<BR>&nbsp;&nbsp;ri_float&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;&lt;=&nbsp;(<SPAN class="type">ri_float</SPAN>&nbsp;<SPAN class="variablename">f</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;_u&nbsp;=&nbsp;min(_u,&nbsp;f);<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;getWidth();<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="type">ri_float</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">&gt;=</SPAN>&nbsp;(<SPAN class="type">ri_float</SPAN>&nbsp;<SPAN class="variablename">f</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;_l&nbsp;=&nbsp;max(_l,&nbsp;f);<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;getWidth();<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="type">ri_float</SPAN>&nbsp;<SPAN class="functionname">lowerBound</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;_l;&nbsp;}<BR>&nbsp;&nbsp;<SPAN class="type">ri_float</SPAN>&nbsp;<SPAN class="functionname">upperBound</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;_u;&nbsp;}<BR>&nbsp;&nbsp;...<BR>};&nbsp;//&nbsp;<SPAN class="comment">class&nbsp;RI<BR></SPAN>&nbsp;<BR></PRE></BLOCKQUOTE><P> The functions <CODE>lowerBound()</CODE> and <CODE>upperBound()</CODE> provide access to the lower resp. upper bound of the constraint. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node15.html#ct.casestudy.impl.profilewakeup">&lt;&lt; Prev</A></TD><TD><A href="node13.html">- Up -</A></TD><TD><A href="node17.html#ct.casestudy.impl.rivar">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
