<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>14 Referring To Distributed Entities: URL</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node48.html#chapter.remote">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node50.html#chapter.resolve">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.urlurl"><H1><A name="chapter.urlurl">14 Referring To Distributed Entities: <CODE>URL</CODE></A></H1><P>In the age of the <EM>World Wide Web</EM>, resources needed by a running system don't just reside in files, they reside at URLs. The <CODE>URL</CODE> module provides an interface for creating and manipulating URLs as data-structures. It fully conforms to URI syntax as defined in RFC&nbsp;2396 <A href="ftp://ftp.isi.edu/in-notes/rfc2396.txt">Uniform Resource Identifiers (URI): Generic Syntax</A> by T.&nbsp;Berners-Lee, R.&nbsp;Fielding, and L.&nbsp;Masinter (August 1998), and passes all 5 test suites published by Roy Fielding.</P><P>The only derogations to said specification were made to accommodate Windows-style filenames: (1) a prefix of the form <I>C</I><CODE>:</CODE> where <I>C</I> is a single character is interpreted as Windows-style device notation rather than as a uri scheme -- in practice, this is a compatible extension since there are no legal single character schemes, (2) path segments may indifferently be separated by <CODE>/</CODE> or <CODE>\</CODE>; this too is compatible since non-separator forward and backward slashes ought to be otherwise <EM>escape encoded</EM>.</P><P>There is additionally a further experimental extension: all urls may be suffixed by a string of the form &quot;{foo=a,bar=b}&quot;. This adds an <EM>info</EM> record to the parsed representation of the url. Here, this record would be <CODE>info(foo:a&nbsp;bar:b)</CODE>. Thus properties can be attached to urls. For example, we may indicate that a url denotes a native functor thus: <CODE>file:/foo/bar/baz.so{native}</CODE>. Here <CODE>{native}</CODE> is equivalent to <CODE>{native=}</CODE>, i.&nbsp;e. the info record is <CODE>info(native:<SPAN class="string">''</SPAN>)</CODE>.</P><H2><A name="label562">14.1 Examples</A></H2><P>Here are a few examples of conversions from url vstrings to url records. Return values are displayed following the function call. </P><DL><DT><CODE>{URL<SPAN class="keyword">.</SPAN>make&nbsp;<SPAN class="string">&quot;http://www.mozart-oz.org/home-1.1.0/share/FD.ozf&quot;</SPAN>}</CODE></DT><DD><P></P><BLOCKQUOTE class="code"><CODE>url(<BR>&nbsp;&nbsp;&nbsp;absolute&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;authority&nbsp;:&nbsp;<SPAN class="string">&quot;www.mozart-oz.org&quot;</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;device&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;fragment&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;[<SPAN class="string">&quot;home-1.1.0&quot;</SPAN>&nbsp;<SPAN class="string">&quot;share&quot;</SPAN>&nbsp;<SPAN class="string">&quot;FD.ozf&quot;</SPAN>]&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;query&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;scheme&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="string">&quot;http&quot;</SPAN>)</CODE></BLOCKQUOTE><P> The <CODE>absolute</CODE> feature has value <CODE><SPAN class="keyword">true</SPAN></CODE> to indicate that the path is absolute i.&nbsp;e. began with a slash. The <CODE>path</CODE> feature is simply the list of path components, as strings.</P></DD><DT><CODE>{URL<SPAN class="keyword">.</SPAN>make&nbsp;<SPAN class="string">&quot;foo/bar/&quot;</SPAN>}</CODE> </DT><DD><P></P><BLOCKQUOTE class="code"><CODE>url(<BR>&nbsp;&nbsp;&nbsp;absolute&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;authority&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;device&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;fragment&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;[<SPAN class="string">&quot;foo&quot;</SPAN>&nbsp;<SPAN class="string">&quot;bar&quot;</SPAN>&nbsp;nil]&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;query&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;scheme&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>)</CODE></BLOCKQUOTE><P> The above illustrates a relative url: the <CODE>absolute</CODE> feature has value <CODE><SPAN class="keyword">false</SPAN></CODE>. Note that the trailing slash results in the empty component <CODE>nil</CODE>. </P></DD><DT><CODE>{URL<SPAN class="keyword">.</SPAN>make&nbsp;<SPAN class="string">&quot;c:\\foo\\bar&quot;</SPAN>}</CODE> </DT><DD><P></P><BLOCKQUOTE class="code"><CODE>url(<BR>&nbsp;&nbsp;&nbsp;absolute&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;authority&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;device&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="string">&amp;c</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;fragment&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;[<SPAN class="string">&quot;foo&quot;</SPAN>&nbsp;<SPAN class="string">&quot;bar&quot;</SPAN>]&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;query&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;scheme&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>)</CODE></BLOCKQUOTE><P> Here the leading <CODE>c:</CODE> was parsed as a Windows-style device notation and the backslashes as component separators. </P></DD><DT><CODE>{URL<SPAN class="keyword">.</SPAN>make&nbsp;<SPAN class="string">&quot;foo.so{native}&quot;</SPAN>}</CODE></DT><DD><P></P><BLOCKQUOTE class="code"><CODE>url(<BR>&nbsp;&nbsp;&nbsp;absolute&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;authority&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;device&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;fragment&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;info(native:nil)&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;[<SPAN class="string">&quot;foo.so&quot;</SPAN>]&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;query&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;scheme&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<SPAN class="keyword">unit</SPAN>)</CODE></BLOCKQUOTE><P> The <CODE>{native}</CODE> annotation is entered into the <CODE>info</CODE> feature. </P></DD></DL><P> </P><H2><A name="label563">14.2 Interface</A></H2><P></P><DL><DT><CODE>URL<SPAN class="keyword">.</SPAN>make</CODE> <A name="label564"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>make&nbsp;</CODE><CODE>+<I>VR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>UrlR</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Parses virtual string <CODE><I>VR</I></CODE> as a url, according to the proposed uri syntax modulo Windows-motivated derogations (see above). Local filename syntax is a special case of scheme-less uri. The parsed representation of a url is a non-empty record whose features hold the various parts of the url, it has the form <CODE>url(<SPAN class="keyword">...</SPAN>)</CODE>. We speak of url records and url vstrings: the former being the parsed representation of the latter. A url record must be non-empty to distinguish it from the url vstring consisting of the atom <CODE>url</CODE>. The empty url record can be written e.&nbsp;g. <CODE>url(<SPAN class="keyword">unit</SPAN>)</CODE>. <CODE><I>VR</I></CODE> may also be a url record, in which case it is simply returned.</P></DD><DT><CODE>URL<SPAN class="keyword">.</SPAN>is</CODE> <A name="label565"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>is&nbsp;</CODE><CODE>+<I>X</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Returns <CODE><SPAN class="keyword">true</SPAN></CODE> iff <CODE><I>X</I></CODE> is a non-empty record labeled with <CODE>url</CODE>.</P></DD><DT><CODE>URL<SPAN class="keyword">.</SPAN>toVirtualString</CODE> <A name="label566"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>toVirtualString&nbsp;</CODE><CODE>+<I>VR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>V</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P><CODE><I>VR</I></CODE> may be a url record or a virtual string. The corresponding normalized vstring representation is returned. #<CODE><I>FRAGMENT</I></CODE> and {<CODE><I>INFO</I></CODE>} segments are not included (see below). This is appropriate for retrieval since fragment and info sections are meant for client-side usage.</P></DD><DT><CODE>URL<SPAN class="keyword">.</SPAN>toVirtualStringExtended</CODE> <A name="label567"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>toVirtualStringExtended&nbsp;</CODE><CODE>+<I>VR</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>HowR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>V</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Similar to the above, but <CODE><I>HowR</I></CODE> is a record with optional boolean features <CODE>full</CODE>, <CODE>cache</CODE>, and <CODE>raw</CODE>. <CODE>full:<SPAN class="keyword">true</SPAN></CODE> indicates that #<I>FRAGMENT</I> and {<I>INFO</I>} sections should be included if present. <CODE>cache:<SPAN class="keyword">true</SPAN></CODE> requests that cache-style syntax be used (see <A href="node50.html#chapter.resolve">Chapter&nbsp;15</A>): the <CODE>:</CODE> following the scheme and the <CODE>//</CODE> preceding the authority are both replaced by single <CODE>/</CODE>. <CODE>raw:<SPAN class="keyword">true</SPAN></CODE> indicates that no escape encoding should take place; this is useful e.g. for Windows filenames that may contain spaces or other characters illegal in URIs.</P></DD><DT><CODE>URL<SPAN class="keyword">.</SPAN>toString</CODE> <A name="label568"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>toString&nbsp;</CODE><CODE>+<I>VR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>S</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Calls <CODE>URL<SPAN class="keyword">.</SPAN>toVirtualString</CODE> and converts the result to a string. </P></DD><DT><CODE>URL<SPAN class="keyword">.</SPAN>toAtom</CODE> <A name="label569"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>toAtom&nbsp;</CODE><CODE>+<I>VR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>A</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Calls <CODE>URL<SPAN class="keyword">.</SPAN>toVirtualString</CODE> and converts the result to an atom. </P></DD><DT><CODE>URL<SPAN class="keyword">.</SPAN>resolve</CODE> <A name="label570"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>resolve&nbsp;</CODE><CODE>+<I>BaseVR</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RelVR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>UrlR</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P><CODE><I>BaseVR</I></CODE> and <CODE><I>RelVR</I></CODE> are url records or vstrings. <CODE><I>RelVR</I></CODE> is resolved relative to <CODE><I>BaseVR</I></CODE> and a new url record is returned with the appropriate fields filled in. </P></DD><DT><CODE>URL<SPAN class="keyword">.</SPAN>normalizePath</CODE> <A name="label571"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>normalizePath&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Given a list <CODE><I>Xs</I></CODE> of string components (see <CODE>path</CODE> feature of a url record), returns a list <CODE><I>Ys</I></CODE> that results from normalizing <CODE><I>Xs</I></CODE>. Normalization is the process of eliminating occurrences of path components <CODE>.</CODE> and <CODE>..</CODE> by interpreting them relative to the stack of path components. A leading <CODE>.</CODE> is preserved because <CODE>./foo</CODE> and <CODE>foo</CODE> should be treated differently: the first one is an absolute path anchored in the current directory, whereas the second one is relative. </P></DD><DT><CODE>URL<SPAN class="keyword">.</SPAN>isAbsolute</CODE> <A name="label572"></A></DT><DT><CODE>URL<SPAN class="keyword">.</SPAN>isRelative</CODE> <A name="label573"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>isAbsolute&nbsp;</CODE><CODE>+<I>VR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>isRelative&nbsp;</CODE><CODE>+<I>VR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>A url is considered absolute if (1) it has a <CODE>scheme</CODE>, or (2) it has a <CODE>device</CODE>, or (3) its <CODE>path</CODE> started with <CODE>/</CODE>, <CODE>~</CODE> (user home directory notation), <CODE>.</CODE> (current directory), or <CODE>..</CODE> (parent directory). For example, <CODE>~rob/foo/baz</CODE> is absolute. </P></DD><DT><CODE>URL<SPAN class="keyword">.</SPAN>toBase</CODE> <A name="label574"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{URL<SPAN class="keyword">.</SPAN>toBase&nbsp;</CODE><CODE>+<I>VR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>UrlR</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Turns a url vstring or record into a url record that can safely be used as a base for <CODE>URL<SPAN class="keyword">.</SPAN>resolve</CODE> without loosing its last component. Basically, it makes sure that there is a slash at the end. </P></DD></DL><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node48.html#chapter.remote">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node50.html#chapter.resolve">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A>, <A href="http://www.ps.uni-sb.de/~homik/">Martin&nbsp;Homik</A>, <A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A>, <A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
