<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2 Module Managers: Module</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.application">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node8.html#chapter.types_modes_constr">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.module"><H1><A name="chapter.module">2 Module Managers: <CODE>Module</CODE></A></H1><P> Module managers grant access to modules identified by urls. Examples and more information on module managers can be found in <A href="../apptut/index.html">``Application Programming''</A>. </P><DIV id="section.module.basic"><H2><A name="section.module.basic">2.1 Basics</A></H2><P> A module manager maintains a <A name="label20"></A><EM>module table</EM>, that maps urls to modules. To be more precise, the table maps a url to a module or to a future for a module (this is explained later). </P><P> A module manager supports the following operations: </P><DL><DT><A name="label21"></A><EM>link</EM> </DT><DD><P>Linking takes a url <I>U</I> as input and returns a module <I>M</I> or a future <I>F</I> for a module. </P><P> We say that <I>M</I> or <I>F</I> is <A name="label22"></A><EM>linked from <I>U</I></EM>. Most of the time we will not distinguish between <I>M</I> and <I>F</I>. </P><P> Depending on whether the module table already contains an entry for <I>M</I>, the following happens: </P><OL type="1"><LI><P>If the module table already contains an entry <I>M</I> for the url <I>U</I>, linking just returns <I>M</I>. </P></LI><LI><P>If no entry for <I>U</I> is available, a new future <I>F</I> is created and stored under <I>U</I> in the module table. <I>F</I> is returned. </P><P> As soon as the value for the future <I>F</I> is requested, a new thread is created that <A name="label23"></A><EM>installs</EM> a module from the url <I>U</I>. This is called <A name="label24"></A><EM>dynamic linking</EM> or <A name="label25"></A><EM>linking on demand</EM>. </P><P> If under the url <I>U</I> a pickled functor is stored, the module is computed by first loading the functor <I>G</I>. Then <I>G</I> is <A name="label26"></A><EM>applied</EM> with respect to the url <I>U</I> (this is explained later) which yields a module to which the future <I>F</I> is bound. This also explains why it is okay to not make a distinction between module and future for a module, since the distinction does not has any consequences as it comes to module access. </P><P> If the url <I>U</I> refers to a system module (see also <A href="../apptut/node4.html#chapter.modman">Chapter&nbsp;3 of ``Application Programming''</A>) the system module is returned. </P><P> The url <I>U</I> can also refer to a native functor, this is described in detail in <A href="../apptut/node19.html#part.foreign.extensions">Part&nbsp;VI of ``Application Programming''</A>. </P></LI></OL><P> </P></DD><DT><A name="label27"></A><EM>apply</EM> </DT><DD><P>Application takes a functor <I>F</I> and a <A name="label28"></A><EM>base url</EM> <I>U</I> and returns a module <I>M</I>. </P><P> First the import urls of <I>F</I> are resolved with respect to the base url <I>U</I>. Then the resolved urls are used for linking. The returned modules are called <A name="label29"></A><EM>argument modules</EM>. Then the body of the functor is applied to the argument modules. </P></DD><DT><A name="label30"></A><EM>enter</EM> </DT><DD><P>Entering takes a url <I>U</I> and a module <I>M</I> as input. </P><P> The module <I>M</I> is added to the module table under <I>U</I>. If the module table already contains an entry for <I>U</I>, an exception is raised. </P></DD></DL><P> </P><P> A module manager is implemented as an instance of the class <CODE>Module<SPAN class="keyword">.</SPAN>manager</CODE>. The class provides methods to link and apply functors and to enter modules into the module manager's module table. </P></DIV><DIV id="section.modules.names"><H2><A name="section.modules.names">2.2 Module Names and URLs</A></H2><P> As has been explained above, each module is refered to by a url <I>U</I>, some of which are Oz specific in that they refer to system modules. We just say that the module <EM>has the url</EM> <I>U</I>. </P><P> A <EM>module name</EM> is a shortcut for a module url. The mapping of module names to full urls is explained in detail in <A href="../apptut/node4.html#chapter.modman">Chapter&nbsp;3 of ``Application Programming''</A>. </P></DIV><DIV id="section.modules.link"><H2><A name="section.modules.link">2.3 The Class <CODE>Module<SPAN class="keyword">.</SPAN>manager</CODE></A></H2><P> Module managers are created as instances of the class <CODE>Module<SPAN class="keyword">.</SPAN>manager</CODE>. For predefined abstractions that are build on top of module managers see <A href="node7.html#section.modules.abstractions">Section&nbsp;2.4</A>. </P><P> </P><DL><DT><A name="label31"></A><SPAN class="index"><CODE>init</CODE></SPAN> <A name="label32"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>init()</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Initializes the module manager. </P></DD><DT><A name="label33"></A><SPAN class="index"><CODE>link</CODE></SPAN> <A name="label34"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>link(url:</CODE><CODE>+<I>UrlV</I></CODE><CODE>&nbsp;</CODE><CODE><I>ModuleR</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_)</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>link(name:</CODE><CODE>+<I>NameV</I></CODE><CODE>&nbsp;</CODE><CODE><I>ModuleR</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_)</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Links the module identified either by a url <CODE><I>UrlV</I></CODE> (a virtual string) or a module name <CODE><I>NameV</I></CODE> (a virtual string). Returns the module <CODE><I>ModuleR</I></CODE> (which might be a future to a module). </P><P> The argument for the module is optional, if it is omitted the module is requested immediately. </P></DD><DT><A name="label35"></A><SPAN class="index"><CODE>apply</CODE></SPAN> <A name="label36"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>apply(</CODE><CODE>+<I>Functor</I></CODE><CODE>&nbsp;</CODE><CODE><I>ModuleR</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_)</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>apply(url:</CODE><CODE>+<I>UrlV</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Functor</I></CODE><CODE>&nbsp;</CODE><CODE><I>ModuleR</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_)</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>apply(name:</CODE><CODE>+<I>NameV</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Functor</I></CODE><CODE>&nbsp;</CODE><CODE><I>ModuleR</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_)</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Applies the functor <CODE><I>Functor</I></CODE>, where the url <CODE><I>UrlV</I></CODE> (a virtual string) or the module name <CODE><I>NameV</I></CODE> (a virtual string) serve as base url for linking the functor's import. If neither a module name nor a url is given, the current working directory is taken as base url. </P><P> The argument for the module is optional. </P><P> Please note that the resulting module is <EM>not</EM> added to the module table, the URL argument only serves as base url for the functor's import. </P></DD><DT><A name="label37"></A><SPAN class="index"><CODE>enter</CODE></SPAN> <A name="label38"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>enter(url:</CODE><CODE>+<I>UrlV</I></CODE><CODE>&nbsp;</CODE><CODE><I>ModuleR</I></CODE><CODE>)</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>enter(name:</CODE><CODE>+<I>NameV</I></CODE><CODE>&nbsp;</CODE><CODE><I>ModuleR</I></CODE><CODE>)</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Installs the module <CODE><I>ModuleR</I></CODE> under the url <CODE><I>UrlV</I></CODE> (a virtual string) or the module name <CODE><I>NameV</I></CODE> (a virtual string). </P><P> Raises an exception if the module manager already has a module under that particular url installed. </P></DD></DL><P> </P></DIV><DIV id="section.modules.abstractions"><H2><A name="section.modules.abstractions">2.4 Predefined Abstractions</A></H2><P> </P><DL><DT><A name="label39"></A><SPAN class="index"><CODE>link</CODE></SPAN> <A name="label40"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{Module<SPAN class="keyword">.</SPAN>link&nbsp;</CODE><CODE>+<I>UrlVs</I></CODE><CODE>&nbsp;</CODE><CODE><I>Rs</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Takes a list <CODE><I>UrlVs</I></CODE> of urls (as virtual strings) and and returns the list of modules created by linking. </P><P> All functors are linked by the same module manager, however each application of <CODE>Module<SPAN class="keyword">.</SPAN>link</CODE> employs a new module manager. This has the following consequences: </P><UL><LI><P>Modules imported by several functors are shared. </P></LI><LI><P>Each application of <CODE>Module<SPAN class="keyword">.</SPAN>link</CODE> links required functors anew. That is, after replacing a functor on the file system, an application of <CODE>Module<SPAN class="keyword">.</SPAN>link</CODE> considers the new functor for linking. </P></LI></UL><P> </P><P> <CODE>Module<SPAN class="keyword">.</SPAN>link</CODE> is defined as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Module.link</SPAN>&nbsp;UrlVs}<BR>&nbsp;&nbsp;&nbsp;ModMan&nbsp;=&nbsp;{New&nbsp;Module<SPAN class="keyword">.</SPAN>manager&nbsp;init}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Map&nbsp;UrlVs&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;Url}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ModMan&nbsp;link(url:Url&nbsp;$)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DD><DT><A name="label41"></A><SPAN class="index"><CODE>apply</CODE></SPAN> <A name="label42"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{Module<SPAN class="keyword">.</SPAN>apply&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE><I>Rs</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Takes a list of functors or pairs of urls (as virtual strings) as input. The url in a pair of url and functor describes the base url with which the import urls of the functor gets resolved. If it is missing the current working directory is used for url resolution. </P><P> Returns a list of modules computed by functor application. </P><P> <CODE>Module<SPAN class="keyword">.</SPAN>apply</CODE> is defined as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Module.apply</SPAN>&nbsp;UFs}<BR>&nbsp;&nbsp;&nbsp;ModMan&nbsp;=&nbsp;{New&nbsp;Module<SPAN class="keyword">.</SPAN>manager&nbsp;init}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Map&nbsp;UFs&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;UF}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;UF&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;U<SPAN class="keyword">#</SPAN>F&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ModMan&nbsp;apply(url:U&nbsp;F&nbsp;$)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ModMan&nbsp;apply(UF&nbsp;$)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DD></DL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.application">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node8.html#chapter.types_modes_constr">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A>, <A href="http://www.ps.uni-sb.de/~homik/">Martin&nbsp;Homik</A>, <A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A>, <A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
