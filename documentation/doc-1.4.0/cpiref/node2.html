<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1.2 The class OZ_Expect</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#r_overview">&lt;&lt; Prev</A></TD><TD><A href="ip.html">- Up -</A></TD><TD><A href="node3.html#r_prop">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="r_expect"><H2><A name="r_expect">1.2 The class <CODE>OZ_Expect</CODE></A></H2><P>The functionality provided by class <CODE>OZ_Expect</CODE> is intended to be used for implementing header functions. </P><P> </P><DIV id="expect.types"><H3><A name="expect.types">1.2.1 Types</A></H3><P> </P><DL><DT class="datatype"><CODE>OZ_expect_t</CODE> <A name="label2"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>data type</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">struct</SPAN>&nbsp;<SPAN class="type">OZ_expect_t</SPAN>&nbsp;{<BR>&nbsp;&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">size</SPAN>,&nbsp;<SPAN class="variablename">accepted</SPAN>;<BR>&nbsp;&nbsp;<SPAN class="functionname">OZ_expect_t</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">s</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">a</SPAN>)&nbsp;:&nbsp;size(s),&nbsp;accepted(a)&nbsp;{}<BR>};</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Return type of member functions which check for constraints on parameters (see <A href="node2.html#expect.checkconstr">Section&nbsp;1.2.4</A>). </P></DD><DT class="enumtype"><CODE>OZ_FDPropState</CODE> <A name="label3"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>enumerable  type</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">enum</SPAN>&nbsp;&nbsp;<BR><SPAN class="type">OZ_FDPropState</SPAN>&nbsp;{<SPAN class="variablename">fd_prop_singl</SPAN>&nbsp;=&nbsp;0,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="variablename">fd_prop_bounds</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="variablename">fd_prop_any</SPAN>};</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>The values of this enumerable type are used to determine what kind of pruning of a finite domain causes a propagator to be resumed. The values <CODE>OZ_FDPropState</CODE> have the following meaning. </P><P></P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>value</P></TH><TH><P>rerun propagator in case ...</P></TH></TR><TR valign="top"><TD><P><CODE>fd_prop_singl</CODE></P></TD><TD><P>... a finite domain becomes a singleton.</P></TD></TR><TR valign="top"><TD><P><CODE>fd_prop_bounds</CODE></P></TD><TD><P>... the bounds of a finite domain are narrowed.</P></TD></TR><TR valign="top"><TD><P><CODE>fd_prop_any</CODE></P></TD><TD><P>... an arbitrary value is removed from a finite</P></TD></TR><TR valign="top"><TD><P></P></TD><TD><P>domain or an equality constraint is imposed.</P></TD></TR></TABLE><P> </P></DD><DT class="enumtype"><CODE>OZ_FSetPropState</CODE> <A name="label4"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>enumerable  type</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">enum</SPAN>&nbsp;&nbsp;<BR><SPAN class="type">OZ_FSetPropState</SPAN>&nbsp;{<SPAN class="variablename">fs_prop_glb</SPAN>&nbsp;=&nbsp;0,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="variablename">fs_prop_lub</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="variablename">fs_prop_val</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="variablename">fs_prop_any</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="variablename">fs_prop_bounds</SPAN>};</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>The values of this enumerable type are used to determine what kind of pruning of a finite set constraint causes a propagator to be resumed. The values <CODE>OZ_FSetPropState</CODE> have the following meaning. </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>value</P></TH><TH><P>rerun propagator in case ...</P></TH></TR><TR valign="top"><TD><P><CODE>fs_prop_val</CODE></P></TD><TD><P>... a finite set constraint becomes a finite set value.</P></TD></TR><TR valign="top"><TD><P><CODE>fs_prop_glb</CODE></P></TD><TD><P>... a value is added to a set.</P></TD></TR><TR valign="top"><TD><P><CODE>fs_prop_lub</CODE></P></TD><TD><P>... a value is removed from a set.</P></TD></TR><TR valign="top"><TD><P><CODE>fs_prop_bounds</CODE></P></TD><TD><P>... a value is added to or removed from a set.</P></TD></TR><TR valign="top"><TD><P><CODE>fs_prop_any</CODE></P></TD><TD><P>... either the conditions for <CODE>fs_prop_bounds</CODE> apply</P></TD></TR><TR valign="top"><TD><P></P></TD><TD><P>or an equality constraint is imposed.</P></TD></TR></TABLE><P> </P></DD><DT class="datatype"><CODE>OZ_ExpectMeth</CODE> <A name="label5"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>data type</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">typedef</SPAN>&nbsp;<BR><SPAN class="type">OZ_expect_t</SPAN>&nbsp;(<SPAN class="reference">OZ_Expect</SPAN>::*<SPAN class="type">OZ_ExpectMeth</SPAN>)(OZ_Term)</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Type of member functions which check for constraints on parameters (see <A href="node2.html#expect.checkconstr">Section&nbsp;1.2.4</A>). </P></DD></DL><P> </P></DIV><DIV id="expect.condes"><H3><A name="expect.condes">1.2.2 Constructor and Destructor</A></H3><P> </P><DL><DT class="default"><CODE>OZ_expect</CODE> <A name="label6"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>default constructor</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>OZ_Expect(<SPAN class="type">void</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Default constructor of the class <CODE>OZ_Expect</CODE>. </P></DD><DT class="destructor"><CODE>~OZ_expect</CODE> <A name="label7"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>destructor</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>~OZ_Expect();</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Destructor of the class <CODE>OZ_Expect</CODE>. </P></DD></DL><P> </P></DIV><DIV id="expect.setdescr"><H3><A name="expect.setdescr">1.2.3 Specification of a Set of Integers</A></H3><P> Specification of a set of integers is mainly used in context with finite domain and finite set constraints. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>level_4</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><I>level_3</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>compl(<I>level_3</I>)</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>level_3</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><I>level_2</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>[<I>level_2</I>+]</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>nil</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>level_2</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><I>level_1</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>level_1</I><CODE><SPAN class="keyword">#</SPAN></CODE><I>level_1</I></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>level_1</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>OZ_getFDInf()</CODE>,...,<CODE>OZ_getFDSup()</CODE> </TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>(in case of <CODE>OZ_Expect<SPAN class="keyword">::</SPAN>expectDomDescr()</CODE>)</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>OZ_getFSetInf()</CODE>,...,<CODE>OZ_getFSetSup()</CODE> </TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>(in case of <CODE>OZ_Expect<SPAN class="keyword">::</SPAN>expectFSetDescr()</CODE>)</TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><DIV id="expect.checkconstr"><H3><A name="expect.checkconstr">1.2.4 Member Functions for Checking the Constraint Store</A></H3><P> A member function described in this section takes as first argument a term, typically a parameter of a propagator. Extra arguments allow to control the behaviour of the member function or to specify the way subterms are to be checked. The returned value is of type <CODE>OZ_expect_t</CODE> and denotes the result of the examination of the constraint store.</P><P> </P><DL><DT class="member"><CODE>expectDomDescr</CODE> <A name="label8"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectDomDescr</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">descr</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">level</SPAN>&nbsp;=&nbsp;4);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This member function expects <CODE>descr</CODE> to be a finite domain specification (see <A href="node2.html#expect.setdescr">Section&nbsp;1.2.3</A>) according to <CODE>level</CODE>. The non-terminal <EM>level_n</EM> in <A href="node2.html#expect.setdescr">Section&nbsp;1.2.3</A> corresponds to <CODE>level=n</CODE>. </P></DD><DT class="member"><CODE>expectFSetDescr</CODE> <A name="label9"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectFSetDescr</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">descr</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">level</SPAN>&nbsp;=&nbsp;4);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This member function expects <CODE>descr</CODE> to be a finite set specification (see <A href="node2.html#expect.setdescr">Section&nbsp;1.2.3</A>) according to <CODE>level</CODE>. The non-terminal <EM>level_n</EM> in <A href="node2.html#expect.setdescr">Section&nbsp;1.2.3</A> corresponds to <CODE>level=n</CODE>. </P></DD><DT class="member"><CODE>expectVar</CODE> <A name="label10"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectVar</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a variable. A determined term <CODE>t</CODE> is regarded as an inconsistency. </P></DD><DT class="member"><CODE>expectRecordVar</CODE> <A name="label11"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectRecordVar</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a record. </P></DD><DT class="member"><CODE>expectBoolVar</CODE> <A name="label12"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectBoolVar</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a finite domain variable with domain <IMG alt="\{0,1\}" src="latex1.png"> resp. the value 0 or 1. </P></DD><DT class="member"><CODE>expectIntVar</CODE> <A name="label13"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;&nbsp;<BR><SPAN class="functionname">expectIntVar</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">OZ_FDPropState</SPAN>&nbsp;<SPAN class="variablename">ps</SPAN>&nbsp;=&nbsp;fd_prop_any);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a finite domain variable or a finite domain integer. The value of <CODE>ps</CODE> controls on what events the propagator has to be resumed. See the explanation on <CODE>OZ_FDPropState</CODE> in <A href="node2.html#expect.types">Section&nbsp;1.2.1</A> for the values of <CODE>ps</CODE>. </P></DD><DT class="member"><CODE>expectFSetVar</CODE> <A name="label14"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;&nbsp;<BR><SPAN class="functionname">expectFSetVar</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">OZ_FSetPropState</SPAN>&nbsp;<SPAN class="variablename">ps</SPAN>&nbsp;=&nbsp;fs_prop_any);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a finite set variable or a finite set value. The value of <CODE>ps</CODE> controls on what events the propagator has to be resumed. See the explanation on <CODE>OZ_FSetPropState</CODE> in <A href="node2.html#expect.types">Section&nbsp;1.2.1</A> for the values of <CODE>ps</CODE>. </P></DD><DT class="member"><CODE>expectGenCtVar</CODE> <A name="label15"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectGenCtVar</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">OZ_CtDefinition</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">def</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">OZ_CtWakeUp</SPAN>&nbsp;<SPAN class="variablename">w</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a constrained variable resp. a compatible value according to <CODE>def</CODE>. The value <CODE>w</CODE> determines the event the propagator is reinvoked. See <A href="node10.html#ct.reference.def">Section&nbsp;2.1</A> for details on <CODE>OZ_CtDefinition</CODE> and <A href="node11.html#ct.reference.wakeup">Section&nbsp;2.2</A> for details on <CODE>OZ_CtWakeUp</CODE>. </P></DD><DT class="member"><CODE>expectInt</CODE> <A name="label16"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectInt</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a small integer. See the systems manual <A href="../foreign/index.html">``Interfacing to C and C++''</A> for details. </P></DD><DT class="member"><CODE>expectFloat</CODE> <A name="label17"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectFloat</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a float. </P></DD><DT class="member"><CODE>expectFSetValue</CODE> <A name="label18"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectFSetValue</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a finite set value. </P></DD><DT class="member"><CODE>expectLiteral</CODE> <A name="label19"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectLiteral</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a literal. </P></DD><DT class="member"><CODE>expectLiteralOutOf</CODE> <A name="label20"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectLiteralOutOf</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">ls</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a literal contained in <CODE>ls</CODE> where <CODE>ls</CODE> points to an array of literals terminated with <CODE>(OZ_Term)&nbsp;<SPAN class="reference">NULL</SPAN></CODE>. </P></DD><DT class="member"><CODE>expectVector</CODE> <A name="label21"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectVector</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">OZ_ExpectMeth</SPAN>&nbsp;<SPAN class="variablename">expect_f</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a vector of terms which are all sufficiently constrained with respect to <CODE>expect_f</CODE>. A vector is either a tuple, a closed record, or a list. </P></DD><DT class="member"><CODE>expectProperRecord</CODE> <A name="label22"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectProperRecord</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">OZ_ExpectMeth</SPAN>&nbsp;<SPAN class="variablename">expect_f</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a proper record where all subtrees are sufficiently constrained with respect to <CODE>expect_f</CODE>. A proper record expects its subtrees to be indexed by literals. </P></DD><DT class="member"><CODE>expectProperRecord</CODE> <A name="label23"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectProperRecord</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">ar</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a proper record with at least subtrees under the features in <CODE>ar</CODE> are present where <CODE>ar</CODE> points to an array of features terminated with <CODE>(OZ_Term)&nbsp;<SPAN class="reference">NULL</SPAN></CODE>. </P></DD><DT class="member"><CODE>expectProperTuple</CODE> <A name="label24"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectProperTuple</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">OZ_ExpectMeth</SPAN>&nbsp;<SPAN class="variablename">expect_f</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a proper tuple where all subtrees are sufficiently constrained with respect to <CODE>expect_f</CODE>. A proper tuple expects its subtrees to be indexed by integers. </P></DD><DT class="member"><CODE>expectList</CODE> <A name="label25"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectList</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;<SPAN class="type">OZ_ExpectMeth</SPAN>&nbsp;<SPAN class="variablename">expect_f</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects <CODE>t</CODE> to be a list where all elements are sufficiently constrained with respect to <CODE>expect_f</CODE>. A list is either the atom <CODE>nil</CODE> or a 2-tuple with label <CODE><SPAN class="string">'|'</SPAN></CODE> where the second element is a list again. </P></DD><DT class="member"><CODE>expectStream</CODE> <A name="label26"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="functionname">expectStream</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">st</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Expects either an unbound variable or <CODE>nil</CODE> resp. a 2-tuple with label <CODE><SPAN class="string">'|'</SPAN></CODE> where the second element is a stream too. </P></DD></DL><P> </P></DIV><DIV id="expect.control"><H3><A name="expect.control">1.2.5 Member Functions for Control Purposes</A></H3><P> </P><DL><DT class="member"><CODE>collectVarsOn</CODE> <A name="label27"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">collectVarsOn</SPAN>(<SPAN class="type">void</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This member function turns collecting variables <EM>on</EM>. That means that pruning of parameters checked in this mode may cause the propagator to be resumed. </P></DD><DT class="member"><CODE>collectVarsOff</CODE> <A name="label28"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">collectVarsOff</SPAN>(<SPAN class="type">void</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This member function turns collecting variables <EM>off</EM>. That means that pruning of parameters checked in this mode <EM>cannot</EM> cause the propagator to be resumed. </P></DD><DT class="member"><CODE>impose</CODE> <A name="label29"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">impose</SPAN>(<SPAN class="type">OZ_Propagator</SPAN>&nbsp;*<SPAN class="variablename">p</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>The propagator <CODE>p</CODE> is imposed. The return value is the result of the initial invocation of <CODE><SPAN class="reference">OZ_Propagator</SPAN>::propagate()</CODE>. </P></DD><DT class="member"><CODE>suspend</CODE> <A name="label30"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">suspend</SPAN>(<SPAN class="type">OZ_Thread</SPAN>&nbsp;<SPAN class="variablename">th</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This member function is to be called if the header function has to be suspended. The thread <CODE>th</CODE> can be created with <CODE>OZ_makeSuspendedThread()</CODE> which is defined by the S<SPAN class="allcaps">CI</SPAN> (see <A href="../foreign/index.html">``Interfacing to C and C++''</A> for details). </P></DD><DT class="member"><CODE>fail</CODE> <A name="label31"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">fail</SPAN>(<SPAN class="type">void</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This member function is to be called if an inconsistency has been detected. </P></DD><DT class="member"><CODE>isSuspending</CODE> <A name="label32"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isSuspending</SPAN>(<SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="variablename">r</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_TRUE</CODE> if <CODE>r</CODE> indicates that constraints expected on a parameter are not present in the current store. Otherwise it returns <CODE>OZ_FALSE</CODE>.</P><P></P></DD><DT class="member"><CODE>isFailing</CODE> <A name="label33"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isFailing</SPAN>(<SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="variablename">r</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_TRUE</CODE> if <CODE>r</CODE> indicates an inconsistency. Otherwise it returns <CODE>OZ_FALSE</CODE>. </P></DD><DT class="member"><CODE>isExceptional</CODE> <A name="label34"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isFailing</SPAN>(<SPAN class="type">OZ_expect_t</SPAN>&nbsp;<SPAN class="variablename">r</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_TRUE</CODE> if <CODE>r</CODE> indicates an inconsistency causing an exception. Otherwise it returns <CODE>OZ_FALSE</CODE>. </P></DD></DL><P> </P></DIV><DIV id="expect.macros"><H3><A name="expect.macros">1.2.6 Macros</A></H3><P> </P><DL><DT class="macro"><CODE>OZ_EXPECTED_TYPE</CODE> <A name="label35"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>macro</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>OZ_EXPECTED_TYPE(S)</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This macro declares a C/C++ string used by the macros <CODE>OZ_EXPECT</CODE> and <CODE>OZ_EXPECT_SUPEND</CODE> in case an inconsistency is detected. For details see <A href="../cpitut/node5.html#u_nesting.impose">Section&nbsp;1.4.2 of ``The Mozart Constraint Extensions Tutorial''</A>. </P></DD><DT class="macro"><CODE>OZ_EM</CODE> <A name="label36"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>macro</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P>The macros <CODE>OZ_EM_</CODE> are provided to create standardized error messages. </P></BLOCKQUOTE></DD><DD><P></P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>expected constraint</P></TH><TH><P>macro to be used</P></TH></TR><TR valign="top"><TD><P>literal</P></TD><TD><P><CODE>OZ_EM_LIT</CODE></P></TD></TR><TR valign="top"><TD><P>float</P></TD><TD><P><CODE>OZ_EM_FLOAT</CODE></P></TD></TR><TR valign="top"><TD><P>small integer</P></TD><TD><P><CODE>OZ_EM_INT</CODE></P></TD></TR><TR valign="top"><TD><P>finite domain integer</P></TD><TD><P><CODE>OZ_EM_FD</CODE></P></TD></TR><TR valign="top"><TD><P>boolean finite domain integer in <IMG alt="\{0,1\}" src="latex1.png"></P></TD><TD><P><CODE>OZ_EM_FDBOOL</CODE></P></TD></TR><TR valign="top"><TD><P>description of a finite domain integer</P></TD><TD><P><CODE>OZ_EM_FDDESCR</CODE></P></TD></TR><TR valign="top"><TD><P>finite set of integers</P></TD><TD><P><CODE>OZ_EM_FSETVAL</CODE></P></TD></TR><TR valign="top"><TD><P>finite set of integers constraint</P></TD><TD><P><CODE>OZ_EM_FSET</CODE></P></TD></TR><TR valign="top"><TD><P>description of a finite set of integers</P></TD><TD><P><CODE>OZ_EM_FSETDESCR</CODE></P></TD></TR><TR valign="top"><TD><P>vector of</P></TD><TD><P><CODE>OZ_EM_VECT</CODE></P></TD></TR><TR valign="top"><TD><P>record of</P></TD><TD><P><CODE>OZ_EM_RECORD</CODE></P></TD></TR><TR valign="top"><TD><P>truth name</P></TD><TD><P><CODE>OZ_EM_TNAME</CODE></P></TD></TR><TR valign="top"><TD><P>stream</P></TD><TD><P><CODE>OZ_EM_STREAM</CODE></P></TD></TR></TABLE><P> </P></DD><DT class="macro"><CODE>OZ_EXPECT</CODE> <A name="label37"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>macro</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>OZ_EXPECT(O,&nbsp;P,&nbsp;F)</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This macros checks if a term occurring at argument position <CODE>P</CODE> of a S<SPAN class="allcaps">CI</SPAN> function is currently expectedly constrained with respect to the function <CODE>F</CODE>. The first parameter <CODE>O</CODE> must be an instance of the class <CODE>OZ_Expect</CODE> resp. a class derived from it. Only if the expected constraints are available in the store the code following this macro is executed.</P><P></P></DD><DT class="macro"><CODE>OZ_EXPECT_SUSPEND</CODE> <A name="label38"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>macro</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>OZ_EXPECT_SUSPEND(O,&nbsp;P,&nbsp;F,&nbsp;SC)</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This macros has the same semantics as the previous one except that in case that expected constraints are currently not present in the store the counter <CODE>SC</CODE> is incremented and the following code is executed. </P></DD></DL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#r_overview">&lt;&lt; Prev</A></TD><TD><A href="ip.html">- Up -</A></TD><TD><A href="node3.html#r_prop">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
