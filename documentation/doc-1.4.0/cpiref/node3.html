<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1.3 The class OZ_Propagator</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#r_expect">&lt;&lt; Prev</A></TD><TD><A href="ip.html">- Up -</A></TD><TD><A href="node4.html#r_fdint">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="r_prop"><H2><A name="r_prop">1.3 The class <CODE>OZ_Propagator</CODE></A></H2><P>This class is the base class of all propagators to be implemented. Since this class is a virtual base class, it is not possible to create an instance of that class.</P><P> </P><DIV id="r_prop.constr"><H3><A name="r_prop.constr">1.3.1 Constructor and Destructor Member Functions</A></H3><P> </P><DL><DT class="default"><CODE>OZ_Propagator</CODE> <A name="label39"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>default constructor</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_Propagator(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This constructor is to be called whenever an instance of a class derived from <CODE>OZ_Propagator</CODE> is created. </P></DD><DT class="virtual"><CODE>~OZ_Propagator</CODE> <A name="label40"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>virtual destructor</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="keyword">virtual</SPAN>&nbsp;~<SPAN class="functionname">OZ_Propagator</SPAN>();</CODE> </P></BLOCKQUOTE></DD><DD><P>This destructor is defined to be virtual to force the destructors in the derived classes to be virtual. This ensure that destroying a derived class results in calling the destructor of the derived class. </P></DD></DL><P> </P></DIV><DIV id="r_prop.operator"><H3><A name="r_prop.operator">1.3.2 Operator Member Functions</A></H3><P> </P><DL><DT class="static"><CODE><SPAN class="keyword">new</SPAN></CODE> <A name="label41"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>static operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">void</SPAN>&nbsp;*&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="keyword">new</SPAN>(<SPAN class="type">size_t</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This operator allocates the appropriate amount of heap memory when a propagator is created. </P></DD><DT class="static"><CODE><SPAN class="keyword">delete</SPAN></CODE> <A name="label42"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>static operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">void</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="keyword">delete</SPAN>(<SPAN class="type">void</SPAN>&nbsp;*,&nbsp;size_t);</CODE> </P></BLOCKQUOTE></DD><DD><P>This operator deallocates the heap memory occupied by a propagator when it is destroyed. </P></DD></DL><P> </P></DIV><DIV id="r_prop.provided"><H3><A name="r_prop.provided">1.3.3 Provided Member Functions</A></H3><P> </P><DL><DT class="member"><CODE>mayBeEqualVars</CODE> <A name="label43"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">mayBeEqualVars</SPAN>(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This member function returns <CODE>OZ_TRUE</CODE> if at least one variable the propagator was imposed on has been unified. Otherwise it returns <CODE>OZ_FALSE</CODE>. See <A href="../cpitut/node8.html#u_advanced.detect">Section&nbsp;1.7.1 of ``The Mozart Constraint Extensions Tutorial''</A> for details. </P></DD><DT class="member"><CODE>replaceBy</CODE> <A name="label44"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">replaceBy</SPAN>(<SPAN class="type">OZ_Propagator</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">p</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This member function replaces the current propagator (i.&nbsp;e. <CODE>*<SPAN class="keyword">this</SPAN></CODE>) by the propagator <CODE>p</CODE>. </P></DD><DT class="member"><CODE>replaceBy</CODE> <A name="label45"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">replaceBy</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">a</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">b</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This member function replaces the current propagator (i.&nbsp;e. <CODE>*<SPAN class="keyword">this</SPAN></CODE>) by the equality constraint between <CODE>a</CODE> and <CODE>b</CODE>.</P><P>Caution: before <CODE>replaceBy</CODE> can be called, for all <CODE>x</CODE> of type <CODE>OZ_FDIntVar</CODE> the member function <CODE>x.leave()</CODE> has to be called.</P><P></P></DD><DT class="member"><CODE>replaceByInt</CODE> <A name="label46"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">replaceByInt</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">v</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">i</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This member function replaces the current propagator (i.&nbsp;e. <CODE>*<SPAN class="keyword">this</SPAN></CODE>) by the equality constraint between <CODE>v</CODE> and <CODE>i</CODE>. </P></DD><DT class="member"><CODE>postpone</CODE> <A name="label47"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">postpone</SPAN>(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This member function (usually in conjunction with the <CODE><SPAN class="keyword">return</SPAN></CODE> statement) causes the execution of the propagator to be postponed, i.&nbsp;e. the propagator is immediately switched to <CODE>runnable</CODE> and put at the end of the thread queue. </P></DD><DT class="member"><CODE>imposeOn</CODE> <A name="label48"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">imposeOn</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This member function imposes the current propagator (i.&nbsp;e. <CODE>*<SPAN class="keyword">this</SPAN></CODE>}) on <CODE>t</CODE>. If the imposition was successful, i.&nbsp;e., <CODE>t</CODE> refers to a variable, <CODE>OZ_TRUE</CODE> is returned, otherwise <CODE>OZ_FALSE</CODE>. </P></DD><DT class="member"><CODE>addImpose</CODE> <A name="label49"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">addImpose</SPAN>(<SPAN class="type">OZ_FDPropState</SPAN>&nbsp;<SPAN class="variablename">s</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">v</SPAN>);<BR><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">addImpose</SPAN>(<SPAN class="type">OZ_FSetPropState</SPAN>&nbsp;<SPAN class="variablename">s</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">v</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>These member functions add <CODE>v</CODE> to the parameters of the propagator to be imposed with next invocation of <CODE><SPAN class="reference">OZ_Propagator</SPAN>::impose</CODE>. In case <CODE>v</CODE> does not denote a variable nothing happens. The value of <CODE>s</CODE> determines the event when the propagator is to be resumed.</P><P></P></DD><DT class="member"><CODE>impose</CODE> <A name="label50"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">impose</SPAN>(<SPAN class="type">OZ_Propagator</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">p</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This member function imposes the propagator <CODE>p</CODE> on the parameters collected by <CODE>addImpose</CODE>. The propagator is immediately switched to <EM>runnable</EM>, but not initially run. </P></DD><DT class="constant"><CODE>toString</CODE> <A name="label51"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">char</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">toString</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns a textual representation of the propagator pointing to a static array of <CODE><SPAN class="type">char</SPAN></CODE>s. </P></DD></DL><P> </P></DIV><DIV id="r_prop.todefine"><H3><A name="r_prop.todefine">1.3.4 Member Functions to be Defined by the Programmer</A></H3><P>The member functions in this section are purely virtual, i.&nbsp;e., a class inheriting from <CODE>OZ_Propagator</CODE> <EM>must</EM> define these functions, otherwise it is not possible to create instances of such a class. These pure virtual member functions make <CODE>OZ_Propagator</CODE> to an abstract base class.</P><P> </P><DL><DT class="pure"><CODE>sizeOf</CODE> <A name="label52"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>virtual member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">size_t</SPAN>&nbsp;<SPAN class="functionname">sizeOf</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;=&nbsp;0;</CODE> </P></BLOCKQUOTE></DD><DD><P>The implementation of this pure virtual function in a derived class <CODE>P</CODE> is supposed to return the size of an instance of <CODE>P</CODE>. </P></DD><DT class="pure"><CODE>sClone</CODE> <A name="label53"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>virtual member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">sClone</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;=&nbsp;0;</CODE> </P></BLOCKQUOTE></DD><DD><P>The implementation of this pure virtual function in a derived class <CODE>P</CODE> is called during cloning and is supposed to apply to each data member of type <CODE>OZ_Term</CODE> the function <CODE>OZ_sCloneTerm</CODE> (see <A href="node9.html#r_aux">Section&nbsp;1.9</A>) and possibly, copy dynamically allocated extensions of the object's state. Further details on that issue can be found in <A href="../cpitut/node8.html#u_advanced.redundant">Section&nbsp;1.7.2 of ``The Mozart Constraint Extensions Tutorial''</A>.</P><P></P></DD><DT class="pure"><CODE>gCollect</CODE> <A name="label54"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>virtual member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">gCollect</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;=&nbsp;0;</CODE> </P></BLOCKQUOTE></DD><DD><P>The implementation of this pure virtual function in a derived class <CODE>P</CODE> is called during garbage collection and is supposed to apply to each data member of type <CODE>OZ_Term</CODE> the function <CODE>OZ_sCloneTerm</CODE> (see <A href="node9.html#r_aux">Section&nbsp;1.9</A>) and possibly, copy dynamically allocated extensions of the object's state. Further details on that issue can be found in <A href="../cpitut/node8.html#u_advanced.redundant">Section&nbsp;1.7.2 of ``The Mozart Constraint Extensions Tutorial''</A>.</P><P></P></DD><DT class="pure"><CODE>propagate</CODE> <A name="label55"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>virtual member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">propagate</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;=&nbsp;0;</CODE> </P></BLOCKQUOTE></DD><DD><P>The implementation of this pure virtual function in a derived class <CODE>P</CODE> is supposed to implement the operational semantics of the propagator. The return value indicates the result of the computation to the emulator. </P></DD><DT class="pure"><CODE>getParameters</CODE> <A name="label56"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>virtual member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">getParameters</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>&nbsp;=&nbsp;0;</CODE> </P></BLOCKQUOTE></DD><DD><P>The implementation of this pure virtual function in a derived class <CODE>P</CODE> is supposed to return the list (as Oz data structure) of <CODE>P</CODE>'s parameters. Nested parameter structures are to be represented as nested lists.</P><P></P></DD><DT class="pure"><CODE>getProfile</CODE> <A name="label57"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>virtual member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_PropagatorProfile</SPAN>&nbsp;<SPAN class="functionname">getProfile</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>&nbsp;=&nbsp;0;</CODE> </P></BLOCKQUOTE></DD><DD><P>The implementation of this pure virtual function in a derived class <CODE>P</CODE> is supposed to return the static profile member function used to get information about the state of a propagator class (for instance, the number of total invocations). </P></DD></DL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#r_expect">&lt;&lt; Prev</A></TD><TD><A href="ip.html">- Up -</A></TD><TD><A href="node4.html#r_fdint">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
