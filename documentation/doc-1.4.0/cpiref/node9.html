<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1.9 Auxiliary Interface Functions</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html#r_fsc">&lt;&lt; Prev</A></TD><TD><A href="ip.html">- Up -</A></TD></TR></TABLE><DIV id="r_aux"><H2><A name="r_aux">1.9 Auxiliary Interface Functions</A></H2><P> </P><DL><DT class="function"><CODE>OZ_gCollectTerm</CODE> <A name="label227"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">OZ_gCollectTerm</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;&amp;<SPAN class="variablename">t</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>During garbage collection this function updates the reference <CODE>t</CODE> to a term on the heap. This is typically required when the member function <CODE>gCollect()</CODE> of a propagator is invoked. </P></DD><DT class="function"><CODE>OZ_gCollectBlock</CODE> <A name="label228"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">OZ_gCollectBlock</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">frm</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">to</SPAN>,&nbsp;<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>During garbage collection this function updates the <CODE>n</CODE> elememts in <CODE>frm</CODE> and stores them in <CODE>to</CODE>. </P></DD><DT class="function"><CODE>OZ_gCollectAllocBlock</CODE> <A name="label229"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_Term&nbsp;*&nbsp;OZ_gCollectAllocBlock(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>,&nbsp;OZ_Term&nbsp;*&nbsp;frm);</CODE> </P></BLOCKQUOTE></DD><DD><P>During garbage collection this function updates the <CODE>n</CODE> elements in <CODE>frm</CODE> and returns a pointer to the updates. The updates are stored in freshly allocated heap memory. </P></DD><DT class="function"><CODE>OZ_sCloneTerm</CODE> <A name="label230"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">OZ_sCloneTerm</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;&amp;<SPAN class="variablename">t</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>During cloning this function updates the reference <CODE>t</CODE> to a term on the heap. This is typically required when the member function <CODE>sClone()</CODE> of a propagator is invoked. </P></DD><DT class="function"><CODE>OZ_sCloneBlock</CODE> <A name="label231"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">OZ_sCloneBlock</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">frm</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">to</SPAN>,&nbsp;<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>During cloning this function updates the <CODE>n</CODE> elememts in <CODE>frm</CODE> and stores them in <CODE>to</CODE>. </P></DD><DT class="function"><CODE>OZ_sCloneAllocBlock</CODE> <A name="label232"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_Term&nbsp;*&nbsp;OZ_sCloneAllocBlock(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>,&nbsp;OZ_Term&nbsp;*&nbsp;frm);</CODE> </P></BLOCKQUOTE></DD><DD><P>During cloning this function updates the <CODE>n</CODE> elements in <CODE>frm</CODE> and returns a pointer to the updates. The updates are stored in freshly allocated heap memory. </P></DD><DT class="function"><CODE>OZ_isPosSmallInt</CODE> <A name="label233"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">OZ_isPosSmallInt</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">val</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function returns <CODE>OZ_TRUE</CODE> if <CODE>val</CODE> denotes an integer contained in the finite set <IMG alt="\{0, \ldots, \mbox{\tt OZ\_getFDSup()}\}" src="latex9.png">. Otherwise it returns <CODE>OZ_FALSE</CODE>. </P></DD><DT class="function"><CODE>OZ_hallocOzTerms</CODE> <A name="label234"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_Term&nbsp;*&nbsp;OZ_hallocOzTerms(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function allocates a block of heap memory for <CODE>n</CODE> items of type <CODE>OZ_Term</CODE> and returns a pointer to the block. </P></DD><DT class="function"><CODE>OZ_hallocChars</CODE> <A name="label235"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">char</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">OZ_hallocChars</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function allocates a block of heap memory for <CODE>n</CODE> items of type <CODE><SPAN class="type">char</SPAN></CODE> and returns a pointer to the block. </P></DD><DT class="function"><CODE>OZ_hallocCInts</CODE> <A name="label236"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">OZ_hallocCInts</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function allocates a block of heap memory for <CODE>n</CODE> items of type <CODE><SPAN class="type">int</SPAN></CODE> and returns a pointer to the block. </P></DD><DT class="function"><CODE>OZ_hfreeOzTerms</CODE> <A name="label237"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">OZ_hfreeOzTerms</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">ts</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>The function frees the heap memory allocated by <CODE>OZ_hallocOzTerms()</CODE>. The first argument <CODE>ts</CODE> points to a memory block and the value of <CODE>n</CODE> must denote the correct size of the block. </P></DD><DT class="function"><CODE>OZ_hfreeCInts</CODE> <A name="label238"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">OZ_hfreeCInts</SPAN>(<SPAN class="type">int</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">is</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>The function frees the heap memory allocated by <CODE>OZ_hallocCInts</CODE>. The first argument <CODE>is</CODE> points to a memory block and the value of <CODE>n</CODE> must denote the correct size of the block. </P></DD><DT class="function"><CODE>OZ_hfreeChars</CODE> <A name="label239"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">OZ_hfreeChars</SPAN>(<SPAN class="type">char</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">is</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>The function frees the heap memory allocated by <CODE>OZ_hallocChars()</CODE>. The first argument <CODE>is</CODE> points to a memory block and the value of <CODE>n</CODE> must denote the correct size of the block. </P></DD><DT class="function"><CODE>OZ_copyCInts</CODE> <A name="label240"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">OZ_copyCInts</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">is</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Copies <CODE>n</CODE> <CODE><SPAN class="type">int</SPAN></CODE>s from <CODE>is</CODE> and returns the location of the copy. If <CODE>n</CODE> is equal to 0 it returns <CODE>(<SPAN class="type">int</SPAN>&nbsp;*)&nbsp;<SPAN class="reference">NULL</SPAN></CODE>. </P></DD><DT class="function"><CODE>OZ_copyChars</CODE> <A name="label241"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">char</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">OZ_copyChars</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">n</SPAN>,&nbsp;<SPAN class="type">char</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">cs</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Copies <CODE>n</CODE> <CODE><SPAN class="type">char</SPAN></CODE>s from <CODE>cs</CODE> and returns the location of the copy. If <CODE>n</CODE> is equal to 0 it returns <CODE>(<SPAN class="type">char</SPAN>&nbsp;*)&nbsp;<SPAN class="reference">NULL</SPAN></CODE>. </P></DD><DT class="function"><CODE>OZ_findEqualVars</CODE> <A name="label242"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">OZ_findEqualVars</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">sz</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">ts</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>The function expects <CODE>ts</CODE> to be a pointer to an <CODE>OZ_Term</CODE> array of size <CODE>sz</CODE>. It returns an array of <CODE><SPAN class="type">int</SPAN></CODE>s indicating variables which are equal. Suppose that the <IMG alt="i" src="latex16.png">th field of the returned array holds one of the following values.</P><P></P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>value</P></TH><TH><P>explanation</P></TH></TR><TR valign="top"><TD><P>-1</P></TD><TD><P>The term stored at that position is not a variable.</P></TD></TR><TR valign="top"><TD><P><IMG alt="i" src="latex16.png"></P></TD><TD><P>This is the first occurrence of a variable stored in the array at position <IMG alt="i" src="latex16.png">.</P></TD></TR><TR valign="top"><TD><P><IMG alt="j \neq i" src="latex17.png"></P></TD><TD><P>This is a repeated occurrence of a variable stored at position <IMG alt="j" src="latex18.png"> in the array.</P></TD></TR><TR valign="top"><TD><P></P></TD><TD><P>The first occurrence can be found at position <IMG alt="j" src="latex18.png">. </P></TD></TR></TABLE><P></P><P>The returned <CODE><SPAN class="type">int</SPAN></CODE> array is statically allocated, i.&nbsp;e. it is overridden on every invocation. For details see <A href="../cpitut/node8.html#u_advanced.detect">Section&nbsp;1.7.1 of ``The Mozart Constraint Extensions Tutorial''</A>. </P></DD><DT class="function"><CODE>OZ_isEqualVars</CODE> <A name="label243"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">OZ_isEqualVars</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">v1</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">v2</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function returns <CODE>OZ_TRUE</CODE> if <CODE>v1</CODE> and <CODE>v2</CODE> refer to the same variable. Otherwise it returns <CODE>OZ_FALSE</CODE>. </P></DD><DT class="function"><CODE>OZ_findSingletons</CODE> <A name="label244"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">OZ_findSingletons</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">sz</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">ts</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>The function expects <CODE>ts</CODE> to be a pointer to an <CODE>OZ_Term</CODE> array of size <CODE>sz</CODE> which expects its elements to refer to finite domain variables. It returns an array of <CODE><SPAN class="type">int</SPAN></CODE>s indicating variables which are singletons. Suppose that the <IMG alt="i" src="latex16.png">th field of the returned array holds one of the following values.</P><P></P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>value</P></TH><TH><P>explanation</P></TH></TR><TR valign="top"><TD><P><IMG alt="\geq 0" src="latex19.png"></P></TD><TD><P>The term stored at that position is a singleton.</P></TD></TR><TR valign="top"><TD><P>otherwise</P></TD><TD><P>The term stored at that position is still a finite domain variable.</P></TD></TR></TABLE><P></P><P>The returned <CODE><SPAN class="type">int</SPAN></CODE> array is statically allocated, i.&nbsp;e. it is overridden on every invocation. </P></DD><DT class="function"><CODE>OZ_typeErrorCPI</CODE> <A name="label245"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">OZ_typeErrorCPI</SPAN>(<SPAN class="type">char</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">__typeString</SPAN>,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">pos</SPAN>,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">char</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">comment</SPAN>);</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>The return value of this function indicates the runtime system that an exception has to be raised. The message printed is composed using the <CODE>pos</CODE>th substring of <CODE>__typeString</CODE> and <CODE>comment</CODE>. </P></DD><DT class="function"><CODE>OZ_getFDInf</CODE> <A name="label246"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">OZ_getFDInf</SPAN>(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function returns the value of the smallest element a finite domain which is represented by an instance of the class <CODE>OZ_FiniteDomain</CODE> can take. The value returned is 0. </P></DD><DT class="function"><CODE>OZ_getFDSup</CODE> <A name="label247"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">OZ_getFDSup</SPAN>(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function returns the value of the largest element a finite domain which is represented by an instance of the class <CODE>OZ_FiniteDomain</CODE> can take. The value returned is <IMG alt="134\;217\;726" src="latex2.png">. </P></DD><DT class="function"><CODE>OZ_getFSetInf</CODE> <A name="label248"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">OZ_getFSetInf</SPAN>(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function returns the value of the smallest element a finite set value which is represented by an instance of the class <CODE>OZ_FSetValue</CODE> can take. The value returned is 0. </P></DD><DT class="function"><CODE>OZ_getFSetSup</CODE> <A name="label249"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">OZ_getFSetSup</SPAN>(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function returns the value of the largest element a finite set value which is represented by an instance of the class <CODE>OZ_FSetValue</CODE> can take. The value returned is <IMG alt="134\;217\;726" src="latex2.png">. </P></DD><DT class="function"><CODE>OZ_fsetValue</CODE> <A name="label250"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">OZ_fsetValue</SPAN>(<SPAN class="type">OZ_FSetValue</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">fsv</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function converts the finite set value <CODE>fsv</CODE> to the corresponding <CODE>OZ_Term</CODE>. </P></DD><DT class="function"><CODE>OZ_fsetValueToC</CODE> <A name="label251"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_FSetValue&nbsp;*&nbsp;OZ_fsetValueToC(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">fsv</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function converts <CODE>fsv</CODE>, referring to a finite set value, to a pointer to the finite set value. </P></DD><DT class="function"><CODE>OZ_vectorSize</CODE> <A name="label252"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">OZ_vectorSize</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function returns the size of a vector. In case <CODE>t</CODE> is no vector it returns -1.</P><P></P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>type</P></TH><TH><P>returned value</P></TH></TR><TR valign="top"><TD><P>Literal</P></TD><TD><P>The value returned is 0.</P></TD></TR><TR valign="top"><TD><P>List</P></TD><TD><P>he value returned is the length of the list.</P></TD></TR><TR valign="top"><TD><P>Tuple</P></TD><TD><P>The value returned is the arity of the tuple.</P></TD></TR><TR valign="top"><TD><P>Record</P></TD><TD><P>The value returned is the number of features of the record.</P></TD></TR></TABLE><P> </P></DD><DT class="function"><CODE>OZ_getOzTermVector</CODE> <A name="label253"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_Term&nbsp;*&nbsp;OZ_getOzTermVector(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;OZ_Term&nbsp;*&nbsp;v);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function expects <CODE>t</CODE> to be a vector and <CODE>v</CODE> to be an array with minimal <CODE>OZ_vectorSize(t)</CODE> elements. It converts <CODE>t</CODE> to an <CODE>OZ_Term</CODE> array and returns a pointer to the next free position in the array <CODE>v</CODE> after converting <CODE>t</CODE>. In case <CODE>t</CODE> is no vector the function returns <CODE><SPAN class="reference">NULL</SPAN></CODE>. </P></DD><DT class="function"><CODE>OZ_getCIntVector</CODE> <A name="label254"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">OZ_getCIntVector</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">t</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;*&nbsp;<SPAN class="variablename">v</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This function expects <CODE>t</CODE> to be a vector of small integers and <CODE>v</CODE> to be an array with minimal <CODE>OZ_vectorSize(t)</CODE> elements. It converts <CODE>t</CODE> to an <CODE><SPAN class="type">int</SPAN></CODE> array and returns a pointer to the next free position in the array <CODE>v</CODE> after converting <CODE>t</CODE>. In case <CODE>t</CODE> is no vector the function returns <CODE><SPAN class="reference">NULL</SPAN></CODE>. </P></DD></DL><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html#r_fsc">&lt;&lt; Prev</A></TD><TD><A href="ip.html">- Up -</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
