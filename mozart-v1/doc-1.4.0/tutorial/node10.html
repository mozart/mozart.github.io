<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>10 Classes and Objects</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node9.html#chapter.stateful">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node11.html#chapter.objectscc">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.classes"><H1><A name="chapter.classes">10 Classes and Objects</A></H1><P>A Class in Oz is a chunk that contains: </P><UL><LI><P>A collection of methods in a method table. </P></LI><LI><P>A description of the attributes that each instance of the class will possess. Each attribute is a stateful cell that is accessed by the attribute-name, which is either an atom or an Oz-name. </P></LI><LI><P>A description of the features that each instance of the class will possess. A feature is an immutable component (a variable) that is accessed by the feature-name, which is either an atom or an Oz-name. </P></LI><LI><P>Classes are stateless Oz-values<A href="node10.html#label57"><SUP>1</SUP></A>. Contrary to languages like Smalltalk, or Java etc., they are just descriptions of how the objects of the class should behave. </P></LI></UL><P> </P><DIV id="section.classes.classprinciples"><H2><A name="section.classes.classprinciples">10.1 Classes from First Principles</A></H2><P><A href="node10.html#classconstr">Figure&nbsp;10.1</A> shows how a class is constructed from first principles as outlined above. Here we construct a <CODE>Counter</CODE> class. It has a single attribute accessed by the atom val. It has a method table, which has three methods accessed through the chunk features <CODE>browse</CODE>, <CODE>init</CODE> and <CODE>inc</CODE>. A method is a procedure that takes a message, always a record, an extra parameter representing the state of the current object, and the object itself known internally as <CODE><SPAN class="keyword">self</SPAN></CODE>. </P><P></P><DIV class="figure" id="classconstr"><HR><P><A name="classconstr"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Counter<BR><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Attrs&nbsp;=&nbsp;[val]<BR>&nbsp;&nbsp;&nbsp;MethodTable&nbsp;=&nbsp;m(browse:MyBrowse&nbsp;init:Init&nbsp;inc:Inc)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Init</SPAN>&nbsp;M&nbsp;S&nbsp;Self}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init(Value)&nbsp;=&nbsp;M&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(S<SPAN class="keyword">.</SPAN>val)&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;Value<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Inc</SPAN>&nbsp;M&nbsp;S&nbsp;Self}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;inc(Value)=M<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>(S<SPAN class="keyword">.</SPAN>val)&nbsp;(S<SPAN class="keyword">.</SPAN>val)&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X<SPAN class="keyword">+</SPAN>Value&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MyBrowse</SPAN>&nbsp;M=browse&nbsp;S&nbsp;Self}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>(S<SPAN class="keyword">.</SPAN>val)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Counter&nbsp;=&nbsp;{NewChunk&nbsp;c(methods:MethodTable&nbsp;attrs:Attrs)}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.1:</STRONG> An Example of Class construction</P><HR></DIV><P> </P><P> As we can see, the method <CODE>init</CODE> assigns the attribute <CODE>val</CODE> the value <CODE>Value</CODE>, the method <CODE>inc</CODE> increments the attribute <CODE>val</CODE>, and the method <CODE>browse</CODE> browses the current value of <CODE>val</CODE>. </P></DIV><DIV id="section.classes.objectprinciples"><H2><A name="section.classes.objectprinciples">10.2 Objects from First Principles</A></H2><P><A href="node10.html#objectconstr">Figure&nbsp;10.2</A> shows a generic procedure that creates an object from a given class. This procedure creates an object state from the attributes of the class. It initializes the attributes of the object, each to a cell (with unbound initial value). We use here the iterator <CODE>Record<SPAN class="keyword">.</SPAN>forAll<SPAN class="keyword">/</SPAN>2</CODE> that iterates over all fields of a record. <CODE>NewObject</CODE> returns a procedure <CODE>Object</CODE> that identifies the object. Notice that the state of the object is visible only within <CODE>Object</CODE>. One may say that <CODE>Object</CODE> is a procedure that encapsulates the state<A href="node10.html#label58"><SUP>2</SUP></A>. </P><P></P><DIV class="figure" id="objectconstr"><HR><P><A name="objectconstr"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewObject</SPAN>&nbsp;Class&nbsp;InitialMethod&nbsp;?Object}<BR>&nbsp;&nbsp;&nbsp;State&nbsp;O<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;State&nbsp;=&nbsp;{MakeRecord&nbsp;s&nbsp;Class<SPAN class="keyword">.</SPAN>attrs}<BR>&nbsp;&nbsp;&nbsp;{Record<SPAN class="keyword">.</SPAN>forAll&nbsp;State&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;A}&nbsp;{NewCell&nbsp;_&nbsp;A}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">O</SPAN>&nbsp;M}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Class<SPAN class="keyword">.</SPAN>methods<SPAN class="keyword">.</SPAN>{Label&nbsp;M}&nbsp;M&nbsp;State&nbsp;O}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{O&nbsp;InitialMethod}<BR>&nbsp;&nbsp;&nbsp;Object&nbsp;=&nbsp;O<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.2:</STRONG> Object Construction</P><HR></DIV><P> </P><P>We can try our program as follows </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;C<BR>{NewObject&nbsp;Counter&nbsp;init(0)&nbsp;C}<BR>{C&nbsp;inc(6)}&nbsp;{C&nbsp;inc(6)}<BR>{C&nbsp;browse}</CODE></BLOCKQUOTE><P> </P><P>Try to execute the following statement. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{C&nbsp;inc(X)}&nbsp;X=5&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;{C&nbsp;browse}</CODE></BLOCKQUOTE><P> </P><P>You will see that nothing happens. The reason is that the object application </P><BLOCKQUOTE class="code"><CODE>{C&nbsp;inc(X)}</CODE></BLOCKQUOTE><P> </P><P>suspends inside the procedure <CODE>Inc<SPAN class="keyword">/</SPAN>3</CODE> that implements method <CODE>inc</CODE>. Do you know where exactly? If you on the other hand execute the following statement, things will work as expected. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{C&nbsp;inc(X)}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;X=5&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;{C&nbsp;browse}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.forreal"><H2><A name="section.classes.forreal">10.3 Objects and Classes for Real</A></H2><P>Oz supports object-oriented programming following the methodology outlined above. There is also syntactic support and optimized implementation so that object application (calling a method in objects) is as cheap as procedure calls. The class <CODE>Counter</CODE> defined earlier has the syntactic form shown in <A href="node10.html#counterclass">Figure&nbsp;10.3</A>: </P><P></P><DIV class="figure" id="counterclass"><HR><P><A name="counterclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Counter</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;val<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">browse</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>val}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">inc</SPAN>(Value)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>val&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;Value<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(Value)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;Value<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.3:</STRONG> Counter Class</P><HR></DIV><P> </P><P>A class <I>X</I> is defined by: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;</CODE><I>X</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Attributes are defined using the attribute-declaration part before the method-declaration part: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">attr</SPAN>&nbsp;</CODE><I>A1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>AN</I></BLOCKQUOTE><P> </P><P>Then follows the method declarations, each has the form: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">meth</SPAN>&nbsp;</CODE><I>E</I><CODE>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="functionname">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>where the expression <I>E</I> evaluates to a method head, which is a record whose label is the method name. An attribute <I>A</I> is accessed using the expression <CODE><SPAN class="keyword">@</SPAN></CODE><I>A</I>. It is assigned a value using the statement <I>A</I><CODE>&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;</CODE><I>E</I>. </P><P>A class can be defined anonymously by: </P><BLOCKQUOTE class="code"><CODE>X&nbsp;=&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">$</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>The following shows how an object is created from a class using the procedure <CODE>New<SPAN class="keyword">/</SPAN>3</CODE>, whose first argument is the class, the second is the initial method, and the result is the object. <CODE>New<SPAN class="keyword">/</SPAN>3</CODE> is a generic procedure for creating objects from classes. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;C&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>C&nbsp;=&nbsp;{New&nbsp;Counter&nbsp;init(0)}<BR>{C&nbsp;browse}<BR>{C&nbsp;inc(1)}<BR><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{C&nbsp;inc(X)}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;X=5&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label53">10.3.1 Static Method Calls</A></H3><P>Given a class <I>C</I> and a method head <I>m</I><CODE>(<SPAN class="keyword">...</SPAN>)</CODE>, a method call has the following form: </P><BLOCKQUOTE class="code"><I>C</I><CODE><SPAN class="keyword">,</SPAN>&nbsp;</CODE><I>m</I><CODE>(<SPAN class="keyword">...</SPAN>)</CODE></BLOCKQUOTE><P> </P><P>A method call invokes the method defined in the class argument. A method call can only be used inside method definitions. This is because a method call takes the current object denoted by <CODE><SPAN class="keyword">self</SPAN></CODE> as implicit argument. The method could be defined at the class <CODE>C</CODE> or inherited from a super class. Inheritance will be explained shortly. </P><H3><A name="label54">10.3.2 Classes as Modules</A></H3><P>Static method calls have in general the same efficiency as procedure calls. This allows classes to be used as module-specification. This may be advantageous because classes can be built incrementally by inheritance. The program shown in <A href="node10.html#listclass">Figure&nbsp;10.4</A> shows a possible class acting as a module specification. The class <CODE>ListC</CODE> defines some common list-procedures as methods. <CODE>ListC</CODE> defines the methods <CODE>append<SPAN class="keyword">/</SPAN>3</CODE>, <CODE>member<SPAN class="keyword">/</SPAN>2</CODE>, <CODE>length<SPAN class="keyword">/</SPAN>2</CODE>, and <CODE>nrev<SPAN class="keyword">/</SPAN>2</CODE>. Notice that a method body is similar to any Oz statement but in addition, method calls are allowed. We also see the first example of inheritance. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ListC</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN></CODE></BLOCKQUOTE><P> We also show functional methods, i.e. methods that return results similar to functions. A functional method has in general the following form: </P><BLOCKQUOTE class="code"><CODE>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;$)&nbsp;S&nbsp;E&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;</CODE></BLOCKQUOTE><P> </P><P>Here the class <CODE>ListC</CODE> inherits from the predefined class <CODE>BaseObject</CODE> that has only one trivial method: <CODE><SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">noop</SPAN>()&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE>. </P><P></P><DIV class="figure" id="listclass"><HR><P><A name="listclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ListC</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">append</SPAN>(Xs&nbsp;Ys&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Ys<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X<SPAN class="keyword">|</SPAN>(ListC&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;append(Xr&nbsp;Ys&nbsp;$))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">member</SPAN>(X&nbsp;L&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Member&nbsp;X&nbsp;L}&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">This&nbsp;defined&nbsp;in&nbsp;List.oz<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">length</SPAN>(Xs&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;_<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ListC&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;length(Xr&nbsp;$))&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">nrev</SPAN>(Xs&nbsp;?Ys)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Ys&nbsp;=&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Yr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListC&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;nrev(Xr&nbsp;Yr)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListC&nbsp;<SPAN class="keyword">,</SPAN>&nbsp;append(Yr&nbsp;[X]&nbsp;Ys)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.4:</STRONG> List Class</P><HR></DIV><P> </P><P>To create a module from the module specification one needs to create an object from the class. This is done by: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;ListM&nbsp;=&nbsp;{New&nbsp;ListC&nbsp;noop}</CODE></BLOCKQUOTE><P> </P><P><CODE>ListM</CODE> is an object that acts as a module, i.e. it encapsulates a group of procedures (methods). We can try this module by performing some method calls: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{ListM&nbsp;append([1&nbsp;2&nbsp;3]&nbsp;[4&nbsp;5]&nbsp;$)}}</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{ListM&nbsp;length([1&nbsp;2&nbsp;3]&nbsp;&nbsp;$)}}</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{ListM&nbsp;nrev([1&nbsp;2&nbsp;3]&nbsp;&nbsp;$)}}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.inheritance"><H2><A name="section.classes.inheritance">10.4 Inheritance</A></H2><P>Classes may inherit from one or several classes appearing after the keyword: <CODE><SPAN class="keyword">from</SPAN></CODE>. A class <I>B</I> is a <EM>superclass</EM> of a class <I>A</I> if: </P><UL><LI><P><I>B</I> appears in the <CODE><SPAN class="keyword">from</SPAN></CODE> declaration of <I>A</I>, or </P></LI><LI><P><I>B</I> is a superclass of a class appearing in the <CODE><SPAN class="keyword">from</SPAN></CODE> declaration of <I>A</I>. </P></LI></UL><P> </P><P>Inheritance is a way to construct new classes from existing classes. It defines what attributes, features<A href="node10.html#label59"><SUP>3</SUP></A>, and methods are available in the new class. We will restrict our discussion of inheritance to methods. Nonetheless, the same rules apply to features and attributes. </P><P>The methods available in a class <I>C</I> (i.e. visible) are defined through a precedence relation on the methods that appear in the class hierarchy. We call this relation the <EM>overriding relation</EM>: </P><UL><LI><P>A method in a class <I>C</I> overrides any method, with the same label, in any super class of <I>C</I>. </P></LI></UL><P> </P><P>Now a class hierarchy with the super-class relation can be seen as a directed graph with the class being defined as the root. The edges are directed towards the subclasses. There are two requirements for the inheritance to be valid. First, the inheritance relation is directed and acyclic. So the following is not allowed: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">A</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;B</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">B</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;A</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P></P><DIV class="figure" id="cycle"><HR><P><A name="cycle"></A></P></DIV><DIV align="center"><IMG alt="" src="image161.gif"></DIV><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.5:</STRONG> Illegal class hierarchy</P><HR></DIV><P> </P><P>Second, after striking out all overridden methods each remaining method should have a unique label and is defined only in one class in the hierarchy. Hence, class <CODE>C</CODE> in the following example is not valid because the two methods labeled <CODE>m</CODE> remain. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">A1</SPAN>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">B1</SPAN>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">B</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;B1</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">A</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;A1</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;A&nbsp;B</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P></P><DIV class="figure" id="illegalclassinheritance"><HR><P><A name="illegalclassinheritance"></A></P></DIV><DIV align="center"><IMG alt="" src="inheritance1.gif"></DIV><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.6:</STRONG> Illegal class hierarchy in method <CODE>m</CODE></P><HR></DIV><P> </P><P>Also the class <CODE>C</CODE> below is invalid, since two methods <CODE>m</CODE> is available in <CODE>C</CODE>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">A</SPAN>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">B</SPAN>&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;A&nbsp;B</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Notice that if you run a program with an invalid hierarchy, the system will not complain until an object is created that tries to access an invalid method. Only at this point of time, you are going to get a runtime exception. The reason is that classes are partially formed at compile time, and are completed by demand, using method caches, at execution time. </P><H3><A name="label55">10.4.1 Multiple inheritance or Not</A></H3><P>My opinion is the following: </P><UL><LI><P>In general, to use multiple inheritance correctly, one has to understand the total inheritance hierarchy, which is sometimes worth the effort. This is important when there is a shared common ancestor. </P></LI><LI><P>Oz restricts multiple inheritance in a way that most the problems with it do not occur. </P></LI><LI><P>Oz enforces a programming methodology which requres one to override a method which is defined at more than one superclass, one has to define the method locally to overrides the conflict-causing methods. </P></LI><LI><P>There is another problem with multiple inheritance when sibling super-classes share (directly or indirectly) a common ancestor-class that is stateful (i.e. has attributes). One may get replicated operations on the same attribute. This typically happens when executing an initialization method in a class, one has to initialize its super classes. The only remedy here is to understand carefully the inheritance hierarchy to avoid such replication. Alternatively, you should only inherit from multiple classes that do not share stateful common ancestor. This problem is known as the implementation-sharing problem. </P></LI></UL><P> </P></DIV><DIV id="section.classes.features"><H2><A name="section.classes.features">10.5 Features</A></H2><P>Objects may have features similar to records. Features are stateless components that are specified in the class declaration: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;</CODE><I>C</I><CODE>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;</CODE><I>A1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>AN</I><CODE>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>As in a record, a feature of an object has an associated field. The field is a logic variable that can be bound to any Oz value (including cells, objects, classes etc.). Features of objects are accessed using the infix '<CODE><SPAN class="keyword">.</SPAN></CODE>' operator. The following shows an example using features: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ApartmentC</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">AptC</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;ApartmentC</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;streetName:&nbsp;york<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;streetNumber:100<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wallColor:white<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;floorSurface:wood<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label56">10.5.1 Feature initialization</A></H3><P>The example shows how features could be initialized at the time the class is defined. In this case, all instances of the class <CODE>AptC</CODE> will have the features of the class, with their corresponding values. Therefore, the following program will display <CODE>york</CODE> twice. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Apt1&nbsp;Apt2<BR>Apt1&nbsp;=&nbsp;{New&nbsp;AptC&nbsp;init}<BR>Apt2&nbsp;=&nbsp;{New&nbsp;AptC&nbsp;init}<BR>{Browse&nbsp;Apt1<SPAN class="keyword">.</SPAN>streetName}<BR>{Browse&nbsp;Apt2<SPAN class="keyword">.</SPAN>streetName}</CODE></BLOCKQUOTE><P> </P><P>We may leave a feature uninitialized as in: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">MyAptC1</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;ApartmentC</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;streetName<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>In this case whenever an instance is created, the field of the feature is assigned a new fresh variable. Therefore, the following program will bind the feature <CODE>streetName</CODE> of object <CODE>Apt3</CODE> to the atom <CODE>kungsgatan</CODE>, and the corresponding feature of <CODE>Apt4</CODE> to the atom <CODE>sturegatan</CODE>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Apt3&nbsp;Apt4<BR>Apt3&nbsp;=&nbsp;{New&nbsp;MyAptC1&nbsp;init}<BR>Apt4&nbsp;=&nbsp;{New&nbsp;MyAptC1&nbsp;init}<BR>Apt3<SPAN class="keyword">.</SPAN>streetName&nbsp;=&nbsp;kungsgatan<BR>Apt4<SPAN class="keyword">.</SPAN>streetName&nbsp;=&nbsp;sturegatan</CODE></BLOCKQUOTE><P> </P><P>One more form of initialization is available. A feature may be initialized in the class declaration to a variable or an Oz-value that has a variable. In the following, the feature is initialized to a tuple with an anonymous variable. In this case, all instances of the class will <EM>share</EM> the same variable. Consider the following program. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">MyAptC1</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;ApartmentC</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;streetName:f(_)<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;Apt1&nbsp;Apt2&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>Apt1&nbsp;=&nbsp;{New&nbsp;MyAptC1&nbsp;init}<BR>Apt2&nbsp;=&nbsp;{New&nbsp;MyAptC1&nbsp;init}<BR>{Browse&nbsp;Apt1<SPAN class="keyword">.</SPAN>streetName}<BR>{Browse&nbsp;Apt2<SPAN class="keyword">.</SPAN>streetName}<BR>Apt1<SPAN class="keyword">.</SPAN>streetName&nbsp;=&nbsp;f(york)</CODE></BLOCKQUOTE><P> </P><P>If entered incrementally, will show that the statement </P><BLOCKQUOTE class="code"><CODE>Apt1<SPAN class="keyword">.</SPAN>streetName&nbsp;=&nbsp;f(york)</CODE></BLOCKQUOTE><P> </P><P>binds the corresponding feature of <CODE>Apt2</CODE> to the same value as that of <CODE>Apt1</CODE>. </P><P> What has been said of features also holds for attributes. </P></DIV><DIV id="section.classes.parametrized"><H2><A name="section.classes.parametrized">10.6 Parameterized Classes</A></H2><P>There are many ways to get your classes more generic, which later may be specialized for specific purposes. The common way to do this in object-oriented programming is to define first <EM>an abstract class</EM> in which some methods are left unspecified. Later these methods are defined in the subclasses. Suppose you have defined a generic class for sorting where the comparison operator <CODE>less</CODE> is needed. This operator depends on what kinds of data are being sorted. Different realizations are needed for integer, rational, or complex numbers, etc. In this case, by subclassing we can specialize the abstract class to a <EM>concrete</EM> class. </P><P>In Oz, we have also another natural method for creating generic classes. Since classes are first-class values, we can instead define a function that takes some type argument(s) and return a class that is specialized for the type(s). In <A href="node10.html#paramclass">Figure&nbsp;10.7</A>, the function <CODE>SortClass</CODE> is defined that takes a class as its single argument and returns a sorting class specialized for the argument. </P><P></P><DIV class="figure" id="paramclass"><HR><P><A name="paramclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">SortClass</SPAN>&nbsp;Type}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">$</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">qsort</SPAN>(Xs&nbsp;Ys)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Ys&nbsp;=&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;P<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;S&nbsp;L&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;partition(Xr&nbsp;P&nbsp;S&nbsp;L)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListC<SPAN class="keyword">,</SPAN>&nbsp;append({<SPAN class="keyword">self</SPAN>&nbsp;qsort(S&nbsp;$)}&nbsp;P<SPAN class="keyword">|</SPAN>{<SPAN class="keyword">self</SPAN>&nbsp;qsort(L&nbsp;$)}&nbsp;Ys)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">partition</SPAN>(Xs&nbsp;P&nbsp;Ss&nbsp;Ls)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Ss&nbsp;=&nbsp;nil&nbsp;Ls&nbsp;=&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Sr&nbsp;Lr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Type<SPAN class="keyword">,</SPAN>less(X&nbsp;P&nbsp;$)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ss&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Sr&nbsp;Lr&nbsp;=&nbsp;Ls<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ss&nbsp;=&nbsp;Sr&nbsp;Ls&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Lr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;partition(Xr&nbsp;P&nbsp;Sr&nbsp;Lr)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.7:</STRONG> Parameterized Classes</P><HR></DIV><P> </P><P>We can now define two classes for integers and rationals: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Int</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">less</SPAN>(X&nbsp;Y&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X<SPAN class="keyword">&lt;</SPAN>Y<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Rat</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Object</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">less</SPAN>(X&nbsp;Y&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="string">'/'</SPAN>(P&nbsp;Q)&nbsp;=&nbsp;X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="string">'/'</SPAN>(R&nbsp;S)&nbsp;=&nbsp;Y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P<SPAN class="keyword">*</SPAN>S&nbsp;<SPAN class="keyword">&lt;</SPAN>&nbsp;Q<SPAN class="keyword">*</SPAN>R<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Thereafter, we can execute the following statements: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{{New&nbsp;{SortClass&nbsp;Int}&nbsp;noop}&nbsp;qsort([1&nbsp;2&nbsp;5&nbsp;3&nbsp;4]&nbsp;$)}}<BR>{Browse&nbsp;{{New&nbsp;{SortClass&nbsp;Rat}&nbsp;noop}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;qsort([<SPAN class="string">'/'</SPAN>(23&nbsp;3)&nbsp;<SPAN class="string">'/'</SPAN>(34&nbsp;11)&nbsp;<SPAN class="string">'/'</SPAN>(47&nbsp;17)]&nbsp;$)}}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.self"><H2><A name="section.classes.self">10.7 Self Application</A></H2><P>The program in <A href="node10.html#paramclass">Figure&nbsp;10.7</A> shows in the method <CODE>qsort</CODE> an object application using the keyword <CODE><SPAN class="keyword">self</SPAN></CODE> (see below). </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">qsort</SPAN>(Xs&nbsp;Ys)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;partition(Xr&nbsp;P&nbsp;S&nbsp;L)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>We use here the phrase <EM>object-application</EM> instead of the commonly known phrase <EM>message sending</EM> because message sending is misleading in a concurrent language like Oz. When we use <CODE><SPAN class="keyword">self</SPAN></CODE> instead of a specific object as in </P><BLOCKQUOTE class="code"><CODE>{<SPAN class="keyword">self</SPAN>&nbsp;partition(Xr&nbsp;P&nbsp;S&nbsp;L)}</CODE></BLOCKQUOTE><P> </P><P>We mean that we dynamically pick the method <CODE>partition</CODE> that is defined (available) in the current object. Thereafter we apply the object (as a procedure) to the message. This is a form of dynamic binding common in all object-oriented languages. </P></DIV><DIV id="section.classes.attributes"><H2><A name="section.classes.attributes">10.8 Attributes</A></H2><P>We have touched before on the notion of attributes. Attributes are the carriers of state in objects. Attributes are declared similar to features, but using the keyword <CODE><SPAN class="keyword">attr</SPAN></CODE> instead. When an object is created each attribute is assigned a new cell as its value. These cells are initialized very much the same way as features. The difference lies in the fact that attributes are cells that can be assigned, reassigned and accessed at will. However, attributes are private to their objects. The only way to manipulate an attribute from outside an object is to force the class designer to write a method that manipulates the attribute. In the <A href="node10.html#pointclass">Figure&nbsp;10.8</A> we define the class <CODE>Point</CODE>. Note that the attributes <CODE>x</CODE> and <CODE>y</CODE> are initialized to zero before the initial message is applied. The method <CODE>move</CODE> uses <CODE><SPAN class="keyword">self</SPAN></CODE>-application internally. </P><P></P><DIV class="figure" id="pointclass"><HR><P><A name="pointclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Point</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;x:0&nbsp;y:0<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">attribute&nbsp;update<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">location</SPAN>(L)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;l(x:<SPAN class="keyword">@</SPAN>x&nbsp;y:<SPAN class="keyword">@</SPAN>y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">attribute&nbsp;access<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">moveHorizontal</SPAN>(X)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;X<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">moveVertical</SPAN>(Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;Y<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">move</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;moveHorizontal(X)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;moveVertical(Y)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">display</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">Switch&nbsp;the&nbsp;browser&nbsp;to&nbsp;virtual&nbsp;string&nbsp;mode<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">&quot;point&nbsp;at&nbsp;(&quot;</SPAN><SPAN class="keyword">#@</SPAN>x<SPAN class="keyword">#</SPAN><SPAN class="string">&quot;&nbsp;,&nbsp;&quot;</SPAN><SPAN class="keyword">#@</SPAN>y<SPAN class="keyword">#</SPAN><SPAN class="string">&quot;)\n&quot;</SPAN>}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.8:</STRONG> The class Point</P><HR></DIV><P> </P><P>Try to create an instance of <CODE>Point</CODE> and apply some few messages: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;P<BR>P&nbsp;=&nbsp;{New&nbsp;Point&nbsp;init(2&nbsp;0)}<BR>{P&nbsp;display}<BR>{P&nbsp;move(3&nbsp;2)}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.private"><H2><A name="section.classes.private">10.9 Private and Protected Methods</A></H2><P>Methods may be labeled by variables instead of literals. These methods are <EM>private</EM> to the class in which they are defined, as in: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">A</SPAN>(X)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">a</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;A(5)}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">....</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>The method <CODE>A</CODE> is visible only within the class <CODE>C</CODE>. In fact the notation above is just an abbreviation of the following expanded definition: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;A&nbsp;=&nbsp;{NewName}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="keyword">!</SPAN><SPAN class="functionname">A</SPAN>(X)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">a</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;A(5)}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>A is bound to a new name in the lexical scope of the class definition. </P><P>Some object-oriented languages have also the notion of protected methods. A method is <EM>protected</EM> if it is accessible only in the class it is defined or in descendant classes, i.e. subclasses and subsubclasses etc. In Oz there is no direct way to define a method to be protected. However there is a programming technique that gives the same effect. We know that attributes are only visible inside a class or to descendants of a class by inheritance. We may make a method protected by first making it private and second by storing it in an attribute. Consider the following example: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C</SPAN>&nbsp;<SPAN class="keyword">from</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;pa:A<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">A</SPAN>(X)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">a</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;A(5)}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Now, we create a subclass <CODE>C1</CODE> of <CODE>C</CODE> and access method <CODE>A</CODE> as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">C1</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;C</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">b</SPAN>(<SPAN class="keyword">...</SPAN>)&nbsp;L=<SPAN class="keyword">@</SPAN>pa&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;L(5)}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Method <CODE>b</CODE> accesses method <CODE>A</CODE> through the attribute <CODE>pa</CODE>. </P><P> Let us continue our simple example in <A href="node10.html#pointclass">Figure&nbsp;10.8</A> by defining a specialization of the class that in addition of being a point, it stores a history of the previous movement. This is shown in <A href="node10.html#histpointclass">Figure&nbsp;10.9</A>. </P><P></P><DIV class="figure" id="histpointclass"><HR><P><A name="histpointclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">HistoryPoint</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Point</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;history:&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;displayHistory:&nbsp;DisplayHistory<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>init(X&nbsp;Y)&nbsp;&nbsp;%&nbsp;<SPAN class="comment">call&nbsp;your&nbsp;super<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;history&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;[l(X&nbsp;Y)]<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">move</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>move(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;history&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;l(X&nbsp;Y)<SPAN class="keyword">|@</SPAN>history<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">display</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>display<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;DisplayHistory}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">DisplayHistory</SPAN>&nbsp;&nbsp;%&nbsp;<SPAN class="comment">made&nbsp;protected&nbsp;method<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="string">&quot;with&nbsp;location&nbsp;history:&nbsp;&quot;</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>history}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.9:</STRONG> The class History Point</P><HR></DIV><P> </P><P>There are a number of remarks on the class definition <CODE>HistoryPoint</CODE>. First observe the typical pattern of method refinement. The method <CODE>move</CODE> specializes that of class <CODE>Point</CODE>. It first calls the super method, and then does what is specific to being a <CODE>HistoryPoint</CODE> class. Second, <CODE>DisplayHistory</CODE> method is made private to the class. Moreover it is made available for subclasses, i.e. protected, by storing it in the attribute <CODE>displayHistory</CODE>. You can now try the class by the following statements: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;P<BR>P&nbsp;=&nbsp;{New&nbsp;HistoryPoint&nbsp;init(2&nbsp;0)}<BR>{P&nbsp;display}<BR>{P&nbsp;move(3&nbsp;2)}</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="section.classes.defaultargs"><H2><A name="section.classes.defaultargs">10.10 Default Argument Values</A></H2><P>A method head may have default argument values. Consider the following example. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">m</SPAN>(X&nbsp;Y&nbsp;d1:Z<SPAN class="keyword">&lt;=</SPAN>0&nbsp;d2:W<SPAN class="keyword">&lt;=</SPAN>0)&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>A call of the method <CODE>m</CODE> may leave the arguments of features <CODE>d1</CODE> and <CODE>d2</CODE> unspecified. In this case these arguments will assume the value zero. </P><P>We continue our <CODE>Point</CODE> example by specializing <CODE>Point</CODE> in a different direction. We define the class <CODE>BoundedPoint</CODE> as a point that moves in a constrained rectangular area. Any attempt to move such a point outside the area will be ignored. The class is shown in <A href="node10.html#boundedpoint">Figure&nbsp;10.10</A>. Notice that the method <CODE>init</CODE> has two default arguments that give a default area if not specified in the initialization of a new instance of <CODE>BoundedPoint</CODE>. </P><P></P><DIV class="figure" id="boundedpoint"><HR><P><A name="boundedpoint"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">BoundedPoint</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Point</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xbounds:&nbsp;0<SPAN class="keyword">#</SPAN>0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ybounds:&nbsp;0<SPAN class="keyword">#</SPAN>0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boundConstraint:&nbsp;BoundConstraint<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(X&nbsp;Y&nbsp;xbounds:XB&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;0<SPAN class="keyword">#</SPAN>10&nbsp;ybounds:YB&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;0<SPAN class="keyword">#</SPAN>10)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>init(X&nbsp;Y)&nbsp;%&nbsp;<SPAN class="comment">call&nbsp;your&nbsp;super<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xbounds&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;XB<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ybounds&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;YB<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">move</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;BoundConstraint(X&nbsp;Y&nbsp;$)}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>move(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">BoundConstraint</SPAN>(X&nbsp;Y&nbsp;$)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(X&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>xbounds<SPAN class="keyword">.</SPAN>1&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;<SPAN class="keyword">=&lt;</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>xbounds<SPAN class="keyword">.</SPAN>2&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>ybounds<SPAN class="keyword">.</SPAN>1&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;<SPAN class="keyword">=&lt;</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>ybounds<SPAN class="keyword">.</SPAN>2&nbsp;)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">display</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point<SPAN class="keyword">,</SPAN>display<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;DisplayBounds}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">DisplayBounds</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X0<SPAN class="keyword">#</SPAN>X1&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>xbounds<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y0<SPAN class="keyword">#</SPAN>Y1&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>ybounds<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;=&nbsp;<SPAN class="string">&quot;xbounds=(&quot;</SPAN><SPAN class="keyword">#</SPAN>X0<SPAN class="keyword">#</SPAN><SPAN class="string">&quot;,&quot;</SPAN><SPAN class="keyword">#</SPAN>X1<SPAN class="keyword">#</SPAN><SPAN class="string">&quot;),ybounds=(&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">#</SPAN>Y0<SPAN class="keyword">#</SPAN><SPAN class="string">&quot;,&quot;</SPAN><SPAN class="keyword">#</SPAN>Y1<SPAN class="keyword">#</SPAN><SPAN class="string">&quot;)&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.10:</STRONG> The class BoundedPoint</P><HR></DIV><P> </P><P>We conclude this section by finishing our example in a way that shows the multiple inheritance problem. We would like now a specialization of both <CODE>HistoryPoint</CODE> and <CODE>BoundedPoint</CODE> as a bounded-history point. A point that keeps track of the history and moves in a constrained area. We do this by defining the class <CODE>BHPoint</CODE> that inherits from the two previously defined classes. Since they both share the class <CODE>Point</CODE>, which contains stateful attributes, we encounter the implementation-sharing problem. We, any way, anticipated this problem and therefore created two protected methods stored in <CODE>boundConstraint</CODE> and <CODE>displayHistory</CODE> to avoid repeating the same actions. In any case, we have to refine the methods <CODE>init</CODE>, <CODE>move</CODE> and <CODE>display</CODE> since they occur in the two sibling classes. The solution is shown in <A href="node10.html#bhclass">Figure&nbsp;10.11</A>. Notice how we use the protected methods. We did not care avoiding the repetition of initializing the attributes <CODE>x</CODE> and <CODE>y</CODE> since it does not make any harm. Try the following example: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;P<BR>P&nbsp;=&nbsp;{New&nbsp;BHPoint&nbsp;init(2&nbsp;0)}<BR>{P&nbsp;display}<BR>{P&nbsp;move(1&nbsp;2)}</CODE></BLOCKQUOTE><P> </P><P>This pretty much covers most of the object system. What is left is how to deal with concurrent threads sharing a common space of objects. </P><P></P><DIV class="figure" id="bhclass"><HR><P><A name="bhclass"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">BHPoint</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;HistoryPoint&nbsp;BoundedPoint</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(X&nbsp;Y&nbsp;xbounds:XB&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;0<SPAN class="keyword">#</SPAN>10&nbsp;ybounds:YB&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;0<SPAN class="keyword">#</SPAN>10)<BR>&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">repeats&nbsp;init<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HistoryPoint<SPAN class="keyword">,</SPAN>init(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BoundedPoint<SPAN class="keyword">,</SPAN>init(X&nbsp;Y&nbsp;xbounds:XB&nbsp;ybounds:YB)&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">move</SPAN>(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>boundConstraint&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;L(X&nbsp;Y&nbsp;$)}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HistoryPoint<SPAN class="keyword">,</SPAN>move(X&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">display</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BoundedPoint<SPAN class="keyword">,</SPAN>display<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>displayHistory}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;10.11:</STRONG> The class BHPoint</P><HR></DIV><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node9.html#chapter.stateful">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node11.html#chapter.objectscc">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label57">1. </A>In fact, classes may have some invisible state. In the current implementation, a class usually has method cache, which is stateful</DIV><DIV class="footnote"><A name="label58">2. </A>This is a simplification; an object in Oz is a chunk that has the above procedure in one of its fields; other fields contain the object features</DIV><DIV class="footnote"><A name="label59">3. </A>To be defined shortly</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzn</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
