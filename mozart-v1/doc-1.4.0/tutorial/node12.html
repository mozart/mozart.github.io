<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>12 Logic Programming</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node11.html#chapter.objectscc">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="bib.html#label86">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.lp"><H1><A name="chapter.lp">12 Logic Programming</A></H1><P>Many problems, especially frequent in the field of Artificial Intelligence, and also found elsewhere, e.g., in operations research, are currently solvable only by resorting to some form of search and <EM>constraint</EM> propagation. Such problems can be specified very concisely, if the programming language abstracts away the details of search by providing don't know nondeterminism. Logic programming and Prolog is considered a suitable formalism for this class of problems. In this chapter we will talk about how to express logic programming and concurrent constraint programming in Oz. In logic programming each procedure can be interpreted as a relation expressed by a logical statement. We will also discuss the relation between Oz and Prolog, and how most Prolog programs have a straight forward translation to Oz programs. For more advanced constraint solving techniques, the reader may look to the companion tutorial on constraint programming in Oz. </P><P class="warning"><STRONG>Warning:</STRONG>Please note that the material in this chapter is still incomplete. </P><H2><A name="label64">12.1 Constraint Stores</A></H2><P>Oz threads share a store where variable bindings are stored in the form of equalities: <IMG alt="X_1=U_1, \ldots, X_n=U_n" src="latex3.png"> where <IMG alt="X_i" src="latex4.png"> are variables and <IMG alt="U_i" src="latex5.png"> are either Oz entities or variables. The constraint store contains the Oz values corresponding to records, numbers, names or variables, and the names that uniquely idententifies the procedures, cells and the various types of chunks (classes, objects, functors, etc.). Conceptually the store is modeled as a conjunctive logical formula: <IMG alt="\exists Y_1 \ldots Y_m : X_1=U_1 \wedge \ldots \wedge X_n=U_n" src="latex6.png">, where the <IMG alt="X_i" src="latex4.png"> are the variables and <IMG alt="U_i" src="latex5.png"> are Oz values or variables, and <IMG alt="Y_i " src="latex7.png"> are the union of all variables occuring in <IMG alt="X_i " src="latex4.png"> and <IMG alt="U_i " src="latex5.png">. The store is said to be a <EM>constraint store</EM>. An Oz <EM> computation store</EM> consists of a constraint store, a procedure store where procedures reside, and a cell store where cells and object states reside. </P><H2><A name="label65">12.2 Computation Spaces</A></H2><P>A computation space consists in general of a computation store and a set of executing threads. What we have seen so far is a single computation space. When dealing with logic programming a more elaborate structure will arise with multiple nested computation spaces. The general rules for the structure of computation spaces are as follows. </P><UL><LI><P>There is always a topmost computation space where threads may interact with the external world. A thread trying to add inconsistent constraints (bindings) to the store of the top space will raise a failure exception in the thread. The addition of the inconsistent constraints will be aborted and the constraint store remains always consistent. </P></LI><LI><P>A thread may create a local computation space either directly or indirectly as will be shown in this section. The new computation space will be a child space and the current one the parent space. In general a hierarchy of computation spaces may be created. </P></LI><LI><P>A thread belongs always to one computation space. Also, variables belong to only one computation space. </P></LI><LI><P>A thread in a child space sees and may access variables belonging to its space as well as to all ancestor spaces. The converse is false. A thread in a parent space cannot see the variables of a child space, unless the child space is merged with the parent. In such a case, the child space disappears, and all its content is added to the parent space. The space merge operation may occur due to an explicit operation, or indirectly due to a language construct as will be seen in this section. </P></LI><LI><P>A Thread in a child space my add constraints (bindings) on variables visible to it. This means that it may bind variables belonging to its space or to its ancestor spaces. The binding will only be visible in the current space and all its children spaces if any. </P></LI></UL><P> </P><H2><A name="label66">12.3 Constraint Entailment and Disentailment</A></H2><P>A condition <IMG alt="C" src="latex8.png"> is entailed by the store <IMG alt="\sigma" src="latex9.png"> if <IMG alt="C" src="latex8.png">, considered as a logical formula, is logically implied by the store <IMG alt="\sigma" src="latex9.png">, again considered as a logical formula. Intuitively entailment of <IMG alt="C" src="latex8.png"> means that adding <IMG alt="C" src="latex8.png"> to the store does not increase the information already there. Everything is already there. </P><P>A condition <IMG alt="C" src="latex8.png"> is disentailed by the store if the negation of <IMG alt="C" src="latex8.png"> is logically implied by the store <IMG alt="\sigma" src="latex9.png">. A disentailed constraint is inconsistent with the information already in the store. </P><P> Since a constraint store is a logical formula, we can also talk of a constraint store being entailed, or disentailed by another constraint store. A space <IMG alt="S_0" src="latex10.png"> is entailed (disentailed) by another space <IMG alt="S_1" src="latex11.png"> if the constraint store of <IMG alt="S_0" src="latex10.png"> is entailed (disentailed) by the constraint store if <IMG alt="S_1" src="latex11.png">. </P><P> We call a space that is disentailed (normally by a parent space) a <EM> failed space </EM>. </P><H3><A name="label67">12.3.1 Examples</A></H3><P>Consider the store <IMG alt="\sigma \equiv X = 1 \wedge \ldots \wedge Y = f(X \ Z)" src="latex12.png"> and the following conditions: </P><UL><LI><P><IMG alt="X=1" src="latex13.png"> is entailed since adding this binding does not increase the information in the store. </P></LI><LI><P><IMG alt="\exists U : Y=f(1 \ U)" src="latex14.png"> is also entailed. Adding this information does not increase our information. There is a <IMG alt="Z" src="latex15.png"> that satisfies the above condition. Notice that we do not know which value <IMG alt="Z" src="latex15.png"> will assume. But whatever value assumed by <IMG alt="Z" src="latex15.png">, the condition would be still satisfied. </P></LI><LI><P><IMG alt="Y=f(1 \ 2)" src="latex16.png"> is not entailed by the store, since adding this equality increases the information there, namely by making <IMG alt="Z=2" src="latex17.png">. </P></LI><LI><P><IMG alt="X=2" src="latex18.png"> or <IMG alt="Y=f(3 \ U)" src="latex19.png"> are both disentailed since they contradict information already present. They will cause a failure exception to be raised: in the top space this is normally reported to the user in an error message, whereas a subordinated space is merely failed. </P></LI></UL><P> </P><H2><A name="label68">12.4 Disjunctions</A></H2><P>Now we are in a position to understand the nondeterminate constructs of Oz. Oz provides several disjunctive constructs for <EM>nondeterminate choice</EM>, also known as <EM>don't know choice</EM> statements. </P><H3><A name="label69">12.4.1 or statement</A></H3><P>In all the disjunctive statements we are going to use the notion of a clause and a guard. A clause consists of a guard <I>G</I> and a body <I>S1</I>, and has the following form: </P><BLOCKQUOTE class="code"><I>G</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I></BLOCKQUOTE><P> </P><P> The guard <I>G</I> has the form: </P><BLOCKQUOTE class="code"><CODE>&nbsp;</CODE><I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>Xn</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S0</I><CODE>&nbsp;</CODE></BLOCKQUOTE><P> where the variables <I>Xi</I> are existentially quantified with scope extending over both the guard and the body. </P><P>The first disjunctive statement has the following form: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">or</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><I>G1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>G2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>GN</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>SN</I><CODE>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>An <CODE><SPAN class="keyword">or</SPAN></CODE>-statement has the following semantics. Assume a thread is executing the statement in space <I>SP</I>. </P><UL><LI><P>The thread is blocked. </P></LI><LI><P><IMG alt="N" src="latex20.png"> spaces are created <IMG alt="SP_1, \ldots, SP_N" src="latex21.png"> with <IMG alt="N" src="latex20.png"> new threads executing the guards <IMG alt="G_1, \ldots, G_N" src="latex22.png">. </P></LI><LI><P>Execution of the father thread remains blocked until at most one of the child spaces is not failed. </P></LI><LI><P>If all children spaces are failed, the parent thread raises a failure condition in its space. This means that if the space of the parent thread is the top space, a failure exception is raised. Otherwise the space is local and it becomes a failed space. </P></LI><LI><P>Only one space remains that is not failed which corresponds to the clause <IMG alt="G_i" src="latex23.png"> <CODE><SPAN class="keyword">then</SPAN></CODE> <IMG alt="S_i" src="latex24.png">. Assume also that <IMG alt="G_i" src="latex23.png"> has been reduced to the goal <IMG alt="G'_i" src="latex25.png"> and the constraint <IMG alt="\theta" src="latex26.png">. In this case, the space is merged with the parent space. <IMG alt="\theta" src="latex26.png"> and the variables of the store are added to that of the parent store. <IMG alt="G'_i" src="latex25.png"> executes in its own thread, and the original suspending thread resumes executing the statement <IMG alt="S_i" src="latex24.png">. This rule of execution is called <EM>unit commit</EM> in Oz because execution commits to one alternative disjunct (the only one that is left). </P></LI></UL><P> </P><H3><A name="label70">12.4.2 Shorthand Notation</A></H3><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">or</SPAN>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Gi</I><CODE>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Stands for </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">or</SPAN>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Gi</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P> Observe that the <CODE><SPAN class="keyword">or</SPAN></CODE> statement does not introduce any don't know nondeterminism. A thread executing such a statement waits until things works out in a determinate course of action. </P><H3><A name="label71">12.4.3 Prolog Comparison</A></H3><P> The <CODE><SPAN class="keyword">or</SPAN></CODE> statement just described does not have a corresponding construct in Prolog. The Prolog disjunct <CODE>P&nbsp;;&nbsp;Q</CODE> always creates a choice point that is subject to backtracking. </P><H2><A name="label72">12.5 Determinacy Driven Execution</A></H2><P>The <CODE><SPAN class="keyword">or</SPAN></CODE>-statement of Oz allows a pure logical form of programming style where computations are synchronized by determinacy conditions. Consider the following program. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Ints</SPAN>&nbsp;N&nbsp;Xs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">or</SPAN>&nbsp;N&nbsp;=&nbsp;0&nbsp;Xs&nbsp;=&nbsp;nil<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Xr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp;<SPAN class="keyword">&gt;</SPAN>&nbsp;0&nbsp;=&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;Xs&nbsp;=&nbsp;N<SPAN class="keyword">|</SPAN>Xr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Ints&nbsp;N<SPAN class="keyword">-</SPAN>1&nbsp;Xr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sum3</SPAN>&nbsp;Xs&nbsp;N&nbsp;R}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">or</SPAN>&nbsp;Xs&nbsp;=&nbsp;nil&nbsp;R&nbsp;=&nbsp;N<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;=&nbsp;Xs&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Sum3&nbsp;Xr&nbsp;X<SPAN class="keyword">+</SPAN>N&nbsp;R}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sum</SPAN>&nbsp;Xs&nbsp;R}&nbsp;{Sum3&nbsp;Xs&nbsp;0&nbsp;R}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;N&nbsp;S&nbsp;R&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Ints&nbsp;N&nbsp;S}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Sum&nbsp;S&nbsp;{Browse}}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;N&nbsp;=&nbsp;1000<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>The thread executing <CODE>Ints</CODE> will suspend until <CODE>N</CODE> is known, because it cannot decide on which disjunct to take. Similarly, <CODE>Sum3</CODE> will wait until the list <CODE>S</CODE> is known. <CODE>S</CODE> will be defined incrementally and that will lead to the suspension and resumption of <CODE>Sum3</CODE>. Things will start to take off when the main thread binds <CODE>N</CODE> to <CODE>1000</CODE>. This shows clearly that determinacy driven execution gives the synchronization information need to mimic producer/consumer behavior. </P><H2><A name="label73">12.6 Conditionals</A></H2><H3><A name="label74">12.6.1 Logical Conditional</A></H3><P>A logical conditional is a statement having the following form. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">cond</SPAN>&nbsp;</CODE><I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>XN</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S0</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>where <I>Xi</I> are newly introduced variables, and <I>Si</I> are statements. <I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>XN</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S0</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I> is the clause of the conditional, and <I>S2</I> is the alternative. </P><P>A <CODE><SPAN class="keyword">cond</SPAN></CODE>-statement has the following semantics. Assume a thread is executing the statement in space <I>SP</I>. </P><UL><LI><P>The thread is blocked. </P></LI><LI><P>A space <IMG alt="SP_1" src="latex27.png"> is created, with a single thread executing the guard <CODE><SPAN class="keyword">cond</SPAN>&nbsp;</CODE><I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>XN</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S0</I>. </P></LI><LI><P>Execution of the father thread remains blocked until <IMG alt="SP_1" src="latex27.png"> is either entailed or disentailed. Notice that these conditions may never occur, e.&nbsp;g. when some thread is suspending or running forever in <IMG alt="SP_1" src="latex27.png">. </P></LI><LI><P>If <IMG alt="SP_1" src="latex27.png"> is disentailed, the father thread continues with <I>S2</I>. </P></LI><LI><P>If <IMG alt="SP_1" src="latex27.png"> is entailed, assume it has been reduced to the store <IMG alt="\theta" src="latex26.png"> and the set of local variables <IMG alt="SX" src="latex28.png"> In this case, the space is merged with the parent space. <IMG alt="\theta" src="latex26.png"> and <IMG alt="SX" src="latex28.png"> added to the parent store, and the father thread continues with the execution of <I>S1</I>. </P></LI></UL><P> </P><H3><A name="label75">12.6.2 Prolog Comparison</A></H3><P> The <CODE><SPAN class="keyword">cond</SPAN></CODE> statement just described corresponds roughly to Prolog's conditional <CODE>&nbsp;P&nbsp;<SPAN class="keyword">-&gt;</SPAN>&nbsp;Q&nbsp;;&nbsp;R&nbsp;</CODE>. Oz is a bit more careful about the scope of variables, so local variables <I>Xi</I> have to be introduced explicitly. <CODE><SPAN class="keyword">cond</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;P&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Q&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;R&nbsp;<SPAN class="keyword">end</SPAN></CODE> always has the logical semantics <IMG alt="\exists X : P \wedge Q \vee (\not \exists X : P) \wedge R" src="latex29.png">, given that we stick to the logical part of Oz. This is not always true in Prolog. </P><H3><A name="label76">12.6.3 Parallel Conditional</A></H3><P>A parallel conditional is of the form </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">cond</SPAN>&nbsp;</CODE><I>G1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>G2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>SN</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>A parallel conditional is executed by evaluating all conditions <I>G1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>G(N-1)</I> in an <EM>arbitrary</EM> order, possibly concurrently, each in its own space. If one of the spaces, say <I>Gi</I>, is entailed, its corresponding statement <I>Si</I> is chosen by the father thread. If all spaces are failed, the else statement <I>SN</I> is chosen, otherwise the executing thread suspends. </P><P> Parallel conditionals are useful mostly in concurrent programming, e.g. for programming time-out on certain events. This construct is the basic construct in concurrent logic programming languages (also known as committed-choice languages). </P><P> As a typical example from concurrent logic programming let us define the indeterministic binary merge, where the arrival timing of elements on the two streams <CODE>Xs</CODE> and <CODE>Ys</CODE> determines the order of elements on the resulting stream <CODE>Zs</CODE>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Merge</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">cond</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs&nbsp;=&nbsp;Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Ys&nbsp;=&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs&nbsp;=&nbsp;Xr<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;Xr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Xs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr&nbsp;{Merge&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Y&nbsp;Yr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Ys&nbsp;=&nbsp;Y<SPAN class="keyword">|</SPAN>Yr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;Y<SPAN class="keyword">|</SPAN>Zr&nbsp;{Merge&nbsp;Xs&nbsp;Yr&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> In general binary-stream merge is inefficient, specially when multiple of these are used to connect multiple threads to a simple server thread. An efficient way to implement a constant-time multi-merge operator is defined below by using cells and streams instread. The procedure <CODE>{MMerge&nbsp;STs&nbsp;L}</CODE> has two arguments STs may be either nil, a list of streams to merged, or of the form <CODE>merge(ST1&nbsp;ST2)</CODE> where each <CODE>STi</CODE> is again of the same form as <CODE>STs</CODE>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MMerge</SPAN>&nbsp;STs&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;C&nbsp;=&nbsp;{NewCell&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MM</SPAN>&nbsp;STs&nbsp;S&nbsp;E}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;STs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;ST<SPAN class="keyword">|</SPAN>STr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;M&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;ST&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;ST1&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Exchange&nbsp;C&nbsp;X<SPAN class="keyword">|</SPAN>ST1&nbsp;ST1}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M=S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{MM&nbsp;STr&nbsp;M&nbsp;E}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;merge(STs1&nbsp;STs2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;M&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{MM&nbsp;STs1&nbsp;S&nbsp;M}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{MM&nbsp;STs2&nbsp;M&nbsp;E}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;E<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{MM&nbsp;&nbsp;STs&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;E}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;E<SPAN class="keyword">==unit</SPAN>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;L&nbsp;=&nbsp;nil&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> A binary-merge <CODE>{Merge&nbsp;X&nbsp;Y&nbsp;Z}</CODE> is simply <CODE>{MMerge&nbsp;[X&nbsp;Y]&nbsp;Z}</CODE>.</P><H2><A name="label77">12.7 Nondeterministic Programs and Search</A></H2><P>Oz allows much of the nondeterministic and search-oriented programming as Prolog. This type of programming comes in a little bit different flavour than Prolog. While Prolog comes ready with a default search strategy based on backtracking, Oz allows programmers to devise their suitable search strategies in a way that is separate and orthogonal from the nondeterministic specification of a problem.</P><P> To be able to do this Oz has a specific linguistic constructs that create choice point without specifying how they will be explored. A completely separate program can then specify the search strategy. </P><H3><A name="label78">12.7.1 <CODE><SPAN class="keyword">dis</SPAN></CODE> Construct</A></H3><P>The following program uses the <CODE><SPAN class="keyword">dis</SPAN></CODE> construct of Oz to create a choice point when necessary. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Append</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;nil&nbsp;Ys&nbsp;=&nbsp;Zs&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;Xr&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Append&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P><P>It corresponds roughly to the <CODE>append<SPAN class="keyword">/</SPAN>3</CODE> program of Prolog: </P><BLOCKQUOTE class="code"><CODE>append(<SPAN class="keyword">[],</SPAN>&nbsp;Ys<SPAN class="keyword">,</SPAN>&nbsp;Ys)<SPAN class="keyword">.</SPAN>&nbsp;<BR>append([X<SPAN class="keyword">|</SPAN>Xr]<SPAN class="keyword">,</SPAN>&nbsp;Ys<SPAN class="keyword">,</SPAN>&nbsp;[X<SPAN class="keyword">|</SPAN>Zr])&nbsp;:<SPAN class="keyword">-</SPAN>&nbsp;append(Xr<SPAN class="keyword">,</SPAN>&nbsp;Yr<SPAN class="keyword">,</SPAN>&nbsp;Zr)<SPAN class="keyword">.</SPAN></CODE></BLOCKQUOTE><P></P><P>In fact the same kind of abbreviations that hold for <CODE><SPAN class="keyword">or</SPAN></CODE> hold also for <CODE><SPAN class="keyword">dis</SPAN></CODE>. That is the above program have the following abbreviated form. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Append</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;nil&nbsp;Ys&nbsp;=&nbsp;Zs&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;Xr&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Append&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> Assume the following procedure call: </P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Append&nbsp;[1&nbsp;2&nbsp;3]&nbsp;[a&nbsp;b&nbsp;c]&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P><P>This will behave exactly as the <CODE><SPAN class="keyword">or</SPAN></CODE> construct, i.e. it will deterministically bind <CODE>X</CODE> to <CODE>[1&nbsp;2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]</CODE>. If we on the other hand try: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Append&nbsp;X&nbsp;Y&nbsp;[1&nbsp;2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]}<BR>&nbsp;&nbsp;{Browse&nbsp;X<SPAN class="keyword">#</SPAN>Y}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> the bahavior will look the same as with the <CODE><SPAN class="keyword">or</SPAN></CODE> construct; the thread executing this sequence of calls will suspend while executing <CODE>{Append&nbsp;X&nbsp;Y&nbsp;[1&nbsp;2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]}</CODE>. There is however a difference. The call of <CODE>Append</CODE> will create a choice-point with two alternatives: </P><UL><LI><P><CODE>X&nbsp;=&nbsp;nil&nbsp;Y&nbsp;=&nbsp;[1&nbsp;2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN></CODE></P></LI><LI><P></P><BLOCKQUOTE class="code"><CODE>Xr&nbsp;Xr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;1<SPAN class="keyword">|</SPAN>Xr&nbsp;Zr&nbsp;=&nbsp;[2&nbsp;3&nbsp;a&nbsp;b&nbsp;c]&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{Append&nbsp;Xr&nbsp;Y&nbsp;Zr}</CODE></BLOCKQUOTE><P></P></LI></UL><P> </P><H3><A name="label79">12.7.2 Define Clause Grammer</A></H3><P> </P><BLOCKQUOTE class="code"><CODE>Sentence(P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;NounPhrase(X&nbsp;P1&nbsp;P)&nbsp;VerbPhrase(X&nbsp;P1)<BR>NounPhrase(X&nbsp;P1&nbsp;P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;Determiner(X&nbsp;P2&nbsp;P1&nbsp;P)&nbsp;Noun(X&nbsp;P3)&nbsp;RelClause(X&nbsp;P3&nbsp;P2)&nbsp;&nbsp;<BR>NounPhrase(X&nbsp;P&nbsp;P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;Name(X)<BR>VerbPhrase(X&nbsp;P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;TransVerb(X&nbsp;Y&nbsp;P1)&nbsp;NounPhrase(Y&nbsp;P1&nbsp;P)&nbsp;<SPAN class="keyword">|</SPAN>&nbsp;InstransVerb(X&nbsp;P)<BR>RelClause(X&nbsp;P1&nbsp;and(P1&nbsp;P2))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[that]&nbsp;VerbPhrase(X&nbsp;P2)&nbsp;&nbsp;<BR>RelClause(_&nbsp;P&nbsp;P)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;<BR>Determiner(X&nbsp;P1&nbsp;P2&nbsp;all(X&nbsp;imp(P1&nbsp;P2)))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[every]&nbsp;&nbsp;<BR>Determiner(X&nbsp;P1&nbsp;P2&nbsp;exits(X&nbsp;and(P1&nbsp;P2)))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[a]<BR>Noun(X&nbsp;man(X))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[man]&nbsp;&nbsp;<BR>Noun(X&nbsp;woman(X))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[woman]<BR>name(john)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[john]&nbsp;&nbsp;<BR>name(jan)&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[jan]<BR>TransVerb(X&nbsp;Y&nbsp;loves(X&nbsp;Y))&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[loves]<BR>IntransVerb(X&nbsp;lives(X))&nbsp;&nbsp;<SPAN class="keyword">--&gt;</SPAN>&nbsp;[lives]</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sentence</SPAN>&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;X&nbsp;P1&nbsp;S1&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{NounPhrase&nbsp;X&nbsp;P1&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S1}<BR>&nbsp;&nbsp;&nbsp;{VerbPhrase&nbsp;X&nbsp;P1&nbsp;S1<SPAN class="keyword">#</SPAN>S}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NounPhrase</SPAN>&nbsp;X&nbsp;P1&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2&nbsp;P3&nbsp;S1&nbsp;S2&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Determiner&nbsp;X&nbsp;P2&nbsp;P1&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S1}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Noun&nbsp;X&nbsp;P3&nbsp;S1<SPAN class="keyword">#</SPAN>S2}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RelClause&nbsp;X&nbsp;P3&nbsp;P2&nbsp;S2<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;{Name&nbsp;X&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P1&nbsp;=&nbsp;P<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">VerbPhrase</SPAN>&nbsp;X&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;P1&nbsp;S1&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{TransVerb&nbsp;X&nbsp;Y&nbsp;P1&nbsp;S0<SPAN class="keyword">#</SPAN>S1}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{NounPhrase&nbsp;Y&nbsp;P1&nbsp;P&nbsp;S1<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;{IntransVerb&nbsp;X&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">TransVerb</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;loves<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;Z&nbsp;=&nbsp;loves(X&nbsp;Y)<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">IntransVerb</SPAN>&nbsp;X&nbsp;Y&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;lives<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;lives(X)<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Name</SPAN>&nbsp;X&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;john<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;jan<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Noun</SPAN>&nbsp;X&nbsp;Y&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;man<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;man(X)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;S0&nbsp;=&nbsp;woman<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;woman(X)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Determiner</SPAN>&nbsp;X&nbsp;P1&nbsp;P2&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;every<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;all(X&nbsp;imp(P1&nbsp;P2))<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;S0&nbsp;=&nbsp;a<SPAN class="keyword">|</SPAN>S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;exists(X&nbsp;and(P1&nbsp;P2))<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">RelClause</SPAN>&nbsp;X&nbsp;P1&nbsp;P&nbsp;S0<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;P2&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S1&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S0&nbsp;=&nbsp;that<SPAN class="keyword">|</SPAN>S1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;and(P1&nbsp;P2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{VerbPhrase&nbsp;X&nbsp;P2&nbsp;S1<SPAN class="keyword">#</SPAN>S}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;S0&nbsp;=&nbsp;S<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;=&nbsp;P1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Main</SPAN>&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;{Sentence&nbsp;P&nbsp;[every&nbsp;man&nbsp;that&nbsp;lives&nbsp;loves&nbsp;a&nbsp;woman]<SPAN class="keyword">#</SPAN>nil}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P><H3><A name="label80">12.7.3 Some Search Procedures</A></H3><H3><A name="label81">12.7.4 Dis Construct</A></H3><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Edge<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Connected</SPAN>&nbsp;X&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Edge&nbsp;X&nbsp;Y}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Edge&nbsp;X&nbsp;Z}&nbsp;&nbsp;{Connected&nbsp;Z&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Edge</SPAN>&nbsp;X&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;1&nbsp;Y&nbsp;=&nbsp;2<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;2&nbsp;Y&nbsp;=&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;2&nbsp;Y&nbsp;=&nbsp;3<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;3&nbsp;Y&nbsp;=&nbsp;4<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;2&nbsp;Y&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;5&nbsp;Y&nbsp;=&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;4&nbsp;Y&nbsp;=&nbsp;6<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;6&nbsp;Y&nbsp;=&nbsp;7<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;6&nbsp;Y&nbsp;=&nbsp;8<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;1&nbsp;Y&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X&nbsp;=&nbsp;5&nbsp;Y&nbsp;=&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR>{ExploreOne<BR>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;X<SPAN class="keyword">#</SPAN>Y&nbsp;=&nbsp;L&nbsp;{Connected&nbsp;X&nbsp;Y}<BR>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>}<BR>{Browse<BR>&nbsp;{SearchAll<BR>&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X<SPAN class="keyword">#</SPAN>Y&nbsp;=&nbsp;L&nbsp;{Connected&nbsp;X&nbsp;Y}<BR>&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;}}</CODE></BLOCKQUOTE><P></P><H3><A name="label82">12.7.5 Negation</A></H3><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NotP</SPAN>&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;{SearchOne&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;L}&nbsp;{P}&nbsp;L=<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;$}&nbsp;=&nbsp;nil<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">ConnectedEnh</SPAN>&nbsp;X&nbsp;Y&nbsp;Visited}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Edge&nbsp;X&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Edge&nbsp;X&nbsp;Z}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{NotP&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Member&nbsp;Z&nbsp;Visited}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ConnectedEnh&nbsp;Z&nbsp;Y&nbsp;Z<SPAN class="keyword">|</SPAN>Visited}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label83">12.7.6 Dynamic Predicates</A></H3><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">DisMember</SPAN>&nbsp;X&nbsp;Ys}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">dis</SPAN>&nbsp;Ys&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>_&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Yr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Ys&nbsp;=&nbsp;_<SPAN class="keyword">|</SPAN>Yr&nbsp;{DisMember&nbsp;X&nbsp;Yr}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">DataBase</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;BaseObject</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;d<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{NewDictionary}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">dic</SPAN>($)&nbsp;<SPAN class="keyword">@</SPAN>d&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">tell</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;{IsFree&nbsp;I<SPAN class="keyword">.</SPAN>1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;database(nonground(I))&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is&nbsp;=&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>condGet&nbsp;<SPAN class="keyword">@</SPAN>d&nbsp;I<SPAN class="keyword">.</SPAN>1&nbsp;nil}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>put&nbsp;<SPAN class="keyword">@</SPAN>d&nbsp;I<SPAN class="keyword">.</SPAN>1&nbsp;{Append&nbsp;Is&nbsp;[I]}}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">ask</SPAN>(I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;{IsFree&nbsp;I}&nbsp;<SPAN class="keyword">orelse</SPAN>&nbsp;{IsFree&nbsp;I<SPAN class="keyword">.</SPAN>1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{DisMember&nbsp;I&nbsp;{Flatten&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>items&nbsp;<SPAN class="keyword">@</SPAN>d}}}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{DisMember&nbsp;I&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>condGet&nbsp;<SPAN class="keyword">@</SPAN>d&nbsp;I<SPAN class="keyword">.</SPAN>1&nbsp;nil}}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">entries</SPAN>($)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Dictionary<SPAN class="keyword">.</SPAN>entries&nbsp;<SPAN class="keyword">@</SPAN>d}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Dynamic</SPAN>&nbsp;?Pred}<BR>&nbsp;&nbsp;&nbsp;Pred&nbsp;=&nbsp;{New&nbsp;DataBase&nbsp;init}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Assert</SPAN>&nbsp;P&nbsp;I}<BR>&nbsp;&nbsp;&nbsp;{P&nbsp;tell(I)}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Query</SPAN>&nbsp;P&nbsp;I}<BR>&nbsp;&nbsp;&nbsp;{P&nbsp;ask(I)}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>EdgeP&nbsp;=&nbsp;{Dynamic}<BR>{ForAll<BR>[edge(1&nbsp;2)<BR>&nbsp;edge(2&nbsp;1)&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">Cycle<BR></SPAN>&nbsp;edge(2&nbsp;3)<BR>&nbsp;edge(3&nbsp;4)<BR>&nbsp;edge(2&nbsp;5)<BR>&nbsp;edge(5&nbsp;6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;edge(4&nbsp;6)<BR>&nbsp;edge(6&nbsp;7)<BR>&nbsp;edge(6&nbsp;8)<BR>&nbsp;edge(1&nbsp;5)<BR>&nbsp;edge(5&nbsp;1)&nbsp;&nbsp;%&nbsp;<SPAN class="comment">Cycle<BR></SPAN>]<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}&nbsp;{Assert&nbsp;EdgeP&nbsp;I}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>}</CODE></BLOCKQUOTE><P> </P><H3><A name="label84">12.7.7 The Basic Space Library</A></H3><H3><A name="label85">12.7.8 Example: A Simple Expert System</A></H3></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node11.html#chapter.objectscc">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="bib.html#label86">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzén</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
