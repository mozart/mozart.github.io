<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>9 Stateful Data Types</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html#chapter.concurrency">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node10.html#chapter.classes">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.stateful"><H1><A name="chapter.stateful">9 Stateful Data Types</A></H1><P>Oz provides a set of stateful data types. These include ports, objects, arrays, and dictionaries (hash tables). These data types are abstract in the sense that they are characterized only by the set of operations performed on the members of the type. Their implementation is always hidden, and in fact different implementations exist but their corresponding behavior remains the same. For example, objects are implemented in a totally different way depending on the optimization level of the compiler. Each member is always unique by conceptually tagging it with an Oz-name upon creation. A member is created by an explicit creation operation. A type test operation always exists. In addition, a member ceases to exist when it is no longer accessible. </P><DIV id="section.stateful.port"><H2><A name="section.stateful.port">9.1 Ports</A></H2><P>Port is such an abstract data-type. A Port <CODE>P</CODE> is an asynchronous communication channel that can be shared among several senders. A port has a stream associated with it. The operation: <CODE>{Port<SPAN class="keyword">.</SPAN>new&nbsp;S&nbsp;?P}</CODE> creates a port <CODE>P</CODE> and initially connects it to the variable <CODE>S</CODE> taking the role of a stream. The operation: <CODE>{Port<SPAN class="keyword">.</SPAN>send&nbsp;P&nbsp;M}</CODE> will append the message <CODE>M</CODE> to the end of the stream associated with <CODE>P</CODE>. The port keeps track of the end of the stream as its next insertion point. The operation <CODE>{IsPort&nbsp;P&nbsp;?B}</CODE> checks whether <CODE>P</CODE> is a port. In order to protect the stream <CODE>S</CODE> from being bound by mistake <CODE>S</CODE> is actually a future. The following program shows a simple example using ports: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;S&nbsp;P<BR>P&nbsp;=&nbsp;{Port<SPAN class="keyword">.</SPAN>new&nbsp;S}<BR>{Browse&nbsp;S}&nbsp;</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>{Port<SPAN class="keyword">.</SPAN>send&nbsp;P&nbsp;1}<BR>{Port<SPAN class="keyword">.</SPAN>send&nbsp;P&nbsp;2}</CODE></BLOCKQUOTE><P> </P><P>If you enter the above statements incrementally you will observe that <CODE>S</CODE> gets incrementally more defined. </P><BLOCKQUOTE class="code"><CODE>S<BR>1<SPAN class="keyword">|</SPAN>&nbsp;<BR>1<SPAN class="keyword">|</SPAN>2<SPAN class="keyword">|</SPAN>_</CODE></BLOCKQUOTE><P> </P><P>Ports are more expressive abstractions than pure stream communication, which was discussed in <A href="node8.html#section.concurrency.stream">Section&nbsp;8.2</A>, since they can be shared among multiple threads, and can be embedded in other data structures. Ports are the main message passing mechanism between threads in Oz. </P></DIV><DIV id="section.stateful.clientserver"><H2><A name="section.stateful.clientserver">9.2 Client-Server Communication</A></H2><P>Ports are used as a communication entry point to servers. The program shown in <A href="node9.html#concurrentqueue">Figure&nbsp;9.1</A> defines a thread that acts as FIFO queue server. It has two ports, one for inserting items to the queue using <CODE>put</CODE>, and the other for fetch items out of the queue using <CODE>get</CODE>. The use of single-assignment (logic) variables makes the server insensitive to the relative arrival order of <CODE>get</CODE> and <CODE>put</CODE> requests. <CODE>get</CODE> requests can arrive even when the queue is empty. A server is created by <CODE>{NewQueueServer&nbsp;?Q}</CODE>. This procedure returns back a record <CODE>Q</CODE> with features <CODE>put</CODE> and <CODE>get</CODE> each holding a unary procedure. A client thread having access to <CODE>Q</CODE> can request services by invoking these procedure. Notice how results are returned back through logic variables. A client requesting an Item in the queue will call <CODE>{Q<SPAN class="keyword">.</SPAN>get&nbsp;I}</CODE>. The server will eventually answer back by binding <CODE>I</CODE> to an item. </P><P></P><DIV class="figure" id="concurrentqueue"><HR><P><A name="concurrentqueue"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewQueueServer</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Given&nbsp;GivePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Given}<BR>&nbsp;&nbsp;&nbsp;Taken&nbsp;TakePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Taken}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Given&nbsp;=&nbsp;Taken<BR>&nbsp;&nbsp;&nbsp;queue(put:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;GivePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;TakePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;9.1:</STRONG> Concurrent Queue server, first attempt </P><HR></DIV><P> </P><P>Try the following sequence of statements. The program will not work. So, what is the problem? </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">thread</SPAN>&nbsp;Q&nbsp;=&nbsp;{NewQueueServer}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>{Q<SPAN class="keyword">.</SPAN>put&nbsp;1}<BR>{Browse&nbsp;{Q<SPAN class="keyword">.</SPAN>get&nbsp;$}}<BR>{Browse&nbsp;{Q<SPAN class="keyword">.</SPAN>get&nbsp;$}}<BR>{Browse&nbsp;{Q<SPAN class="keyword">.</SPAN>get&nbsp;$}}<BR>{Q<SPAN class="keyword">.</SPAN>put&nbsp;2}<BR>{Q<SPAN class="keyword">.</SPAN>put&nbsp;3}</CODE></BLOCKQUOTE><P> </P><P> The problem is that <CODE>Given&nbsp;=&nbsp;Taken</CODE> is trying to impose equality between two futures. Remember that <CODE>Given</CODE> and <CODE>Taken</CODE> are futures that can only be read and cannot be bound. So the thread corresponding to the queue server will suspend in the statement <CODE>Given&nbsp;=&nbsp;Taken</CODE>. This problem is remedied by running this statement in its own thread as shown in <A href="node9.html#concurrentqueue1">Figure&nbsp;9.2</A> <A href="node9.html#label52"><SUP>1</SUP></A>. </P><P> The program works as follows. <CODE>{Q<SPAN class="keyword">.</SPAN>put&nbsp;I0}&nbsp;{Q<SPAN class="keyword">.</SPAN>put&nbsp;I1}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{Q<SPAN class="keyword">.</SPAN>put&nbsp;In}</CODE> will incrementally add the elements <CODE>I0&nbsp;I1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;In</CODE> to the stream <CODE>Given</CODE>, resulting in <CODE>I0<SPAN class="keyword">|</SPAN>I1<SPAN class="keyword">|...|</SPAN>In<SPAN class="keyword">|&lt;</SPAN>Future1<SPAN class="keyword">&gt;</SPAN></CODE>. <CODE>{Q<SPAN class="keyword">.</SPAN>get&nbsp;X0}&nbsp;{Q<SPAN class="keyword">.</SPAN>put&nbsp;X1}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{Q<SPAN class="keyword">.</SPAN>put&nbsp;Xn}</CODE> will add the elements <CODE>X0&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn</CODE> to the stream <CODE>Taken</CODE> resulting in <CODE>X0<SPAN class="keyword">|</SPAN>X1<SPAN class="keyword">|...|</SPAN>Xn<SPAN class="keyword">|&lt;</SPAN>Future2<SPAN class="keyword">&gt;</SPAN></CODE>. The equality constraint <CODE>Given&nbsp;=&nbsp;Taken</CODE> will bind <CODE>Xi<SPAN class="string">'s</SPAN></CODE> to <CODE>Ii<SPAN class="string">'s</SPAN></CODE>. </P><P></P><DIV class="figure" id="concurrentqueue1"><HR><P><A name="concurrentqueue1"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewQueueServer</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Given&nbsp;GivePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Given}<BR>&nbsp;&nbsp;&nbsp;Taken&nbsp;TakePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Taken}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;Given=Taken&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;queue(put:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;GivePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;TakePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;9.2:</STRONG> Concurrent Queue server</P><HR></DIV><P></P><P class="warning"><STRONG>Warning:</STRONG> The code above is correct but, due to a limitation in the current Oz implementation, leaks memory. As a workaround, one can use the code below as a drop-in replacement. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewQueueServer</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Given&nbsp;GivePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Given}<BR>&nbsp;&nbsp;&nbsp;Taken&nbsp;TakePort={Port<SPAN class="keyword">.</SPAN>new&nbsp;Taken}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">for</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Given&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Taken&nbsp;<SPAN class="keyword">do</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X=Y<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;queue(put:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;GivePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;TakePort&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P class="warning"> </P></DIV><DIV id="section.stateful.chunk"><H2><A name="section.stateful.chunk">9.3 Chunks</A></H2><P>Ports are actually stateful data structures. A port keeps a local state internally tracking the end of its associated stream. Oz provides two primitive devices to construct abstract stateful data-types <EM>chunks</EM> and <EM>cells</EM>. All others subtypes of chunks can be defined in terms of chunks and cells. </P><P>A chunk is similar to a record except that the label of a chunk is an oz-name, and there is no arity operation available on chunks. This means one can hide certain components of a chunk if the feature of the component is an oz-name that is visible only (by lexical scoping) to user-defined operations on the chunk. </P><P>A chunk is created by the procedure <CODE>{NewChunk&nbsp;Record}</CODE>. This creates a chunk with the same components as the record, but having a unique label. The following program creates a chunk. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X={NewChunk&nbsp;f(c:3&nbsp;a:1&nbsp;b:2)}<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X<SPAN class="keyword">.</SPAN>c}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>This will display the following. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">&lt;</SPAN>Ch<SPAN class="keyword">&gt;</SPAN>(a:1&nbsp;b:2&nbsp;c:3)<BR>3</CODE></BLOCKQUOTE><P></P><P class="warning"><STRONG>Warning:</STRONG> As a syntactic convenience, one can equate an expression <CODE>E</CODE> at an expression position with a variable <CODE>X&nbsp;=&nbsp;E</CODE>, and use <CODE>X</CODE> to refer to the value of the expression. Using this notation the above program could be written as </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X={NewChunk&nbsp;f(c:3&nbsp;a:1&nbsp;b:2)}}<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;X<SPAN class="keyword">.</SPAN>c}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P class="warning"> </P><P>In <A href="node9.html#portcellchunk">Figure&nbsp;9.3</A>, we show an example of using the information hiding ability of chunks to implement Ports. </P></DIV><DIV id="section.stateful.cell"><H2><A name="section.stateful.cell">9.4 Cells</A></H2><P>A cell could be seen as a chunk with a mutable single component. A cell is created as follows. </P><BLOCKQUOTE class="code"><CODE>{NewCell&nbsp;X&nbsp;?C}</CODE></BLOCKQUOTE><P> </P><P>A cell is created with the initial content <CODE>X</CODE>. <CODE>C</CODE> is bound to a cell. The <A href="node9.html#cellop">Table&nbsp;9.1</A> shows the operations on a cell. </P><P></P><DIV class="table" id="cellop"><HR><P><A name="cellop"></A></P></DIV><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>Operation</P></TH><TH><P>Description</P></TH></TR><TR valign="top"><TD><P><CODE>{NewCell&nbsp;X&nbsp;?C}</CODE></P></TD><TD><P>Creates a cell C with content X</P></TD></TR><TR valign="top"><TD><P><CODE>X=<SPAN class="keyword">@</SPAN>C</CODE></P></TD><TD><P>Returns the content of C in X</P></TD></TR><TR valign="top"><TD><P><CODE>C<SPAN class="keyword">:=</SPAN>Y</CODE></P></TD><TD><P>Modifies the content of C to Y</P></TD></TR><TR valign="top"><TD><P><CODE>{IsCell&nbsp;<SPAN class="keyword">+</SPAN>C}</CODE></P></TD><TD><P>Tests if C is a cell</P></TD></TR><TR valign="top"><TD><P><CODE>{Exchange&nbsp;<SPAN class="keyword">+</SPAN>C&nbsp;X&nbsp;Y}</CODE></P></TD><TD><P>Swaps atomically the content of C from X to Y</P></TD></TR></TABLE><DIV class="table"><P class="caption"><STRONG>Table&nbsp;9.1:</STRONG> Cell operations</P><HR></DIV><P> </P><P>Check the following program. The last statement increments the cell by one. If we leave out <CODE><SPAN class="keyword">thread</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> the program deadlocks. Do you know why? </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;I&nbsp;O&nbsp;X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;I&nbsp;=&nbsp;{NewCell&nbsp;a}&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>I}<BR>&nbsp;&nbsp;&nbsp;{Assign&nbsp;I&nbsp;b}&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>I}<BR>&nbsp;&nbsp;&nbsp;{Assign&nbsp;I&nbsp;X}&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>I}<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;5<SPAN class="keyword">*</SPAN>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Exchange&nbsp;I&nbsp;O&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;O<SPAN class="keyword">+</SPAN>1&nbsp;<SPAN class="keyword">end</SPAN>}&nbsp;{Browse&nbsp;<SPAN class="keyword">@</SPAN>I}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Cells and higher-order iterators allow conventional assignment-based programming in Oz. The following program accumulates in the cell <CODE>J</CODE> the value of <IMG alt="\sum_{i=1}^10 i" src="latex2.png">. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;J&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>J&nbsp;=&nbsp;{NewCell&nbsp;0}<BR>{For&nbsp;1&nbsp;10&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O&nbsp;N&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Exchange&nbsp;J&nbsp;O&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp;=&nbsp;O<SPAN class="keyword">+</SPAN>I<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR>{Browse&nbsp;<SPAN class="keyword">@</SPAN>J}</CODE></BLOCKQUOTE><P> </P><P>Ports described in <A href="node9.html#section.stateful.port">Section&nbsp;9.1</A> can be implemented by chunks and cells in a secure way, i.e. as an abstract data type that cannot be forged. The program in <A href="node9.html#portcellchunk">Figure&nbsp;9.3</A> shows an implementation of Ports. Initially an Oz-name is created locally, which is accessible only by the Port operations. A port is created as a chunk that has one component, which is a cell. The cell is initialized to the stream associated with the port. The type test <CODE>IsPort</CODE> is done by checking the feature <CODE>Port</CODE>. Sending a message to a port results in updating the stream atomically, and updating the cell to point to the tail of the stream. </P><P></P><DIV class="figure" id="portcellchunk"><HR><P><A name="portcellchunk"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Port&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;PortTag&nbsp;=&nbsp;{NewName}&nbsp;%<SPAN class="comment">New&nbsp;Oz&nbsp;name<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewPort</SPAN>&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;=&nbsp;{NewCell&nbsp;S}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{NewChunk&nbsp;port(PortTag:C)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">IsPort</SPAN>&nbsp;?P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Chunk<SPAN class="keyword">.</SPAN>hasFeature&nbsp;P&nbsp;PortTag}&nbsp;%<SPAN class="comment">Checks&nbsp;a&nbsp;chunk&nbsp;feature<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Send</SPAN>&nbsp;P&nbsp;M}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ms&nbsp;Mr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Exchange&nbsp;P<SPAN class="keyword">.</SPAN>PortTag&nbsp;Ms&nbsp;Mr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ms&nbsp;=&nbsp;M<SPAN class="keyword">|</SPAN>Mr<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;Port&nbsp;=&nbsp;port(new:NewPort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is:IsPort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send:Send)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;9.3:</STRONG> Implementation of Ports by Cells and Chunks</P><HR></DIV><P></P><P> The implementation in <A href="node9.html#portcellchunk">Figure&nbsp;9.3</A> does not protect the stream of the port. Protection of the stream is done using a future as follows. </P><P></P><DIV class="figure" id="portcellchunkf"><HR><P><A name="portcellchunkf"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;Port&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;PortTag&nbsp;=&nbsp;{NewName}&nbsp;%<SPAN class="comment">New&nbsp;Oz&nbsp;name<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewPort</SPAN>&nbsp;FS}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;C&nbsp;=&nbsp;{NewCell&nbsp;S}&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FS&nbsp;=&nbsp;<SPAN class="keyword">!!</SPAN>S&nbsp;&nbsp;%&nbsp;<SPAN class="comment">Create&nbsp;a&nbsp;future<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{NewChunk&nbsp;port(PortTag:C)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">IsPort</SPAN>&nbsp;?P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Chunk<SPAN class="keyword">.</SPAN>hasFeature&nbsp;P&nbsp;PortTag}&nbsp;%<SPAN class="comment">Checks&nbsp;a&nbsp;chunk&nbsp;feature<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Send</SPAN>&nbsp;P&nbsp;M}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ms&nbsp;Mr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Exchange&nbsp;P<SPAN class="keyword">.</SPAN>PortTag&nbsp;Ms&nbsp;Mr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ms&nbsp;=&nbsp;M<SPAN class="keyword">|!!</SPAN>Mr<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;Port&nbsp;=&nbsp;port(new:NewPort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is:IsPort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send:Send)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;9.4:</STRONG> Implementation of Ports by Cells and Chunks</P><HR></DIV><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html#chapter.concurrency">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node10.html#chapter.classes">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label52">1. </A>This design of a FIFO queue server was proposed by Denys Duchier</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzén</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
