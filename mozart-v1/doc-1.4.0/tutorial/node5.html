<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>5 Basic Control Structures</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node4.html#chapter.equality">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node6.html#chapter.functional">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.control"><H1><A name="chapter.control">5 Basic Control Structures</A></H1><P>We have already seen some basic statements in Oz. Introducing new variables and sequencing of statements: </P><BLOCKQUOTE class="code"><I>S1</I><CODE>&nbsp;&nbsp;&nbsp;</CODE><I>S2</I></BLOCKQUOTE><P> </P><P>Reiterating again, a thread executes statements in a sequential order. However a thread, contrary to conventional languages, may suspend in some statement, so above, a thread has to complete execution of <I>S1</I>, before starting <I>S2</I>. In fact, <I>S2</I> may not be executed at all, if an exception is raised in <I>S1</I>. </P><H2><A name="label28">5.1 skip</A></H2><P>The statement <CODE><SPAN class="keyword">skip</SPAN></CODE> is the empty statement. </P><DIV id="control.if"><H2><A name="control.if">5.2 If Statement</A></H2><P>Oz provides a simple form of conditional statement having the following form: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;B&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><CODE>B</CODE> should be a Boolean value. </P><H3><A name="label29">5.2.1 Semantics</A></H3><P></P><UL><LI><P>If <CODE>B</CODE> is bound to <CODE><SPAN class="keyword">true</SPAN></CODE> <I>S1</I> is executed </P></LI><LI><P>if <CODE>B</CODE> is bound to <CODE><SPAN class="keyword">false</SPAN></CODE> <I>S2</I> is executed </P></LI><LI><P>if <CODE>B</CODE> is bound to an non-boolean value, an exception is raised </P></LI><LI><P>otherwise if <CODE>B</CODE> is unbound the thread suspends until one of the cases above applies </P></LI></UL><P> </P><P class="margin">Comparison Procedures</P><P> Oz provides a number of built-in tertiary procedures used for comparison. These include <CODE><SPAN class="keyword">==</SPAN></CODE> that we have seen earlier as well as <CODE><SPAN class="keyword">\=</SPAN></CODE>, <CODE><SPAN class="keyword">=&lt;</SPAN></CODE>, <CODE><SPAN class="keyword">&lt;</SPAN></CODE>, <CODE><SPAN class="keyword">&gt;=</SPAN></CODE>, and <CODE><SPAN class="keyword">&gt;</SPAN></CODE>. Common to these procedures is that they are used as Boolean functions in an infix notation. The following example illustrates the use of an If-statement in conjunction with the greater-than operator <CODE><SPAN class="keyword">&gt;</SPAN></CODE>. </P><P>In this example <CODE>Z</CODE> is bound to the maximum of <CODE>X</CODE> and <CODE>Y</CODE>, i.e. to <CODE>Y</CODE>:</P><P></P><DIV class="figure" id="casestatement"><HR><P><A name="casestatement"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;5&nbsp;Y&nbsp;=&nbsp;10<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Z&nbsp;=&nbsp;X&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Z&nbsp;=&nbsp;Y&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.1:</STRONG> Using a if statement</P><HR></DIV><P> </P><H3><A name="label30">5.2.2 Abbreviations</A></H3><P>A statement using the keyword <CODE><SPAN class="keyword">elseif</SPAN></CODE>: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;</CODE><I>B2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S3</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>is shorthand for nested if-statements: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S3</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>An if-statement missing the else part: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>is equivalent to: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.procedure"><H2><A name="control.procedure">5.3 Procedural Abstraction</A></H2><H3><A name="label31">5.3.1 Procedure Definition</A></H3><P>Procedure definition is a primary abstraction in Oz. A procedure can be defined, passed around as argument to another procedure, or stored in a record. A procedure definition is a statement that has the following structure. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">P</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}&nbsp;S&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label32">5.3.2 Semantics</A></H3><P>Assume that the variable <CODE>P</CODE> is already introduced; executing the above statement will: </P><P></P><UL><LI><P>create a unique closure which is essentially a uniquely named lambda expression <IMG alt="\lambda(X_1 \ldots X_N).S" src="latex1.png"> </P></LI><LI><P>The variable <I>P</I> is bound to the closure. </P></LI></UL><P> </P><P>A procedure in Oz has a unique identity, given by its unique closure, and is distinct from all other procedures. Two procedure definitions are always different, even if they look similar. Procedures are the first Oz values that we encounter, whose equality is based on name equality. Others include threads, cells, and chunks. </P></DIV><DIV id="control.lexical"><H2><A name="control.lexical">5.4 On Lexical Scoping</A></H2><P>In general, the statement <I>S</I> in a procedure definition will have many variable occurrences. A variable that occurs textually in a statement is called an identifier to distinguish it from the logic variable that is a data structure created at runtime. Some identifier occurrences in <I>S</I> are <EM>syntactically bound</EM> while others are <EM>free</EM>. An identifier occurrence <I>X</I><A href="node5.html#label38"><SUP>1</SUP></A> in <I>S</I> is bound if it is in the scope of the procedure formal-parameter <I>X</I>, or is in the scope of a variable introduction statement that introduces <I>X</I>. Otherwise, the identifier occurrence is free. Each free identifier occurrence in a program is eventually bound by the closest textually surrounding identifier-binding construct. </P><P>We have already seen how to apply (call) a procedure. Let us now show our first procedure definition. In <A href="node5.html#casestatement">Figure&nbsp;5.1</A>, we have seen how to compute the maximum of two numbers or literals. We abstract this code into a procedure. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;Max&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Max</SPAN>&nbsp;X&nbsp;Y&nbsp;Z}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Z&nbsp;=&nbsp;X&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Z&nbsp;=&nbsp;Y&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;10<BR>&nbsp;&nbsp;&nbsp;{Max&nbsp;X&nbsp;Y&nbsp;Z}&nbsp;{Browse&nbsp;Z}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.anonymous"><H2><A name="control.anonymous">5.5 Anonymous Procedures and Variable Initialization</A></H2><P>One could ask why a variable is bound to a procedure in a way that is different from it being bound to a record, e.g. <CODE>X&nbsp;=&nbsp;</CODE><I>f(...)</I>? The answer is that what you see is just a syntactic variant of the equivalent form </P><BLOCKQUOTE class="code"><CODE>P&nbsp;=&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}&nbsp;S&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>The R.H.S. defines an <EM>anonymous procedural value</EM>. This is equivalent to </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">P</SPAN>&nbsp;X1&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Xn}&nbsp;S&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>In Oz, we can initialize a variable immediately while it is being introduced by using a <EM>variable-initialization equality</EM> </P><BLOCKQUOTE class="code"><CODE>X&nbsp;=&nbsp;</CODE>&lt;<I>Value</I>&gt;</BLOCKQUOTE><P> or </P><BLOCKQUOTE class="code">&lt;<I>Record</I>&gt;<CODE>&nbsp;=&nbsp;</CODE>&lt;<I>Value</I>&gt;</BLOCKQUOTE><P> </P><P>between <CODE><SPAN class="keyword">local</SPAN></CODE> and <CODE><SPAN class="keyword">in</SPAN></CODE>, in the statement <CODE><SPAN class="keyword">local</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE>. So the previous example could be written as follows, where we also use anonymous procedures. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Max&nbsp;=&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X&nbsp;Y&nbsp;Z}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Z&nbsp;=&nbsp;X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Z&nbsp;=&nbsp;Y&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;X&nbsp;=&nbsp;5<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;10<BR>&nbsp;&nbsp;&nbsp;Z<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Max&nbsp;X&nbsp;Y&nbsp;Z}&nbsp;{Browse&nbsp;Z}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Now let us understand variable initialization in more detail. The general rule says that: in a variable-initialization equality, only the variables occurring on the L.H.S. of the equality are the ones being introduced. Consider the following example: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;1<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;=&nbsp;f(M&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[X1&nbsp;Y]&nbsp;=&nbsp;L<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;[1&nbsp;2]<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Browse&nbsp;[M&nbsp;L]}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>First <CODE>Y</CODE> is introduced and initialized in the outer <CODE><SPAN class="keyword">local</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE>. Then, in the inner <CODE><SPAN class="keyword">local</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> all variables on the L.H.S. are introduced, i.e. <CODE>M</CODE>, <CODE>Y</CODE>, <CODE>X1</CODE>, and <CODE>L</CODE>. Therefore the outer variable <CODE>Y</CODE> is invisible in the innermost <CODE><SPAN class="keyword">local</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> statement. The above statement is equivalent to: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;1<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;M&nbsp;X1&nbsp;Y&nbsp;L&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;=&nbsp;f(M&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;[X1&nbsp;Y]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;[1&nbsp;2]<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Browse&nbsp;[M&nbsp;L]}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>If we want <CODE>Y</CODE> to denote the variable in the outer scope, we have to suppress the introduction of the inner <CODE>Y</CODE> in the L.H.S. of the initializing equality by using an exclamation mark <CODE><SPAN class="keyword">!</SPAN></CODE> as follows. An exclamation mark <CODE><SPAN class="keyword">!</SPAN></CODE> is only meaningful in the L.H.S. of an initializing equality <A href="node5.html#label39"><SUP>2</SUP></A>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;=&nbsp;1<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;=&nbsp;f(M&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[X1&nbsp;<SPAN class="keyword">!</SPAN>Y]&nbsp;=&nbsp;L<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;[1&nbsp;2]<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;{Browse&nbsp;[M&nbsp;L]}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.pattern"><H2><A name="control.pattern">5.6 Pattern Matching</A></H2><P>Let us consider a very simple example: insertion of elements in a binary tree. A binary tree is either empty, represented by <CODE>nil</CODE>, or is a tuple of the form <CODE>tree(Key&nbsp;Value&nbsp;TreeL&nbsp;TreeR)</CODE>, where <CODE>Key</CODE> is a key of the node with the corresponding value <CODE>Value</CODE>, and <CODE>TreeL</CODE> is the left subtree having keys less than <CODE>Key</CODE>, and <CODE>TreeR</CODE> is the right subtree having keys greater than <CODE>Key</CODE>. The procedure <CODE>Insert</CODE> takes four arguments, three of them are input arguments <CODE>Key</CODE>, <CODE>Value</CODE> and <CODE>TreeIn</CODE>, and one output argument <CODE>TreeOut</CODE> to be bound to the resulting tree after insertion. </P><P>The program is shown in <A href="node5.html#treeinsert">Figure&nbsp;5.2</A>. The symbol <CODE>?</CODE> before <CODE>TreeOut</CODE> is a voluntary <EM>documentation comment</EM> denoting that the argument plays the role of an output argument. The procedure works by cases as obvious. First depending on whether the tree is empty or not, and in the latter case depending on a comparison between the key of the node in the tree and the input key. Notice the use of <CODE><SPAN class="keyword">if</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> with the obvious meaning. </P><P></P><DIV class="figure" id="treeinsert"><HR><P><A name="treeinsert"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Insert</SPAN>&nbsp;Key&nbsp;Value&nbsp;TreeIn&nbsp;?TreeOut}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;TreeIn&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;TreeOut&nbsp;=&nbsp;tree(Key&nbsp;Value&nbsp;nil&nbsp;nil)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T2)&nbsp;=&nbsp;TreeIn&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;Key&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;K1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;TreeOut&nbsp;=&nbsp;tree(Key&nbsp;Value&nbsp;T1&nbsp;T2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;Key&nbsp;<SPAN class="keyword">&lt;</SPAN>&nbsp;K1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(K1&nbsp;V1&nbsp;T&nbsp;T2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;Key&nbsp;Value&nbsp;T1&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;Key&nbsp;Value&nbsp;T2&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.2:</STRONG> Inserting a node (key and value) in a binary tree</P><HR></DIV><P> </P><P>In <A href="node5.html#treeinsert">Figure&nbsp;5.2</A>, the local variable introduction statement </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T2)=&nbsp;TreeIn&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">...</SPAN></CODE></BLOCKQUOTE><P> </P><P>performed implicitly a pattern matching to extract the values of the locally introduced variables <CODE>K1</CODE>, <CODE>V1</CODE>, <CODE>T1</CODE> and <CODE>T2</CODE>. </P><P>Oz provides an explicit pattern-matching case statement, which allows implicit introduction of variables in the patterns. </P><H3><A name="label33">5.6.1 Case Statement</A></H3><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">case</SPAN>&nbsp;E&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;</CODE><I>Pattern_1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>All variables introduced in <I>Pattern_i</I> are implicitly declared, and have a scope stretching over the corresponding <I>Si</I>. </P><H3><A name="label34">5.6.2 Semantics</A></H3><P>Let us assume that expression <CODE>E</CODE> is evaluated to <CODE>V</CODE>. Executing the case statement will sequentially try to match <CODE>V</CODE> against the patterns <I>Pattern_1</I>, <I>Pattern_2</I>, ...,<I>Pattern_n</I> in this order. Matching <CODE>V</CODE> against <CODE>Pattern_i</CODE> is done in left-to-right depth-first manner. </P><P></P><UL><LI><P>If <CODE>V</CODE> matches <CODE>Pattern_i</CODE> without binding any variable occuring in <CODE>V</CODE>, the corresponding <I>Si</I> statement is executed. </P></LI><LI><P>If <CODE>V</CODE> matches <CODE>Pattern_i</CODE> but binds some variables occuring in <CODE>V</CODE>, the thread suspends </P></LI><LI><P>If the matching of <CODE>V</CODE> and <CODE>Pattern_i</CODE> fails, <CODE>V</CODE> is tried against the next pattern <CODE>Pattern_i<SPAN class="keyword">+</SPAN>1</CODE>, otherwise the <CODE><SPAN class="keyword">else</SPAN></CODE> statement <I>S</I> is executed.</P></LI></UL><P> </P><P>The <CODE><SPAN class="keyword">else</SPAN></CODE> part may be omitted, in which case an exception is raised if all matches fail. </P><P>Again, in each pattern one may suppress the introduction of a new local variable by using <CODE><SPAN class="keyword">!</SPAN></CODE>. For example, in the following example: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">case</SPAN>&nbsp;f(X1&nbsp;X2)&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;f(<SPAN class="keyword">!</SPAN>Y&nbsp;Z)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P><CODE>X1</CODE> is matched is against the value of the external variable <CODE>Y</CODE>. Now remember again that the case statement and its executing thread may suspend if <CODE>X1</CODE> is insufficiently instantiated to decide the result of the matching. Having all this said, <A href="node5.html#treeinsert2">Figure&nbsp;5.3</A> shows the tree-insertion procedure using a matching case-statement. We have also reduced the syntactic nesting by abbreviating: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;)<BR>&nbsp;&nbsp;{Insert&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>into: </P><BLOCKQUOTE class="code"><CODE><I>T</I></CODE><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;)<BR>&nbsp;&nbsp;{Insert&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><CODE><I>T</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> </P><P></P><DIV class="figure" id="treeinsert2"><HR><P><A name="treeinsert2"></A></P></DIV><BLOCKQUOTE class="code"><CODE>%&nbsp;<SPAN class="comment">case&nbsp;for&nbsp;pattern&nbsp;matching<BR></SPAN><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Insert</SPAN>&nbsp;Key&nbsp;Value&nbsp;TreeIn&nbsp;?TreeOut}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;TreeIn<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;TreeOut&nbsp;=&nbsp;tree(Key&nbsp;Value&nbsp;nil&nbsp;nil)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;Key&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;K1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;TreeOut&nbsp;=&nbsp;tree(Key&nbsp;Value&nbsp;T1&nbsp;T2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">elseif</SPAN>&nbsp;Key&nbsp;<SPAN class="keyword">&lt;</SPAN>&nbsp;K1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(K1&nbsp;V1&nbsp;T&nbsp;T2)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;Key&nbsp;Value&nbsp;T1&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TreeOut&nbsp;=&nbsp;tree(K1&nbsp;V1&nbsp;T1&nbsp;T)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;Key&nbsp;Value&nbsp;T2&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.3:</STRONG> Tree insertion using case statement</P><HR></DIV><P> </P><P>The expression <I>E</I> we may match against, could be any record structure, and not just a variable. This allows multiple argument matching, as shown in <A href="node5.html#smerge">Figure&nbsp;5.4</A>, which expects two sorted lists <CODE>Xs</CODE> and <CODE>Ys</CODE> and merges them into a sorted list <CODE>Zs</CODE>. </P><P></P><DIV class="figure" id="smerge"><HR><P><A name="smerge"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">SMerge</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<SPAN class="keyword">#</SPAN>Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil<SPAN class="keyword">#</SPAN>Ys&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs=Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Xs<SPAN class="keyword">#</SPAN>nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs=Xs<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;(X<SPAN class="keyword">|</SPAN>Xr)&nbsp;<SPAN class="keyword">#</SPAN>&nbsp;(Y<SPAN class="keyword">|</SPAN>Yr)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X<SPAN class="keyword">=&lt;</SPAN>Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{SMerge&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;Y<SPAN class="keyword">|</SPAN>Zr<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{SMerge&nbsp;Xs&nbsp;Yr&nbsp;Zr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.4:</STRONG> Merging of two sorted lists</P><HR></DIV><P> </P></DIV><DIV id="control.nesting"><H2><A name="control.nesting">5.7 Nesting</A></H2><A name="label35"></A><P>Let us use our <CODE>Insert</CODE> procedure as defined in <A href="node5.html#treeinsert2">Figure&nbsp;5.3</A>. The following statement inserts a few nodes in an initially empty tree. Note that we had to introduce a number of intermediate variables to perform our sequence of procedure calls. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;T0&nbsp;T1&nbsp;T2&nbsp;T3&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{Insert&nbsp;seif&nbsp;43&nbsp;nil&nbsp;T0}<BR>&nbsp;&nbsp;{Insert&nbsp;eeva&nbsp;45&nbsp;T0&nbsp;T1}<BR>&nbsp;&nbsp;{Insert&nbsp;rebecca&nbsp;20&nbsp;T1&nbsp;T2}<BR>&nbsp;&nbsp;{Insert&nbsp;alex&nbsp;17&nbsp;T2&nbsp;T3}<BR>&nbsp;&nbsp;{Browse&nbsp;T3}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Oz provides syntactic support for nesting one procedure call inside another statement at an expression position. So, in general: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;{P&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">...</SPAN>}<BR>&nbsp;&nbsp;{Q&nbsp;Y&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>could be written as: </P><BLOCKQUOTE class="code"><CODE>{Q&nbsp;{P&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;$&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}</CODE></BLOCKQUOTE><P> </P><P>Using <CODE>$</CODE> as a <A name="label36"></A> <EM>nesting marker</EM>, and thereby the variable <CODE>Y</CODE> is eliminated. The rule, to revert to the flattened syntax is that, a nested procedure call, inside a procedure call, is moved <EM>before</EM> the current statement; and a new variable is introduced with one occurrence replacing the nested procedure call, and the other occurrence replacing the nesting marker. </P><H3><A name="label37">5.7.1 Functional Nesting</A></H3><P>Another form of nesting is called functional nesting: a procedure <CODE>{P&nbsp;X&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;R}</CODE> could be considered as a function; its result is the argument <CODE>R</CODE>. Therefore <CODE>{P&nbsp;X&nbsp;<SPAN class="keyword">...</SPAN>}</CODE> could be considered as a function call that can be inserted in any expression instead of the result argument <CODE>R</CODE>. So <CODE>{Q&nbsp;{P&nbsp;X&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}</CODE> is equivalent to: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;R&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{P&nbsp;X&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;&nbsp;R}<BR>&nbsp;&nbsp;&nbsp;{Q&nbsp;R&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Now back to our example, a more concise form using functional nesting is: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{Insert&nbsp;alex&nbsp;17&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;rebecca&nbsp;20<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Insert&nbsp;eeva&nbsp;45&nbsp;{Insert&nbsp;seif&nbsp;43&nbsp;nil}}}}}&nbsp;</CODE></BLOCKQUOTE><P> </P><P>There is one more rule to remember. It has to do with a nested application inside a record or a tuple as in: </P><BLOCKQUOTE class="code"><CODE>Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>{SMerge&nbsp;Xr&nbsp;Ys}</CODE></BLOCKQUOTE><P> </P><P>Here, the nested application goes <EM>after</EM> the record (or list) construction statement. Therefore, we get </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>Zr<BR>&nbsp;&nbsp;&nbsp;{SMerge&nbsp;Xr&nbsp;Ys&nbsp;Zr}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P> Doing so makes many recursive procedures be <EM>tail-recursive</EM>. Tail-recursive procedures execute with the space efficiency of iterative constructs. </P><P>We can now rewrite our <CODE>SMerge</CODE> procedure as shown in <A href="node5.html#smerge2">Figure&nbsp;5.5</A>, where we use nested application. </P><P></P><DIV class="figure" id="smerge2"><HR><P><A name="smerge2"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">SMerge</SPAN>&nbsp;Xs&nbsp;Ys&nbsp;Zs}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<SPAN class="keyword">#</SPAN>Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil<SPAN class="keyword">#</SPAN>Ys&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs=Ys<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;Xs<SPAN class="keyword">#</SPAN>nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Zs=Xs<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;(X<SPAN class="keyword">|</SPAN>Xr)&nbsp;<SPAN class="keyword">#</SPAN>&nbsp;(Y<SPAN class="keyword">|</SPAN>Yr)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;X<SPAN class="keyword">=&lt;</SPAN>Y&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;X<SPAN class="keyword">|</SPAN>{SMerge&nbsp;Xr&nbsp;Ys}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;Zr&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zs&nbsp;=&nbsp;Y<SPAN class="keyword">|</SPAN>{SMerge&nbsp;Xs&nbsp;Yr}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.5:</STRONG> Merging two sorted lists written in nested form</P><HR></DIV><P> </P></DIV><DIV id="control.procasvals"><H2><A name="control.procasvals">5.8 Procedures as Values</A></H2><P>Since we have been inserting elements in binary trees, let us define a program that checks if a data structure is actually a binary tree. The procedure <CODE>BinaryTree</CODE> shown in <A href="node5.html#checkbintree">Figure&nbsp;5.6</A> checks a structure to verify whether it is a binary tree or not, and accordingly returns <CODE><SPAN class="keyword">true</SPAN></CODE> or <CODE><SPAN class="keyword">false</SPAN></CODE> in its result argument <CODE>B</CODE>. </P><P>Notice that we also defined the auxiliary local procedure <CODE>And</CODE>. </P><P></P><DIV class="figure" id="checkbintree"><HR><P><A name="checkbintree"></A></P></DIV><BLOCKQUOTE class="code"><CODE>%&nbsp;<SPAN class="comment">What&nbsp;is&nbsp;a&nbsp;binary&nbsp;tree?<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">And</SPAN>&nbsp;B1&nbsp;B2&nbsp;?B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;B1&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;B2&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">BinaryTree</SPAN>&nbsp;T&nbsp;?B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K&nbsp;V&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{And&nbsp;{BinaryTree&nbsp;T1}&nbsp;{BinaryTree&nbsp;T2}&nbsp;B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.6:</STRONG> Checking a binary tree</P><HR></DIV><P> </P><P>Consider the call <CODE>{And&nbsp;{BinaryTree&nbsp;T1}&nbsp;{BinaryTree&nbsp;T2}&nbsp;B}</CODE>. It is certainly doing unnecessary work. According to our nesting rules, it evaluates its second argument even if the first is <CODE><SPAN class="keyword">false</SPAN></CODE>. One can fix this problem by making a new procedure <CODE>AndThen</CODE> that takes as its first two arguments two procedures, and calls the second procedure only if the first returns <CODE><SPAN class="keyword">false</SPAN></CODE>; thus, getting the effect of delaying the evaluation of its arguments until really needed. The procedure is shown <A href="node5.html#checkbintreelazy">Figure&nbsp;5.7</A>. <CODE>AndThen</CODE> is the first example of <EM>a higher-order procedure</EM>, i.e. a procedure that takes other procedures as arguments, and may return other procedures as results. In our case, <CODE>AndThen</CODE> just returns a Boolean value. However, in general, we are going to see other examples where procedures return procedures as result. As in functional languages, higher order procedures are invaluable abstraction devices that help creating generic reusable components. </P><P></P><DIV class="figure" id="checkbintreelazy"><HR><P><A name="checkbintreelazy"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">AndThen</SPAN>&nbsp;BP1&nbsp;BP2&nbsp;?B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{BP1}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;{BP2}&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">BinaryTree</SPAN>&nbsp;T&nbsp;?B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tree(K&nbsp;V&nbsp;T1&nbsp;T2)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{AndThen<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;B1}&nbsp;{BinaryTree&nbsp;T1&nbsp;B1}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;B2}&nbsp;{BinaryTree&nbsp;T2&nbsp;B2}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;B&nbsp;=&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.7:</STRONG> Checking a binary tree lazily</P><HR></DIV><P> </P></DIV><DIV id="control.controlabs"><H2><A name="control.controlabs">5.9 Control Abstractions</A></H2><P>Higher-order procedures are used in Oz to define various control abstractions. In the modules <A href="../base/node12.html#chapter.control"><CODE>Control</CODE></A> and <A href="../base/list.html#section.records.lists"><CODE>List</CODE></A> as well as many others, you will find many control abstractions. Here are some examples. The procedure <A href="../base/loop.html#section.control.loops"><CODE>{For&nbsp;From&nbsp;To&nbsp;Step&nbsp;P}</CODE></A> is an iterator abstraction that applies the unary procedure <CODE>P</CODE> (normally saying the procedure <CODE>P<SPAN class="keyword">/</SPAN>1</CODE> instead) to integers from <CODE>From</CODE> to <CODE>To</CODE> proceeding in steps <CODE>Step</CODE>. Executing <CODE>{For&nbsp;1&nbsp;10&nbsp;1&nbsp;Browse}</CODE> will display the integers <CODE>1&nbsp;2&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;10</CODE>. </P><P></P><DIV class="figure" id="foriterator"><HR><P><A name="foriterator"></A></P></DIV><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">HelpPlus</SPAN>&nbsp;C&nbsp;To&nbsp;Step&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;C<SPAN class="keyword">=&lt;</SPAN>To&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{P&nbsp;C}&nbsp;{HelpPlus&nbsp;C<SPAN class="keyword">+</SPAN>Step&nbsp;To&nbsp;Step&nbsp;P}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">HelpMinus</SPAN>&nbsp;C&nbsp;To&nbsp;Step&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;C<SPAN class="keyword">&gt;=</SPAN>To&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{P&nbsp;C}&nbsp;{HelpMinus&nbsp;C<SPAN class="keyword">+</SPAN>Step&nbsp;To&nbsp;Step&nbsp;P}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">For</SPAN>&nbsp;From&nbsp;To&nbsp;Step&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;Step<SPAN class="keyword">&gt;</SPAN>0&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{HelpPlus&nbsp;From&nbsp;To&nbsp;Step&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;{HelpMinus&nbsp;From&nbsp;To&nbsp;Step&nbsp;P}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;5.8:</STRONG> The For iterator</P><HR></DIV><P> </P><P>Another control abstraction that is often used is the <CODE>ForAll<SPAN class="keyword">/</SPAN>2</CODE> iterator defined in the <CODE>List</CODE> module. <CODE>ForAll<SPAN class="keyword">/</SPAN>2</CODE> applies a unary procedure on all the elements of a list, in the order defined by the list. Think what happens if the list is produced incrementally by another concurrent thread? In this case the consumer thread will synchronize on the availability of data on the list. The list behaves as a stream of elements and we automatically get stream communication between threads. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">ForAll</SPAN>&nbsp;Xs&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Xs<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{P&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;Xr&nbsp;P}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.exception"><H2><A name="control.exception">5.10 Exception Handling</A></H2><P>Oz incorporates an exception handling mechanism that allows safeguarding programs against exceptional and/or unforeseeable situations at run-time. It is also possible to raise and handle user-defined exceptions. </P><P>An exception is any expression <I>E</I>. To raise the exception <I>E</I>, one executes the following statement: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">raise</SPAN>&nbsp;</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Here is a simple example: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Eval</SPAN>&nbsp;E}&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;E<BR>&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;&nbsp;&nbsp;plus(X&nbsp;Y)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;X<SPAN class="keyword">+</SPAN>Y}<BR>&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;&nbsp;&nbsp;times(X&nbsp;Y)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;X<SPAN class="keyword">*</SPAN>Y}<BR>&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;illFormedExpression(E)&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>The basic exception handling statement is called a try-statement. Its simplest form is: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P><P>Execution of this statement is equivalent to executing <I>S1</I> if <I>S1</I> does not raise an exception. If <I>S1</I> raises an exception <I>E</I>, <I>X</I> gets bound to <I>E</I> and the statement <I>S2</I> is executed. The variable <I>X</I> is visible in the scope of <I>S2</I>. </P><P> A more convenient try statement has the following form: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><I>Pattern_1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_n</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>Sn</I><CODE>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> This is equivalent to: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;X&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;</CODE><I>Pattern_1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_n</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>Sn</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Put into words, the Execution of this statement is equivalent to executing <I>S</I> if <I>S</I> does not raise an exception. If <I>S</I> raises exception <I>E</I> and <I>E</I> matches one of the patterns <I>Pattern_i</I>, control is passed to the corresponding statement <I>S_i</I>. If <I>E</I> does not match any pattern the exception is propagated outside the try-statement until eventually caught by the system, which catches all escaping exceptions. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;[plus(5&nbsp;10)&nbsp;times(6&nbsp;11)&nbsp;min(7&nbsp;10)]&nbsp;Eval}<BR><SPAN class="keyword">catch</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;illFormedExpression(X)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;<SPAN class="string">'**&nbsp;'</SPAN><SPAN class="keyword">#</SPAN>X<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;**'</SPAN>}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>A try-statement may also specify a final statement <I>S_final</I>, which is executed on normal as well as on exceptional exit. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><I>Pattern_1</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_2</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">[]</SPAN>&nbsp;</CODE><I>Pattern_n</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>Sn</I><CODE>&nbsp;<BR><SPAN class="keyword">finally</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><I>S_final</I><CODE>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Assume that <CODE>F</CODE><A href="node5.html#label40"><SUP>3</SUP></A> is an opened file; the procedure <CODE>Process<SPAN class="keyword">/</SPAN>1</CODE> manipulates the file in some way; and the procedure <CODE>CloseFile<SPAN class="keyword">/</SPAN>1</CODE> closes the file. The following program ensures that the <CODE>F</CODE> is closed upon normal or exceptional exit. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;{Process&nbsp;F}<BR><SPAN class="keyword">catch</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Browse&nbsp;<SPAN class="string">'**&nbsp;'</SPAN><SPAN class="keyword">#</SPAN>X<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;**'</SPAN>}&nbsp;&nbsp;<BR><SPAN class="keyword">finally</SPAN>&nbsp;{CloseFile&nbsp;F}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="control.sysexcept"><H2><A name="control.sysexcept">5.11 System Exceptions</A></H2><P>The exceptions raised by the Oz system are records with one of the labels: <CODE>failure</CODE>, <CODE>error</CODE>, and <CODE>system</CODE>. </P><P></P><UL><LI><P><CODE>failure</CODE>: indicates the attempt to perform an inconsistent equality operation on the store of Oz. </P></LI><LI><P><CODE>error</CODE>: indicates a runtime error which should not occur such as applying a nonprocedure to some argument or adding an integer to an atom, etc. </P></LI><LI><P><CODE>system</CODE>: indicates a runtime condition because of the environment of the Mozart operating system process, i.e., an unforeseeable situation like a closed file or window; or failing to open a connection between two Mozart processes. </P></LI></UL><P> </P><P>The following example demonstrates how to catch a failure exception by its label only. This is the recommended method, for it is less dependent on implementation details. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">One</SPAN>&nbsp;X}&nbsp;X=1&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Two</SPAN>&nbsp;X}&nbsp;X=2&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">try</SPAN>&nbsp;{One}={Two}<BR><SPAN class="keyword">catch</SPAN>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;failure(<SPAN class="keyword">...</SPAN>)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Show&nbsp;caughtFailure}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Here the pattern <CODE>failure(<SPAN class="keyword">...</SPAN>)</CODE> catches any record whose label is <CODE>failure</CODE>. When an exception is raised but not handled, an error message is printed in the emulator window (standard error), and the current thread terminates. In stand-alone applications the default behavior is that a message is printed on standard error and the whole application terminates. It is possible to change this behavior to something else that is more desirable for particular applications. </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node4.html#chapter.equality">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node6.html#chapter.functional">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label38">1. </A>This rule is approximate, since class methods and patterns bind identifier occurrences</DIV><DIV class="footnote"><A name="label39">2. </A>In fact the exclamation mark <CODE><SPAN class="keyword">!</SPAN></CODE> can be used in other situation where you want to suppress the introduction of new variables, for example in pattern matching constructs</DIV><DIV class="footnote"><A name="label40">3. </A>We will now see how input/output is handled later</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzn</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
