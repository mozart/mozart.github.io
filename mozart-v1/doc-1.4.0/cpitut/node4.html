<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1.3 Replacing a Propagator</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#u_getting_started">&lt;&lt; Prev</A></TD><TD><A href="node1.html">- Up -</A></TD><TD><A href="node5.html#u_nesting">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="u_replacing"><H2><A name="u_replacing">1.3 Replacing a Propagator</A></H2><P>There are situations when a propagator should be replaced by another one. The replacing propagator must have the same declarative semantics, but should provide a more efficient implementation for a particular situation. </P><P>Consider the following situation: First a propagator <IMG alt="x+y=z" src="latex1.png"> was imposed. At a later point in time the constraint <IMG alt="x=y" src="latex26.png"> is told to the constraint store. The equality constraint allows to replace <IMG alt="x+y=z" src="latex1.png"> by <IMG alt="2x=z" src="latex27.png">. The rules below show how <IMG alt="x+y=z" src="latex1.png"> can be replaced by another (equality) constraint, if two variables are set equal. </P><P></P><DIV id="u_replace.rule1"><P class="margin"></P><P> Rule 1: <IMG alt="x+y=z \;\wedge\; x=y  \;\rightarrow\;  z=2x" src="latex28.png"> </P></DIV><DIV id="u_replace.rule2"><P class="margin"></P><P> Rule 2: <IMG alt="x+y=z \;\wedge\; x=z  \;\rightarrow\;  y=0" src="latex29.png"> </P></DIV><DIV id="u_replace.rule3"><P class="margin"></P><P> Rule 3: <IMG alt="x+y=z \;\wedge\; y=z  \;\rightarrow\;  x=0" src="latex30.png"> </P></DIV><P>Such simplifications can be implemented by replacing a propagator by another one. The C<SPAN class="allcaps">PI</SPAN> provides for that purpose in <CODE>OZ_Propagator</CODE> a group of member functions <CODE>replaceBy</CODE>. This section demonstrates how to realise the above simplifications using the example of the previous section. </P><DIV id="u_replace.twice"><H3><A name="u_replace.twice">1.3.1 A Twice Propagator</A></H3><P>The implementation of the simplification rule <IMG alt="x+y=z \wedge x=y \rightarrow 2x=z" src="latex31.png"> requires a propagator for the constraint <IMG alt="2x=z" src="latex27.png">. The following code defines the class <CODE>TwiceProp</CODE>. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">TwiceProp</SPAN>&nbsp;:&nbsp;<SPAN class="keyword">public</SPAN>&nbsp;<SPAN class="type">OZ_Propagator</SPAN>&nbsp;{<BR><SPAN class="keyword">private</SPAN>:<BR>&nbsp;&nbsp;<SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">OZ_PropagatorProfile</SPAN>&nbsp;<SPAN class="variablename">profile</SPAN>;<BR>&nbsp;&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">_x</SPAN>,&nbsp;<SPAN class="variablename">_z</SPAN>;<BR><SPAN class="keyword">public</SPAN>:<BR>&nbsp;&nbsp;<SPAN class="functionname">TwiceProp</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">a</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">b</SPAN>)&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;:&nbsp;_x(a),&nbsp;_z(b)&nbsp;{}<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">propagate</SPAN>(<SPAN class="type">void</SPAN>);<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">size_t</SPAN>&nbsp;<SPAN class="functionname">sizeOf</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;<SPAN class="keyword">sizeof</SPAN>(TwiceProp);&nbsp;&nbsp;<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">gCollect</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;OZ_gCollectTerm(_x);&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;OZ_gCollectTerm(_z);&nbsp;&nbsp;<BR>&nbsp;&nbsp;}&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">sClone</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;OZ_sCloneTerm(_x);&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;OZ_sCloneTerm(_z);&nbsp;&nbsp;<BR>&nbsp;&nbsp;}&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">getParameters</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;OZ_cons(_x,&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OZ_cons(_z,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OZ_nil()));<BR>&nbsp;&nbsp;}<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_PropagatorProfile</SPAN>&nbsp;*<SPAN class="functionname">getProfile</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>&nbsp;{&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;&amp;profile;<BR>&nbsp;&nbsp;}<BR>};<BR>&nbsp;<BR><SPAN class="type">OZ_PropagatorProfile</SPAN>&nbsp;<SPAN class="reference">TwiceProp</SPAN>::<SPAN class="variablename">profile</SPAN>;<BR></PRE></BLOCKQUOTE><P> </P><P>The member function <CODE>propagate()</CODE> mainly consists of a <CODE><SPAN class="keyword">for</SPAN></CODE>-loop collecting in auxiliary variables the values <IMG alt="v_x" src="latex32.png"> and <IMG alt="v_z" src="latex24.png"> satisfying the relation <IMG alt="2v_x=v_z" src="latex33.png">. </P><P></P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="reference">TwiceProp</SPAN>::<SPAN class="functionname">propagate</SPAN>(<SPAN class="type">void</SPAN>)<BR>{<BR>&nbsp;&nbsp;<SPAN class="type">OZ_FDIntVar</SPAN>&nbsp;<SPAN class="variablename">x</SPAN>(_x),&nbsp;z(_z);<BR>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="type">OZ_FiniteDomain</SPAN>&nbsp;<SPAN class="variablename">x_aux</SPAN>(fd_empty),&nbsp;<SPAN class="variablename">z_aux</SPAN>(fd_empty);<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">for</SPAN>&nbsp;(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">i</SPAN>&nbsp;=&nbsp;x-&gt;getMinElem();&nbsp;i&nbsp;!=&nbsp;-1;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;x-&gt;getNextLargerElem(i))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">i2</SPAN>&nbsp;=&nbsp;2&nbsp;*&nbsp;i;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;(z-&gt;isIn(i2))&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_aux&nbsp;+=&nbsp;i;&nbsp;z_aux&nbsp;+=&nbsp;i2;<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;FailOnEmpty(*x&nbsp;&amp;=&nbsp;x_aux);<BR>&nbsp;&nbsp;FailOnEmpty(*z&nbsp;&amp;=&nbsp;z_aux);<BR>&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(x.leave()&nbsp;|&nbsp;z.leave())<BR>&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;OZ_SLEEP&nbsp;:&nbsp;OZ_ENTAILED;<BR>&nbsp;<BR><SPAN class="reference">failure</SPAN>:&nbsp;&nbsp;<BR>&nbsp;&nbsp;x.fail();&nbsp;z.fail();<BR>&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;OZ_FAILED;<BR>}<BR>&nbsp;<BR></PRE></BLOCKQUOTE><P></P><P></P></DIV><DIV id="u_replace.equality"><H3><A name="u_replace.equality">1.3.2 Equality Detection and Replacement</A></H3><P>Imposing equality on variables is done by unification. A propagator is <EM>always</EM> resumed if at least one variable of its parameters is unified with another variable. The class <CODE>OZ_Propagator</CODE> provides for a member function <CODE>mayBeEqualVars()</CODE>, which returns 1 in case the propagator is resumed because at least one of its parameters was involved in a unification. Otherwise it returns 0. </P><P>To detect if the addition propagator is resumed because of a unification the following macro is defined. First, it checks if the propagator's parameters were involved in some unification. If that is the case, all possible combinations of equated variables are tested. The C<SPAN class="allcaps">PI</SPAN> function <CODE>OZ_isEqualVars()</CODE> is provided for that purpose. It takes two heap references and returns 1 if they refer to the same variable. In case equal variables are detected the execution branches to a <CODE>return</CODE> statement, which returns the value produced by executing the function passed as argument of the macro. </P><P></P><BLOCKQUOTE class="linenumbers"><PRE>#define&nbsp;<SPAN class="functionname">ReplaceOnUnify</SPAN>(<SPAN class="variablename">EQ01</SPAN>,&nbsp;<SPAN class="variablename">EQ02</SPAN>,&nbsp;<SPAN class="variablename">EQ12</SPAN>)&nbsp;\<BR>&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;(mayBeEqualVars())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;(OZ_isEqualVars(_x,&nbsp;_y))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(EQ01);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;(OZ_isEqualVars(_x,&nbsp;_z))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(EQ02);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;(OZ_isEqualVars(_y,&nbsp;_z))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(EQ12);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<BR>&nbsp;&nbsp;}<BR></PRE></BLOCKQUOTE><P> </P><P>The macro is inserted as first statement in the code of the addition propagator. The member functions <CODE>replaceBy()</CODE> and <CODE>replaceByInt()</CODE> provided by <CODE>OZ_Propagator</CODE> replace the addition propagator according to their arguments by another propagator or a basic constraint. </P><P></P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="reference">AddProp</SPAN>::<SPAN class="functionname">propagate</SPAN>(<SPAN class="type">void</SPAN>)<BR>{<BR></PRE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="linenumbers"><PRE>&nbsp;&nbsp;ReplaceOnUnify(replaceBy(<SPAN class="keyword">new</SPAN>&nbsp;<SPAN class="type">TwiceProp</SPAN>(_x,&nbsp;_z)),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replaceByInt(_y,&nbsp;0),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replaceByInt(_x,&nbsp;0));<BR></PRE></BLOCKQUOTE><P> </P><P>The first argument of the macro causes the addition propagator to be replaced by the twice propagator, which implements reduction rule 1 <A href="node4.html#u_replace.rule1">*</A>. The member function <CODE>replaceBy()</CODE> expects a pointer to a propagator which is generated by applying the <CODE>new</CODE> operator to the constructor of the class <CODE>TwiceProp</CODE>. The second and third macro argument realize the simplification rules 2 <A href="node4.html#u_replace.rule2">*</A> and 3 <A href="node4.html#u_replace.rule3">*</A> by imposing the constraint <IMG alt="y=0" src="latex34.png"> resp. <IMG alt="x=0" src="latex35.png">. </P></DIV><DIV id="u_replace.benefits"><H3><A name="u_replace.benefits">1.3.3 Benefits of Replacing Propagators</A></H3><P>In most of the cases when propagators are replaced the execution becomes faster without obtaining a stronger propagation simply by the fact that redundant computation is avoided. The example of this section provides for even better propagation by imposing a stronger constraint. This can be observed when running the following Oz code. Of course, the updated module has to be loaded before. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">declare</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>{Browse&nbsp;[X&nbsp;Y&nbsp;Z]}&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">[X&nbsp;Y&nbsp;Z]<BR></SPAN>&nbsp;<BR>X&nbsp;<SPAN class="keyword">::</SPAN>&nbsp;[1&nbsp;3&nbsp;5&nbsp;7&nbsp;9]&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">[X{1&nbsp;3&nbsp;5&nbsp;7&nbsp;9}<BR></SPAN>Y&nbsp;<SPAN class="keyword">::</SPAN>&nbsp;[1&nbsp;3&nbsp;5&nbsp;7&nbsp;9]&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;<SPAN class="comment">Y{1&nbsp;3&nbsp;5&nbsp;7&nbsp;9}<BR></SPAN>Z&nbsp;<SPAN class="keyword">::</SPAN>&nbsp;0<SPAN class="keyword">#</SPAN>10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;<SPAN class="comment">Z{0#10}]<BR></SPAN>&nbsp;<BR>{FD_PROP<SPAN class="keyword">.</SPAN>add&nbsp;X&nbsp;Y&nbsp;Z}&nbsp;%&nbsp;<SPAN class="comment">[X{1&nbsp;3&nbsp;5&nbsp;7&nbsp;9}&nbsp;Y{1&nbsp;3&nbsp;5&nbsp;7&nbsp;9}<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;<SPAN class="comment">Z{2&nbsp;4&nbsp;6&nbsp;8&nbsp;10}]<BR></SPAN>X&nbsp;=&nbsp;Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">[Y{1&nbsp;3&nbsp;5}&nbsp;Y{1&nbsp;3&nbsp;5}&nbsp;Z{2&nbsp;6&nbsp;10}]<BR></SPAN>&nbsp;<BR></PRE></BLOCKQUOTE><P> </P><P>Note that the constraint <IMG alt="x=y" src="latex26.png"> causes <IMG alt="x+y=z" src="latex1.png"> to be replaced by <IMG alt="2x=z" src="latex27.png">, so that the domain of <IMG alt="x" src="latex4.png"> and <IMG alt="y" src="latex5.png"> is further constrained to <IMG alt="\{1,3,5\}" src="latex36.png">, which is not the case for the propagator implemented in <A href="node3.html#u_getting_started">Section&nbsp;1.2</A>. </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#u_getting_started">&lt;&lt; Prev</A></TD><TD><A href="node1.html">- Up -</A></TD><TD><A href="node5.html#u_nesting">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
