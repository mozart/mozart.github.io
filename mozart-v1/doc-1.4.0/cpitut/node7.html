<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1.6 Connecting Finite Domain and Finite Set Constraints</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node6.html#u_vectors">&lt;&lt; Prev</A></TD><TD><A href="node1.html">- Up -</A></TD><TD><A href="node8.html#u_advanced">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="u_connect"><H2><A name="u_connect">1.6 Connecting Finite Domain and Finite Set Constraints</A></H2><P> The propagator in this section involves apart from finite domain constraints also finite set constraints. Its semantics is straightforward: it connects a domain variable <IMG alt="D" src="latex7.png"> and a set variable <IMG alt="S" src="latex10.png"> by projecting the changes of the constraints in both directions. Hereby, the finite domain variable designates an integer <IMG alt="i" src="latex49.png"> (as usual) and the set variable designates a singleton set <IMG alt="\{e\}" src="latex60.png"> where <IMG alt="i = e" src="latex61.png">. </P><P class="margin">Propagation Rules</P><P> There are three propagation rules: </P><OL type="1"><LI><P><IMG alt="\#S = 1" src="latex62.png"></P></LI><LI><P><IMG alt="D \subseteq S" src="latex63.png"></P></LI><LI><P><IMG alt="S \subseteq D" src="latex64.png"></P></LI></OL><P> The last two rules propagate the changes of the upper bound of the set constraint to the domain constraint and the other way around. </P><H3><A name="label3">1.6.1 The Class Definition</A></H3><P> The class definition does not have any particularities. It follows the scheme known from previous sections. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ConnectProp</SPAN>&nbsp;:&nbsp;<SPAN class="keyword">public</SPAN>&nbsp;<SPAN class="type">OZ_Propagator</SPAN>&nbsp;{<BR><SPAN class="keyword">private</SPAN>:<BR>&nbsp;&nbsp;<SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">OZ_PropagatorProfile</SPAN>&nbsp;<SPAN class="variablename">profile</SPAN>;<BR><SPAN class="keyword">protected</SPAN>:<BR>&nbsp;&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">_fs</SPAN>;<BR>&nbsp;&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">_fd</SPAN>;<BR><SPAN class="keyword">public</SPAN>:<BR>&nbsp;&nbsp;<SPAN class="functionname">ConnectProp</SPAN>(<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">fsvar</SPAN>,&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="variablename">fdvar</SPAN>)&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;_fs(fsvar),&nbsp;_fd(fdvar)&nbsp;&nbsp;{}<BR>&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">gCollect</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;OZ_gCollectTerm(_fd);<BR>&nbsp;&nbsp;&nbsp;&nbsp;OZ_gCollectTerm(_fs);<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">sClone</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;OZ_sCloneTerm(_fd);<BR>&nbsp;&nbsp;&nbsp;&nbsp;OZ_sCloneTerm(_fs);<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">size_t</SPAN>&nbsp;<SPAN class="functionname">sizeOf</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;<SPAN class="keyword">sizeof</SPAN>(ConnectProp);<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">getParameters</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;OZ_cons(_fs,&nbsp;(OZ_cons(_fd,&nbsp;OZ_nil())));<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_PropagatorProfile</SPAN>&nbsp;*<SPAN class="functionname">getProfile</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;&amp;profile;<BR>&nbsp;&nbsp;}<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">virtual</SPAN>&nbsp;<SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="functionname">propagate</SPAN>();<BR>};<BR></PRE></BLOCKQUOTE><P> Note that set variables are handled the same way as domain variables. </P><H3><A name="label4">1.6.2 The Propagation Function</A></H3><P> The implementation of the propagation function starts with retrieving the constrained variables from the constraint store using the constructors of the classes <CODE>OZ_FDIntVar</CODE> and <CODE>OZ_FSetVar</CODE>. The class <CODE>OZ_FSetVar</CODE> provides for the same member functions as <CODE>OZ_FDIntVar</CODE> such that handling set variables does not differ from handling domain variables. </P><P class="margin">Propagation</P><P> The propagation starts with the first rule. it uses the member function <CODE>OZ_FSetConstraint<SPAN class="keyword">::</SPAN>putcard(int<SPAN class="keyword">,</SPAN>&nbsp;<BR>int)</CODE> to impose the cardinality constraint upon <IMG alt="S" src="latex10.png">. The second rule implemented by removing all elements from <IMG alt="D" src="latex7.png"> that are definitely not in <IMG alt="S" src="latex10.png"> (see <A href="../cpiref/node8.html#r_fsc.refl">Section&nbsp;1.8.3 of ``The Mozart Constraint Extensions Reference''</A> for details on <CODE>OZ_FSetConstraint<SPAN class="keyword">::</SPAN>getNotInSet()</CODE>). The last propagation rule uses the operator <CODE>OZ_FSetConstraint<SPAN class="keyword">::</SPAN>operator&nbsp;<SPAN class="keyword">&lt;=</SPAN></CODE> for <IMG alt="S \subseteq
D" src="latex65.png">. The constructor <CODE>OZ_FSetConstraint</CODE> is used to convert the <CODE>OZ_Finite&nbsp;Domain</CODE> appropriately. Note that imposing constraints on <IMG alt="D" src="latex7.png"> resp. <IMG alt="S" src="latex10.png"> are guarded by <CODE>FailOnEmpty</CODE> resp. <CODE>FailOnInvalid</CODE> to catch failures. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="type">OZ_Return</SPAN>&nbsp;<SPAN class="reference">ConnectProp</SPAN>::<SPAN class="functionname">propagate</SPAN>()&nbsp;{<BR>&nbsp;<BR>printf(<SPAN class="string">&quot;ConnectProp::propagate\n&quot;</SPAN>);<BR>&nbsp;&nbsp;<BR>&nbsp;&nbsp;<SPAN class="type">OZ_FDIntVar</SPAN>&nbsp;<SPAN class="variablename">fd</SPAN>(_fd);<BR>&nbsp;&nbsp;<SPAN class="type">OZ_FSetVar</SPAN>&nbsp;&nbsp;<SPAN class="variablename">fs</SPAN>(_fs);<BR>&nbsp;<BR>&nbsp;&nbsp;//&nbsp;<SPAN class="comment">1st&nbsp;propagation&nbsp;rule<BR></SPAN>&nbsp;&nbsp;fs-&gt;putCard(1,&nbsp;1);&nbsp;&nbsp;<BR>&nbsp;<BR>&nbsp;&nbsp;//&nbsp;<SPAN class="comment">2nd&nbsp;propagation&nbsp;rule<BR></SPAN>&nbsp;&nbsp;FailOnEmpty(*fd&nbsp;-=&nbsp;fs-&gt;getNotInSet());<BR>&nbsp;<BR>&nbsp;&nbsp;//&nbsp;<SPAN class="comment">3rd&nbsp;propagation&nbsp;rule<BR></SPAN>&nbsp;&nbsp;FailOnInvalid(*fs&nbsp;&lt;=&nbsp;OZ_FSetConstraint(*fd));<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(fd.leave()&nbsp;|&nbsp;fs.leave())&nbsp;?&nbsp;OZ_SLEEP&nbsp;:&nbsp;OZ_ENTAILED;<BR>&nbsp;<BR><SPAN class="reference">failure</SPAN>:<BR>&nbsp;&nbsp;fd.fail();&nbsp;fs.fail();<BR>&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;OZ_FAILED;<BR>}<BR></PRE></BLOCKQUOTE><P> The macro <CODE>FailOnInvalid</CODE> is define as </P><BLOCKQUOTE class="linenumbers"><PRE>#define&nbsp;<SPAN class="functionname">FailOnInvalid</SPAN>(<SPAN class="variablename">X</SPAN>)&nbsp;<SPAN class="keyword">if</SPAN>(!(X))&nbsp;<SPAN class="keyword">goto</SPAN>&nbsp;<SPAN class="reference">failure</SPAN>;<BR></PRE></BLOCKQUOTE><P> since finite set operator return <CODE>OZ_FALSE</CODE> in case an inconsistency occured. </P><P> The propagator closes with calling <CODE>leave()</CODE> for both variables and returning <CODE>OZ_SLEEP</CODE> resp. <CODE>OZ_ENTAILED</CODE> depending on whether not all variables denote values or they do. </P><H3><A name="label5">1.6.3 The Header Function and Connecting to the Native Functor Interface</A></H3><P> The header function uses <CODE>OZ_Expect<SPAN class="keyword">::</SPAN>expectFSetVar</CODE> to check for a set variable. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="functionname">OZ_BI_define</SPAN>(connect,&nbsp;2,&nbsp;0)<BR>{<BR>&nbsp;&nbsp;OZ_EXPECTED_TYPE(OZ_EM_FSET<SPAN class="string">&quot;,&quot;</SPAN>OZ_EM_FD);<BR>&nbsp;&nbsp;<SPAN class="type">OZ_Expect</SPAN>&nbsp;<SPAN class="variablename">pe</SPAN>;<BR>&nbsp;&nbsp;OZ_EXPECT(pe,&nbsp;0,&nbsp;expectFSetVar);<BR>&nbsp;&nbsp;OZ_EXPECT(pe,&nbsp;1,&nbsp;expectIntVar);<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;pe.impose(<SPAN class="keyword">new</SPAN>&nbsp;<SPAN class="type">ConnectProp</SPAN>(OZ_in(0),&nbsp;OZ_in(1)));<BR>}<BR>OZ_BI_end<BR>&nbsp;<BR><SPAN class="type">OZ_PropagatorProfile</SPAN>&nbsp;<SPAN class="reference">ConnectProp</SPAN>::<SPAN class="variablename">profile</SPAN>;<BR></PRE></BLOCKQUOTE><P> The predefined macro <CODE>OZ_EM_FSET</CODE> is used to produce an appropriate error message in case an type exception has to be risen. </P><P> The C part of the native functor interface is given below. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="type">OZ_C_proc_interface</SPAN>&nbsp;*<SPAN class="functionname">oz_init_module</SPAN>(<SPAN class="type">void</SPAN>)<BR>{<BR>&nbsp;&nbsp;<SPAN class="keyword">static</SPAN>&nbsp;<SPAN class="type">OZ_C_proc_interface</SPAN>&nbsp;<SPAN class="variablename">i_table</SPAN>[]&nbsp;=&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="string">&quot;connect&quot;</SPAN>,&nbsp;2,&nbsp;0,&nbsp;connect},<BR>&nbsp;&nbsp;&nbsp;&nbsp;{0,&nbsp;0,&nbsp;0,&nbsp;0}<BR>&nbsp;&nbsp;};<BR>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;i_table;<BR>}<BR></PRE></BLOCKQUOTE><P> </P><H3><A name="label6">1.6.4 Testing the Propagator</A></H3><P>To make the propagator available on Oz side feed the following code: </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">declare</SPAN>&nbsp;<BR>Connect&nbsp;=&nbsp;{{New&nbsp;Module<SPAN class="keyword">.</SPAN>manager&nbsp;init}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link(url:&nbsp;<SPAN class="string">'sync.so{native}'</SPAN>&nbsp;$)}<SPAN class="keyword">.</SPAN>connect<BR>{Wait&nbsp;Connect}<BR>{Show&nbsp;Connect}<BR></PRE></BLOCKQUOTE><P> The variable <CODE>Connect</CODE> refers to the propagator. By feeding the code below line by line one can observe (e.&nbsp;g. using the Browser <A href="../browser/index.html">``The Oz Browser''</A>), how the propagator works. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">declare</SPAN>&nbsp;S&nbsp;=&nbsp;{FS<SPAN class="keyword">.</SPAN>var<SPAN class="keyword">.</SPAN>decl}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;=&nbsp;{FD<SPAN class="keyword">.</SPAN>decl}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">S&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;=&nbsp;&nbsp;<BR></SPAN>{Connect&nbsp;S&nbsp;I}&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;<SPAN class="comment">{{}..{0#134217726}}#1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0#134217726}<BR></SPAN>{FS<SPAN class="keyword">.</SPAN>exclude&nbsp;2&nbsp;S}&nbsp;%&nbsp;&nbsp;<SPAN class="comment">{{}..{0#1&nbsp;3#134217726}}#1&nbsp;&nbsp;{0#1&nbsp;3#34217726}<BR></SPAN>I&nbsp;<SPAN class="keyword">::</SPAN>&nbsp;1<SPAN class="keyword">#</SPAN>100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;<SPAN class="comment">{{}..{1&nbsp;3#100}}#1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{1&nbsp;3#100}<BR></SPAN>{FS<SPAN class="keyword">.</SPAN>exclude&nbsp;1&nbsp;S}&nbsp;%&nbsp;&nbsp;<SPAN class="comment">{{}..{3#100}}#1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{3#100}<BR></SPAN>I&nbsp;<SPAN class="keyword">&lt;:</SPAN>&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;<SPAN class="comment">{3}#1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<BR></SPAN></PRE></BLOCKQUOTE><P> The comments at the end of each line indicate the constraints after feeding that line. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node6.html#u_vectors">&lt;&lt; Prev</A></TD><TD><A href="node1.html">- Up -</A></TD><TD><A href="node8.html#u_advanced">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
