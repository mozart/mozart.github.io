<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>3.3 The Linear Programming Model</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node22.html#lp.tutorial.fd">&lt;&lt; Prev</A></TD><TD><A href="lp.html">- Up -</A></TD><TD><A href="node24.html#lp.tutorial.fdlp">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="lp.tutorial.lp"><H2><A name="lp.tutorial.lp">3.3 The Linear Programming Model</A></H2><P>Tackling a multi-knapsack problem with a LP solver amounts to implementing a branch &amp; bound solver to obtain integral solutions. The idea is to compute a continuous solution and to branch over the problem variables with continuous solutions. This is done until only integral problem variables are left. This is what the procedure <CODE>DistributeKnapSackLP</CODE> does. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">DistributeKnapSackLP</SPAN>&nbsp;Vs&nbsp;ObjFn&nbsp;Constraints&nbsp;MaxProfit}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DupVs&nbsp;=&nbsp;{DuplicateRIs&nbsp;Vs}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DupMaxProfit&nbsp;V&nbsp;DupV<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DupMaxProfit&nbsp;=&nbsp;{RI<SPAN class="keyword">.</SPAN>var<SPAN class="keyword">.</SPAN>bounds<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RI<SPAN class="keyword">.</SPAN>getLowerBound&nbsp;MaxProfit}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RI<SPAN class="keyword">.</SPAN>getUpperBound&nbsp;MaxProfit}}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{LP<SPAN class="keyword">.</SPAN>solve&nbsp;DupVs&nbsp;ObjFn&nbsp;Constraints&nbsp;DupMaxProfit&nbsp;optimal}<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V<SPAN class="keyword">#</SPAN>DupV&nbsp;=&nbsp;{SelectVar&nbsp;Vs<SPAN class="keyword">#</SPAN>DupVs}<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;{IsDet&nbsp;V}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DupMaxProfit&nbsp;=&nbsp;MaxProfit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DupVs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;Vs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RI<SPAN class="keyword">.</SPAN>lessEq&nbsp;{Ceil&nbsp;DupV}&nbsp;V}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RI<SPAN class="keyword">.</SPAN>lessEq&nbsp;V&nbsp;{Floor&nbsp;DupV}}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{DistributeKnapSackLP&nbsp;Vs&nbsp;ObjFn&nbsp;Constraints&nbsp;MaxProfit}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR></PRE></BLOCKQUOTE><P> It first duplicates the problem variables (note this is possible due to stability) and invokes the LP solver on them to compute a (possibly continuous) solution. Then it selects the first duplicated continuous problem variable <CODE>DupV</CODE> by <CODE>SelectVar</CODE> (see below). If continuous variables are left (see the <CODE><SPAN class="keyword">else</SPAN></CODE> branch of the <CODE><SPAN class="keyword">case</SPAN></CODE> statement), it creates two choices on the corresponding original problem variable <CODE>V</CODE>: <IMG alt="\lceil DupV \rceil \le V \vee V \le
\lfloor DupV \rfloor" src="latex116.png"> and calls <CODE>DistributeKnapSackLP</CODE> recursively. In case no continuous variables are left, an integral solution is found and the original problem variables are unified with duplicated ones. </P><P>For completeness sake the auxiliary functions <CODE>SelectVar</CODE> and <CODE>DuplicateRIs</CODE> are presented here. </P><TABLE align="center" class="dyptic" id="table.mks.lp.a.b"><TR valign="top"><TD><P></P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">SelectVar</SPAN>&nbsp;VsPair}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;VsPair<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;nil<SPAN class="keyword">#</SPAN>nil&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">unit#unit</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;(VH<SPAN class="keyword">|</SPAN>VT)<SPAN class="keyword">#</SPAN>(RVH<SPAN class="keyword">|</SPAN>RVT)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;<SPAN class="comment">check&nbsp;for&nbsp;integrality<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;RVH&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;{Round&nbsp;RVH}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{SelectVar&nbsp;VT<SPAN class="keyword">#</SPAN>RVT}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;VH<SPAN class="keyword">#</SPAN>RVH&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<BR></PRE></BLOCKQUOTE><P></P></TD><TD><P></P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">DuplicateRIs</SPAN>&nbsp;Vs}<BR>&nbsp;&nbsp;&nbsp;{Map&nbsp;Vs<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;V}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RI<SPAN class="keyword">.</SPAN>var<SPAN class="keyword">.</SPAN>bounds<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RI<SPAN class="keyword">.</SPAN>getLowerBound&nbsp;V}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RI<SPAN class="keyword">.</SPAN>getUpperBound&nbsp;V}}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR></PRE></BLOCKQUOTE><P></P></TD></TR></TABLE><P> </P><P>The procedure <CODE>KnapsackLP</CODE> return the script which creates the appropriate parameters for the LP solver and eventually calls <CODE>DistributeKnapSackLP</CODE>. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">KnapsackLP</SPAN>&nbsp;Problem}<BR>&nbsp;&nbsp;&nbsp;NumProducts&nbsp;=&nbsp;{Length&nbsp;Problem<SPAN class="keyword">.</SPAN>profit}<BR>&nbsp;&nbsp;&nbsp;Resources&nbsp;&nbsp;&nbsp;=&nbsp;Problem<SPAN class="keyword">.</SPAN>resources<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;Sol}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sol(maxprofit:&nbsp;MaxProfit&nbsp;=&nbsp;{RI<SPAN class="keyword">.</SPAN>var<SPAN class="keyword">.</SPAN>decl}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;products:&nbsp;Products&nbsp;=&nbsp;{MakeList&nbsp;NumProducts})<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;Sol<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjFn&nbsp;Constraints<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;Products&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;V}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RI<SPAN class="keyword">.</SPAN>var<SPAN class="keyword">.</SPAN>bounds&nbsp;0<SPAN class="keyword">.</SPAN>0&nbsp;RI<SPAN class="keyword">.</SPAN>sup&nbsp;V}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjFn&nbsp;=&nbsp;objfn(row:&nbsp;{Map&nbsp;Problem<SPAN class="keyword">.</SPAN>profit&nbsp;IntToFloat}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opt:&nbsp;max)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constraints&nbsp;=&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Map&nbsp;{Arity&nbsp;Resources}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;ResourceName}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resource&nbsp;=&nbsp;Resources<SPAN class="keyword">.</SPAN>ResourceName<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constr(row:&nbsp;{Map&nbsp;Resource<SPAN class="keyword">.</SPAN>npp&nbsp;IntToFloat}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;<SPAN class="string">'=&lt;'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rhs:&nbsp;{IntToFloat&nbsp;Resource<SPAN class="keyword">.</SPAN>ta})<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{DistributeKnapSackLP&nbsp;Products&nbsp;ObjFn&nbsp;Constraints<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MaxProfit}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR></PRE></BLOCKQUOTE><P> </P><P>Feeding </P><BLOCKQUOTE class="code"><CODE>{ExploreBest&nbsp;{KnapsackLP&nbsp;Problem}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;O&nbsp;N}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{RI<SPAN class="keyword">.</SPAN>lessEq&nbsp;O<SPAN class="keyword">.</SPAN>maxprofit<SPAN class="keyword">+</SPAN>1<SPAN class="keyword">.</SPAN>0&nbsp;N<SPAN class="keyword">.</SPAN>maxprofit}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> produces the following search tree. </P><DIV align="center"><IMG alt="" src="mks_lp_explorer.gif" id="mks_lp_explorer.pic"></DIV><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node22.html#lp.tutorial.fd">&lt;&lt; Prev</A></TD><TD><A href="lp.html">- Up -</A></TD><TD><A href="node24.html#lp.tutorial.fdlp">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
