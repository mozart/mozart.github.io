<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1.8 The class OZ_FSetConstraint</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node7.html#r_fs">&lt;&lt; Prev</A></TD><TD><A href="ip.html">- Up -</A></TD><TD><A href="node9.html#r_aux">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="r_fsc"><H2><A name="r_fsc">1.8 The class <CODE>OZ_FSetConstraint</CODE></A></H2><P>An <CODE>OZ_FSetConstraint</CODE> defines (among other things) a set of values that are definitely in (the greatest lower bound), a set of values that are definitely out of any set satisfying the Constraint; and a set of values who may or may not be in. These sets will be referred to as <CODE>IN</CODE>, <CODE>OUT</CODE>, and <CODE>UNKNOWN</CODE> sets in the descriptions below. </P><DIV id="r_fsc.constr"><H3><A name="r_fsc.constr">1.8.1 Constructor Member Functions</A></H3><P> </P><DL><DT class="default"><CODE>OZ_FSetConstraint</CODE> <A name="label160"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>default constructor</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_FSetConstraint(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Creates an <EM>uninitialised</EM> <CODE>OZ_FSetConstraint</CODE> entity. </P></DD><DT class="overloaded"><CODE>OZ_FSetConstraint</CODE> <A name="label161"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>overloaded constructor</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_FSetConstraint(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetValue</SPAN>&nbsp;&amp;<SPAN class="variablename">fs</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Creates a constraint where the <CODE>IN</CODE> set is <CODE>fs</CODE>. </P></DD><DT class="overloaded"><CODE>OZ_FSetConstraint</CODE> <A name="label162"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>overloaded constructor</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_FSetConstraint(<SPAN class="type">OZ_FSetState</SPAN>&nbsp;<SPAN class="variablename">state</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Creates a Finite Set Constraint with <CODE>IN</CODE> set of state <CODE>state</CODE>, and <CODE>OUT</CODE> its complement. </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>value of <CODE>state</CODE></P></TH><TH><P>constraint</P></TH></TR><TR valign="top"><TD><P><CODE>fs_empty</CODE></P></TD><TD><P>the empty set matches</P></TD></TR><TR valign="top"><TD><P><CODE>fs_full</CODE></P></TD><TD><P>the set <IMG alt="\{0, \ldots, OZ\_getFSetSup()\}" src="latex15.png"> matches.</P></TD></TR></TABLE><P> </P></DD><DT class="overloaded"><CODE>OZ_FSetConstraint</CODE> <A name="label163"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>overloaded constructor</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_FSetConstraint(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Copy-constructs a Finite Set Constraint from <CODE>fsc</CODE>. </P></DD></DL><P> </P></DIV><DIV id="r_fsc.init"><H3><A name="r_fsc.init">1.8.2 Initialization Member Functions</A></H3><P> </P><DL><DT class="member"><CODE>init</CODE> <A name="label164"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Initializes an empty constraint. </P></DD><DT class="member"><CODE>init</CODE> <A name="label165"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetValue</SPAN>&nbsp;&amp;<SPAN class="variablename">fs</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Initializes a constraint that is only matched by <CODE>fs</CODE>. </P></DD><DT class="member"><CODE>init</CODE> <A name="label166"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(OZ_FSetState);</CODE> </P></BLOCKQUOTE></DD><DD><P>Initializes a Finite Set Constraint with <CODE>IN</CODE> set of state <CODE>state</CODE>, and <CODE>OUT</CODE> its complement. </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>value of <CODE>state</CODE></P></TH><TH><P>constraint</P></TH></TR><TR valign="top"><TD><P><CODE>fs_empty</CODE></P></TD><TD><P>the empty set matches</P></TD></TR><TR valign="top"><TD><P><CODE>fs_full</CODE></P></TD><TD><P>the set <IMG alt="\{0, \ldots, OZ\_getFSetSup()\}" src="latex15.png"> matches.</P></TD></TR></TABLE><P> </P></DD></DL><P> </P></DIV><DIV id="r_fsc.refl"><H3><A name="r_fsc.refl">1.8.3 Reflection Member Functions</A></H3><P>These all access members of <CODE><SPAN class="keyword">*</SPAN>this</CODE>. </P><DL><DT class="constant"><CODE>getKnownIn</CODE> <A name="label167"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getKnownIn</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the cardinality of <CODE>IN</CODE>. </P></DD><DT class="constant"><CODE>getKnownNotIn</CODE> <A name="label168"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getKnownNotIn</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the cardinality of <CODE>OUT</CODE>. </P></DD><DT class="constant"><CODE>getUnknown</CODE> <A name="label169"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getUnknown</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the cardinality of <CODE>UNKNOWN</CODE>. </P></DD><DT class="constant"><CODE>getGlbSet</CODE> <A name="label170"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_FSetValue</SPAN>&nbsp;<SPAN class="functionname">getGlbSet</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>IN</CODE>. </P></DD><DT class="constant"><CODE>getLubSet</CODE> <A name="label171"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_FSetValue</SPAN>&nbsp;<SPAN class="functionname">getLubSet</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the set of values that <EM>may</EM> be in sets satisfying the constraint. </P></DD><DT class="constant"><CODE>getUnknownSet</CODE> <A name="label172"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_FSetValue</SPAN>&nbsp;<SPAN class="functionname">getUnknownSet</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>UNKNOWN</CODE>. </P></DD><DT class="constant"><CODE>getNotInSet</CODE> <A name="label173"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_FSetValue</SPAN>&nbsp;<SPAN class="functionname">getNotInSet</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OUT</CODE>. </P></DD><DT class="constant"><CODE>getGlbCard</CODE> <A name="label174"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getGlbCard</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the cardinality of <CODE>IN</CODE>. </P></DD><DT class="constant"><CODE>getLubCard</CODE> <A name="label175"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getLubCard</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the cardinality of the set of <EM>all</EM> values that are in <EM>some</EM> a set satisfying the constraint. </P></DD><DT class="constant"><CODE>getNotInCard</CODE> <A name="label176"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getNotInCard</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the cardinality of <CODE>OUT</CODE>. </P></DD><DT class="constant"><CODE>getUnknownCard</CODE> <A name="label177"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getUnknownCard</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the cardinality of <CODE>UNKNOWN</CODE>. </P></DD><DT class="constant"><CODE>iterators</CODE> <A name="label178"></A> <A name="label179"></A> <A name="label180"></A> <A name="label181"></A> <A name="label182"></A> <A name="label183"></A> <A name="label184"></A> <A name="label185"></A> <A name="label186"></A> <A name="label187"></A> <A name="label188"></A> <A name="label189"></A> <A name="label190"></A> <A name="label191"></A> <A name="label192"></A> <A name="label193"></A> <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getGlbMinElem</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getLubMinElem</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getNotInMinElem</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getUnknownMinElem</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getGlbMaxElem</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getLubMaxElem</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getNotInMaxElem</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getUnknownMaxElem</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getGlbNextSmallerElem</SPAN>(<SPAN class="type">int</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getLubNextSmallerElem</SPAN>(<SPAN class="type">int</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getNotInNextSmallerElem</SPAN>(<SPAN class="type">int</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getUnknownNextSmallerElem</SPAN>(<SPAN class="type">int</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getGlbNextLargerElem</SPAN>(<SPAN class="type">int</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getLubNextLargerElem</SPAN>(<SPAN class="type">int</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getNotInNextLargerElem</SPAN>(<SPAN class="type">int</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;<BR><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getUnknownNextLargerElem</SPAN>(<SPAN class="type">int</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>These functions allow to access and iterate over elements of several sets related to the constraint. </P><P></P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>name</P></TH><TH><P>function</P></TH></TR><TR valign="top"><TD><P><CODE>getMinElem</CODE></P></TD><TD><P>get the minimal element, -1 if empty</P></TD></TR><TR valign="top"><TD><P><CODE>getMaxElem</CODE></P></TD><TD><P>get the maximal element, -1 if empty</P></TD></TR><TR valign="top"><TD><P><CODE>getNextLargerElem(i)</CODE></P></TD><TD><P>get the next larger element above <CODE>i</CODE>, -1 if there is none</P></TD></TR><TR valign="top"><TD><P><CODE>getNextSmallerElem(i)</CODE></P></TD><TD><P>get the next smaller element below <CODE>i</CODE>, -1 if there is none</P></TD></TR></TABLE><P></P><P> </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>name</P></TH><TH><P>referred set</P></TH></TR><TR valign="top"><TD><P><CODE>glb</CODE></P></TD><TD><P>the set of values that are in <EM>all</EM> sets satisfying the constraint</P></TD></TR><TR valign="top"><TD><P><CODE>lub</CODE></P></TD><TD><P>the set of <EM>all</EM> values that are in <EM>some</EM> sets satisfying the constraint</P></TD></TR><TR valign="top"><TD><P><CODE>unknown</CODE></P></TD><TD><P>the set of values that are in <EM>some</EM>, but <EM>not all</EM> sets satisfying the constraint</P></TD></TR><TR valign="top"><TD><P><CODE>notIn</CODE></P></TD><TD><P>the set of values that are in <EM>no</EM> sets satisfying the constraint</P></TD></TR></TABLE><P> </P></DD><DT class="constant"><CODE>getCardMin</CODE> <A name="label194"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getCardMin</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;&nbsp;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the minimal allowed cardinality. </P></DD><DT class="constant"><CODE>getCardMax</CODE> <A name="label195"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getCardMax</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the maximal allowed cardinality (-1 means the constraint cannot be satisfied) </P></DD><DT class="constant"><CODE>getCardSize</CODE> <A name="label196"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">int</SPAN>&nbsp;<SPAN class="functionname">getCardSize</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the size of the interval between the minimal and maximal allowed cardinality. </P></DD><DT class="constant"><CODE>getKnownInList</CODE> <A name="label197"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">getKnownInList</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>IN</CODE> as a list. </P></DD><DT class="constant"><CODE>getKnownNotInList</CODE> <A name="label198"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">getKnownNotInList</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OUT</CODE> as a list. </P></DD><DT class="constant"><CODE>getUnknownList</CODE> <A name="label199"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">getUnknownList</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>UNKNOWN</CODE> as a list. </P></DD><DT class="constant"><CODE>getLubList</CODE> <A name="label200"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">getLubList</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the union of <CODE>IN</CODE> and <CODE>UNKNOWN</CODE> as a list. </P></DD><DT class="constant"><CODE>getCardTuple</CODE> <A name="label201"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Term</SPAN>&nbsp;<SPAN class="functionname">getCardTuple</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns a tuple consisting of integers giving the minimum and maximum allowed cardinality. </P></DD></DL><P> </P></DIV><DIV id="r_fsc.op"><H3><A name="r_fsc.op">1.8.4 Imposing Constraints</A></H3><P>Where an operator member Function returns an <CODE>OZ_Boolean</CODE>, it is to indicate whether constraint becomes unsatisfiable in the operation.</P><P> </P><DL><DT class="operator"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;=</CODE> <A name="label202"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>OZ_FSetConstraint&nbsp;&amp;<SPAN class="keyword">operator</SPAN>&nbsp;=&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P><CODE>fsc</CODE> gets assigned to <CODE>*<SPAN class="keyword">this</SPAN></CODE>. </P></DD><DT class="constant"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;-</CODE> <A name="label203"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">-</SPAN>&nbsp;(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>The complementary constraint is returned. </P></DD><DT class="operator"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;+=</CODE> <A name="label204"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN><SPAN class="functionname">+=</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">i</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P><CODE>i</CODE> is added to <CODE>*<SPAN class="keyword">this</SPAN>.IN</CODE>. </P></DD><DT class="operator"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;-=</CODE> <A name="label205"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN><SPAN class="functionname">-=</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">i</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P><CODE>i</CODE> is added to <CODE>*<SPAN class="keyword">this</SPAN>.OUT</CODE>. </P></DD><DT class="operator"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;&lt;&lt;=</CODE> <A name="label206"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">&lt;&lt;=</SPAN>&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P><CODE>fsc</CODE> is added to <CODE>*<SPAN class="keyword">this</SPAN></CODE>. </P></DD><DT class="operator"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;%</CODE> <A name="label207"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">%</SPAN>&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_True</CODE> if all values known to be in <CODE>*<SPAN class="keyword">this</SPAN></CODE> are known not to be in <CODE>fsc</CODE>, and the other way round. </P></DD><DT class="constant"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;&amp;</CODE> <A name="label208"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">&amp;</SPAN>&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the intersection of <CODE>*<SPAN class="keyword">this</SPAN></CODE> and <CODE>fsc</CODE>. </P></DD><DT class="constant"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;|</CODE> <A name="label209"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">|</SPAN>&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the union of <CODE>*<SPAN class="keyword">this</SPAN></CODE> and <CODE>fsc</CODE>. </P></DD><DT class="constant"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;-</CODE> <A name="label210"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">-</SPAN>&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the difference of <CODE>*<SPAN class="keyword">this</SPAN></CODE> and <CODE>fsc</CODE>. </P></DD><DT class="operator"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;&lt;=</CODE> <A name="label211"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">&lt;=</SPAN>&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_True</CODE> if <CODE>*<SPAN class="keyword">this</SPAN></CODE> has as least the elements excluded (in <CODE>OUT</CODE>) that are excluded by <CODE>fsc</CODE>. </P></DD><DT class="operator"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;&gt;=</CODE> <A name="label212"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">&gt;=</SPAN>&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;);</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_True</CODE> if <CODE>*<SPAN class="keyword">this</SPAN></CODE> has as least the elements included (in <CODE>IN</CODE>) that are included by <CODE>fsc</CODE>. </P></DD><DT class="operator"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;!=</CODE> <A name="label213"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">!=</SPAN>&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>The elements known to be in <CODE>fsc</CODE> are excluded from <CODE>*<SPAN class="keyword">this</SPAN></CODE> </P></DD><DT class="operator"><CODE><SPAN class="keyword">operator</SPAN>&nbsp;==</CODE> <A name="label214"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="keyword">operator</SPAN>&nbsp;<SPAN class="functionname">==</SPAN>&nbsp;(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fs</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_True</CODE> if <CODE>*<SPAN class="keyword">this</SPAN></CODE> is equivalent to <CODE>fsc</CODE>. </P></DD><DT class="member"><CODE>le</CODE> <A name="label215"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">le</SPAN>(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">i</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>All values above <CODE>i</CODE> are excluded from <CODE>*<SPAN class="keyword">this</SPAN></CODE>. </P></DD><DT class="operator"><CODE>ge</CODE> <A name="label216"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>operator member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">ge</SPAN>(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">int</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>All values below <CODE>i</CODE> are excluded from <CODE>*<SPAN class="keyword">this</SPAN></CODE>. </P></DD></DL><P> </P></DIV><DIV id="r_fsc.aux"><H3><A name="r_fsc.aux">1.8.5 Auxiliary Member Functions</A></H3><P> </P><DL><DT class="member"><CODE>putCard</CODE> <A name="label217"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">putCard</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">cardmin</SPAN>,&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">cardmax</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>The minimum and maximum allowed cardinality is set. </P></DD><DT class="constant"><CODE>isValue</CODE> <A name="label218"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isValue</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_True</CODE> if the constraint determines exactly one set. </P></DD><DT class="constant"><CODE>isIn</CODE> <A name="label219"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isIn</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">i</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_True</CODE> if <CODE>i</CODE> is known to be in <EM>every</EM>(!) set satisfying the constraint. </P></DD><DT class="constant"><CODE>isNotIn</CODE> <A name="label220"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isNotIn</SPAN>(<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">i</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_True</CODE> if <CODE>i</CODE> is in <EM>no</EM> set satisfying the constraint. </P></DD><DT class="constant"><CODE>isEmpty</CODE> <A name="label221"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isEmpty</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE>OZ_True</CODE> if <CODE>*<SPAN class="keyword">this</SPAN></CODE> is satisfied only by the empty set. </P></DD><DT class="constant"><CODE>isFull</CODE> <A name="label222"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isFull</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE><SPAN class="reference">true</SPAN></CODE> if <CODE>*<SPAN class="keyword">this</SPAN></CODE> can only be satisfied by the set containing all possible values (i.&nbsp;e. , <IMG alt="\{0, \ldots, OZ\_getFSetSup()\}" src="latex15.png">).</P><P></P></DD><DT class="constant"><CODE>isSubsumedBy</CODE> <A name="label223"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">OZ_Boolean</SPAN>&nbsp;<SPAN class="functionname">isSubsumedBy</SPAN>(<SPAN class="keyword">const</SPAN>&nbsp;<SPAN class="type">OZ_FSetConstraint</SPAN>&nbsp;&amp;<SPAN class="variablename">fsc</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE><SPAN class="reference">true</SPAN></CODE> if <CODE>*<SPAN class="keyword">this</SPAN></CODE> is subsumed by <CODE>fsc</CODE>. </P></DD><DT class="member"><CODE>copyExtension</CODE> <A name="label224"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">copyExtension</SPAN>(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This member function replaces the current extension of the set constraint representation by a copy of it. </P></DD><DT class="member"><CODE>disposeExtension</CODE> <A name="label225"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">void</SPAN>&nbsp;<SPAN class="functionname">disposeExtension</SPAN>(<SPAN class="type">void</SPAN>);</CODE> </P></BLOCKQUOTE></DD><DD><P>This member function frees the heap memory occupied by the extension of the set constraint. </P></DD><DT class="constant"><CODE>toString</CODE> <A name="label226"></A><SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>constant member function</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE><SPAN class="type">char</SPAN>&nbsp;*&nbsp;<SPAN class="functionname">toString</SPAN>(<SPAN class="type">void</SPAN>)&nbsp;<SPAN class="keyword">const</SPAN>;</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns a textual representation of the finite set constraint pointing to a static array of <CODE><SPAN class="type">char</SPAN></CODE>s. </P></DD></DL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node7.html#r_fs">&lt;&lt; Prev</A></TD><TD><A href="ip.html">- Up -</A></TD><TD><A href="node9.html#r_aux">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
