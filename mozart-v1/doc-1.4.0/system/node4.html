<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1.3 Option Specifications</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#section.application.parsingconventions">&lt;&lt; Prev</A></TD><TD><A href="node1.html">- Up -</A></TD></TR></TABLE><DIV id="section.application.specifications"><H2><A name="section.application.specifications">1.3 Option Specifications</A></H2><P> There are several ways to specify the way the arguments are parsed; we present them in order of increasing processing power. </P><H3><A name="label17">1.3.1 Plain</A></H3><DIV class="apropos"><P class="margin">Syntax Specification</P><P> The <CODE>plain</CODE> way of command line processing actually involves no processing at all. In CGI parsing, not even escaped characters are translated. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>spec</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>plain</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><DIV class="apropos"><P class="margin">Returned Result</P><P> For CGI scripts, the result consists of a list of pairs of strings (the name/value pairs), whereas for command lines, it consists of a list of strings. </P></DIV><H3><A name="label18">1.3.2 List</A></H3><DIV class="apropos"><P class="margin">Syntax Specification</P><P> The <CODE>list</CODE> way of processing command line arguments takes care of determining what is a command line option, whether it takes a value, how its value to be interpreted, etc. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>spec</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE>list(</CODE>[<CODE>mode:&nbsp;</CODE>&lt;<I>mode</I>&gt;] &lt;<I>option</I>&gt; ... &lt;<I>option</I>&gt;)</TD></TR></TABLE></BLOCKQUOTE><P> Using the <CODE>mode</CODE> specification, the command line parser can either be instructed to stop at the first non-option argument it encounters (<CODE>start</CODE>) or it can look for options on the whole command line (<CODE>anywhere</CODE>). The latter is the default if no <CODE>mode</CODE> is given. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>mode</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>start</CODE> | <CODE>anywhere</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><P> The integer fields of the option specification describe the individual options. An option must as least have an &lt;<I>option name</I>&gt;. Furthermore, it may either be an alias for another option (if <CODE>alias</CODE> is given) or it may be a <SPAN class="quasi">`real'</SPAN> option actually visible to the application. Aliases are never returned to the application; they are always replaced by the option they stand for. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>option</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>option name</I>&gt;<CODE>(</CODE>[<CODE>char:</CODE> &lt;<I>char or chars</I>&gt;] [<CODE>type:&nbsp;</CODE>&lt;<I>type</I>&gt;]<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>option name</I>&gt;<CODE>(</CODE>[<CODE>char:&nbsp;</CODE>&lt;<I>char or chars</I>&gt;] <CODE>alias:&nbsp;</CODE>&lt;<I>alias</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>option name</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> As mentioned in <A href="node3.html#section.application.cmdparsing">Section&nbsp;1.2.2</A>, options may be notated using single-character short forms. With the <CODE>char</CODE> specification one or several single-character short forms may be assigned to an option. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>char or chars</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>char</I>&gt; | <CODE>[</CODE>&lt;<I>char</I>&gt;<CODE>]</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><P> If no <CODE>type</CODE> is given, then the option does not take an argument. (Note that <CODE><SPAN class="keyword">true</SPAN></CODE> will be used as the associated value in this case.) Boolean options have a special status, as has already been described in <A href="node3.html#section.application.parsingconventions">Section&nbsp;1.2</A>. The remaining type specifications, however, require an additional argument. The <CODE>list(</CODE>&lt;<I>primary type</I>&gt;<CODE>)</CODE> annotation interprets its argument as a comma-separated list of elements of a specific type. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>type</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>bool</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>primary type</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>list(</CODE>&lt;<I>primary type</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><P> There are four supported basic types and a <SPAN class="quasi">`generic'</SPAN> type. Integer and float arguments have to be given in Oz concrete syntax (with the exception that the unary minus sign may be notated as&nbsp;<CODE><SPAN class="keyword">-</SPAN></CODE>); minimum and maximum values may also be specified. For arguments to be returned as atoms, a set of allowed values may be specified. Strings are returned as-is. </P><P> The generic type simply consists of a binary procedure with the signature <CODE>{P&nbsp;</CODE><CODE>+<I>S</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>}</CODE> which may arbitrarily transform the argument, given as a string. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>primary type</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>int(</CODE>[<CODE>min:&nbsp;</CODE>&lt;<I>int</I>&gt;] [<CODE>max:&nbsp;</CODE>&lt;<I>int</I>&gt;]<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>float(</CODE>[<CODE>min:&nbsp;</CODE>&lt;<I>float</I>&gt;] [<CODE>max:&nbsp;</CODE>&lt;<I>float</I>&gt;]<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>atom(</CODE>[&lt;<I>atom</I>&gt; ... &lt;<I>atom</I>&gt;]<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>string</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>procedure</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><P> Two different forms of alias are supported. Option name aliases simply state that this option name is equivalent to some other option name; the other option's argument description will be used for parsing this option as well. The second kind of alias states that this option is equivalent to another option used with the supplied value (or a combination of several options). In the latter case, the value will be transferred to the output without any additional transformations. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>alias</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>option name</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>option name</I>&gt;<CODE><SPAN class="keyword">#</SPAN></CODE>&lt;<I>value</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>[</CODE>&lt;<I>option name</I>&gt;<CODE><SPAN class="keyword">#</SPAN></CODE>&lt;<I>value</I>&gt;<CODE>]</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><DIV class="apropos"><P class="margin">Returned Result</P><P> The result of this processing step is a list of parsed options, interspersed with non-parsed arguments, a so-called &lt;<I>option list</I>&gt;. All option names in this list are the canonical (i.&nbsp;e., not aliased and unabbreviated) forms. The list respects the order in which the arguments were given. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>option list</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>[</CODE>&lt;<I>arg or option</I>&gt;<CODE>]</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>arg or option</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>option name</I>&gt;<CODE><SPAN class="keyword">#</SPAN></CODE>&lt;<I>value</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>string</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><HR><UL class="toc"><LI><A href="node5.html#section.application.list.examples">List Examples</A></LI></UL><HR><H3><A name="label19">1.3.3 Record</A></H3><DIV class="apropos"><P class="margin">Syntax Specification</P><P> The additional processing step involved in <CODE>record</CODE> kind specifications is that additional contextual conditions may be checked, and the result is returned in a different form. </P></DIV><P> Basically, the <CODE>record</CODE> specification is a strict extension of the <CODE>list</CODE> specification. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>spec</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE>record(</CODE>[<CODE>mode:&nbsp;</CODE>&lt;<I>mode</I>&gt;] &lt;<I>option</I>&gt; ... &lt;<I>option</I>&gt;)</TD></TR></TABLE></BLOCKQUOTE><P> The specifications for <SPAN class="quasi">`real'</SPAN> (i.&nbsp;e., non-alias) options take some more information into consideration, namely how often the option may appear and how several occurrences combine (&lt;<I>occ</I>&gt;), and whether it is a required option (<CODE>optional</CODE>; the default is <CODE><SPAN class="keyword">true</SPAN></CODE>) or whether it takes a default value (<CODE>default</CODE>), which it does not by default. At most one of <CODE>default</CODE> and <CODE>optional</CODE> may be given. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>option</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD>&lt;<I>option name</I>&gt;<CODE>(</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;1:&nbsp;</CODE>&lt;<I>occ</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;</CODE>[<CODE>char:&nbsp;</CODE>&lt;<I>char or chars</I>&gt;]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;</CODE>[<CODE>type:&nbsp;</CODE>&lt;<I>type</I>&gt;]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;</CODE>[<CODE>default:&nbsp;</CODE>&lt;<I>value</I>&gt; | <CODE>optional:&nbsp;</CODE>&lt;<I>bool</I>&gt;]<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P> An option may be allowed to occur at most once (<CODE>single</CODE>) or any number of times. In the latter case, the result may either respect all occurrences (<CODE>multiple</CODE>), or it may ignore all but the first (<CODE>leftmost</CODE>) or last (<CODE>rightmost</CODE>) occurrence. When all occurrences are respected, a list of them (preserving the order) is returned. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>occ</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>single</CODE> | <CODE>multiple</CODE> | <CODE>leftmost</CODE> | <CODE>rightmost</CODE> | <CODE>accumulate(P)</CODE></TD></TR></TABLE></BLOCKQUOTE><P> When <CODE>accumulate(P)</CODE> is specified, procedure <CODE>P</CODE> is called for each occurrence of the option. It takes two arguments: the option (as an atom) and the parsed value. This can be used to accumulate multiple occurrences of related options into one list. See, for example, options <CODE><SPAN class="keyword">--</SPAN>include</CODE> and <CODE><SPAN class="keyword">--</SPAN>exclude</CODE> of <A href="../tools/node7.html#chapter.linker">the Oz linker <CODE>ozl</CODE></A>. </P><DIV class="apropos"><P class="margin">Returned Result</P><P> The result consists of an option record. All options which had an explicit &lt;<I>occ</I>&gt; given in their specification are moved from the option list into this record, the feature being the option name, the subtree the associated value. Defaulted options that have not been overridden by the argument list appear in this record with their default value. Only optional options may be missing from this record, namely when they have not been specified in the argument list. Those options which did not have an explicit &lt;<I>occ</I>&gt; given in their specification are found, interspersed with non-parsed arguments, in an option list under feature&nbsp;<CODE>1</CODE> of the option record. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>option record</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>optRec(1:&nbsp;</CODE>&lt;<I>option list</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>option name</I>&gt;<CODE>:&nbsp;</CODE>&lt;<I>value</I>&gt; ...</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>option name</I>&gt;<CODE>:&nbsp;</CODE>&lt;<I>value</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><HR><UL class="toc"><LI><A href="node6.html#section.application.record.examples">Record Examples</A></LI></UL></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#section.application.parsingconventions">&lt;&lt; Prev</A></TD><TD><A href="node1.html">- Up -</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A>, <A href="http://www.ps.uni-sb.de/~homik/">Martin&nbsp;Homik</A>, <A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;MÃ¼ller</A>, <A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
