<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>4.2 General Purpose Search Engines</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node10.html#vanillasearch">&lt;&lt; Prev</A></TD><TD><A href="node9.html">- Up -</A></TD><TD><A href="node12.html#sec.search.object">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="generalsearch"><H2><A name="generalsearch">4.2 General Purpose Search Engines</A></H2><P>This section describes the search engines found in the module <CODE>Search</CODE>. All of these engines support recomputation, the possibility to stop their execution and various kinds of output. </P><P class="margin">Recomputation.</P><P> Scripts which create a large number of variables or propagators or scripts for which the search tree is very deep might use too much memory to be feasible. The search engines described in this section feature support for so-called <A name="label48"></A><EM>recomputation</EM>. Recomputation reduces the space requirements for these scripts in that it trades space for time. </P><P>Search engines that do not use recomputation, create a copy of a computation space in each distribution step. This copy is needed such that the engine is able to follow more than one alternative of a choice. </P><P>If, for instance, a single solution search engine finds a solution after 200 distribution steps (i.&nbsp;e. the search tree has a depth of 201), 200 copies are created and stored by the engine. </P><P>Recomputation reduces the number of copies needed: Instead of creating a copy in each distribution step, only every <IMG alt="n" src="latex8.png">-th distribution step a copy is created. A space for which no copy has been created can be recomputed from a copy located higher above in the search tree by recomputing some distribution steps. In the worst case, <IMG alt="n-1" src="latex9.png"> distribution steps have to be recomputed. The parameter <IMG alt="n" src="latex8.png"> is the so-called <A name="label49"></A><EM>recomputation distance</EM>. A recomputation distance of <IMG alt="n" src="latex8.png"> means that the <EM>space</EM> needed <EM>decreases</EM> by a factor of <IMG alt="n" src="latex8.png"> and that the <EM>time</EM> needed <EM>increases</EM> by a factor of <IMG alt="n" src="latex8.png">. </P><P>The following search engines take the recomputation distance as an argument (it is denoted by <I>RcdI</I>). A value of <CODE>2</CODE> for <I>RcdI</I> means that only each second distribution step a copy is created. The value <CODE>1</CODE> for <I>RcdI</I> means that in each distrbution step a copy is created, that is no recomputation is used. Values less than <CODE>1</CODE> mean that none but an initial copy is created: from this initial copy all other spaces are recomputed. </P><P>Recomputation can also <EM>reduce</EM> both <EM>space and time</EM> requirements. Searching a single solution of a script which features a good heuristic (i.&nbsp;e. there are only very few failures) creates copies which are not used. Recomputation avoids this, resulting in improvement with respect to both space and time. </P><DIV class="danger"><P class="margin"><IMG align="top" alt="Danger" src="danger.gif"></P><P> Recomputation requires that the distribution strategy used in the script be <EM>deterministic</EM>. Deterministic means that the created choices and their order are identical in repeated runs of the script. This is true for all strategies in the finite domain module, but for example not for strategies with randomized components. </P></DIV><P class="margin">Killing the Engine.</P><P> All engines described in this section return a nullary procedure, which is denoted by <CODE>+<I>KillP</I></CODE>. Applying this procedure kills the search engine. </P><P>A search engine, which can be stopped and resumed is described in Section&nbsp;<A href="node12.html#sec.search.object">Section&nbsp;4.3</A>. </P><P class="margin">Different Types of Output.</P><P> Each of the engines is provided with three different types of output. The first kind returns a list of solutions as the engines in <A href="node10.html#vanillasearch">Section&nbsp;4.1</A>. The second kind returns a list of unary procedures. Applying one of these procedures merges a copy of the succeeded space and gives reference to its root variable variable by the actual argument of the procedure application. The third kind returns a list of succeeded spaces. </P><H3><A name="label50">4.2.1 Single Solution Search</A></H3><P><A name="label52"></A> </P><DL><DT><CODE>one<SPAN class="keyword">.</SPAN>depth</CODE> <A name="label54"></A></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depth&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>returns a singleton list containing the first solution of the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by depth-first search. If no solution exists, <CODE>nil</CODE> is returned. </P><P>For instance, the procedure <CODE>Search<SPAN class="keyword">.</SPAN>base<SPAN class="keyword">.</SPAN>one</CODE> (see <A href="node10.html#vanillasearch">Section&nbsp;4.1</A>) can be defined as: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Search.base.one</SPAN>&nbsp;ScriptP}<BR>&nbsp;&nbsp;&nbsp;{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depth&nbsp;ScriptP&nbsp;1&nbsp;_}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Suppose that <CODE>Script</CODE> is a script for which search does not terminate because it keeps on creating choices forever. It could look like the following: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Script</SPAN>&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;</CODE>&middot;&middot;&middot;<CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;{Script&nbsp;X}&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;{Script&nbsp;X}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> If <CODE>Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depth</CODE> is applied to this particular script by </P><BLOCKQUOTE class="code"><CODE>Solutions={Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depth&nbsp;Script&nbsp;1&nbsp;KillP}</CODE></BLOCKQUOTE><P> the search engine can be killed by applying <CODE>KillP</CODE> as follows: </P><BLOCKQUOTE class="code"><CODE>{KillP}</CODE></BLOCKQUOTE><P> </P><P>Note that a script which keeps on computing forever even without search (i.&nbsp;e., because it contains an infinite recursion or loop) can not be killed. </P></DD><DT><CODE>one<SPAN class="keyword">.</SPAN>depthS</CODE> <A name="label55"></A></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depthS&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Spaces</I></CODE><CODE>}</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>returns a singleton list containing the first succeeded space for the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by depth-first search. If no solution exists, <CODE>nil</CODE> is returned. </P></DD><DT><CODE>one<SPAN class="keyword">.</SPAN>depthP</CODE> <A name="label56"></A></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depthP&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ps</I></CODE><CODE>}</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Similar to <CODE>Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depthS</CODE>, but returns a list of unary procedures as output. </P><P><CODE>Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depthP</CODE> can be defined using <CODE>Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depthS</CODE> as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Search.one.depthP</SPAN>&nbsp;Script&nbsp;RcdI&nbsp;?KillP}<BR>&nbsp;&nbsp;&nbsp;{Map&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>depthS&nbsp;Script&nbsp;RcdI&nbsp;?KillP}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;SuccSpace}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;Root}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Space<SPAN class="keyword">.</SPAN>merge&nbsp;SuccSpace&nbsp;Root}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DD><DT><CODE>one<SPAN class="keyword">.</SPAN>bound</CODE> <A name="label58"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>bound&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>BoundI</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>one<SPAN class="keyword">.</SPAN>boundS</CODE> <A name="label60"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>boundS&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>BoundI</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Spaces</I></CODE></P></BLOCKQUOTE></DD><DT><CODE>one<SPAN class="keyword">.</SPAN>boundP</CODE> <A name="label62"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>boundP&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>BoundI</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ps</I></CODE></P></BLOCKQUOTE></DD><DD><P>returns a singleton list containing the first solution of the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by depth-first search, where the depth of the search tree explored is less than or equal to <CODE>+<I>BoundI</I></CODE>. </P><P>If there is no solution in a depth less than or equal to <CODE>+<I>BoundI</I></CODE>, but there might be solutions deeper in the tree, <CODE>cut</CODE> is returned. In case the entire search tree has a depth less than <CODE>+<I>BoundI</I></CODE> and no solution exists, <CODE>nil</CODE> is returned. </P><P>Otherwise the output is a singleton list containing the solution (<CODE>Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>bound</CODE>), a succeeded space (<CODE>Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>boundS</CODE>), or a procedure (<CODE>Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>boundP</CODE>). </P><P>For instance </P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>bound&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<SPAN class="keyword">fail</SPAN>&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;<SPAN class="keyword">fail</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;1&nbsp;_}</CODE></BLOCKQUOTE><P> returns the output <CODE>nil</CODE>, whereas </P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>bound&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<SPAN class="keyword">fail</SPAN>&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;<SPAN class="keyword">fail</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;<SPAN class="keyword">fail</SPAN>&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;<SPAN class="keyword">fail</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;1&nbsp;_}</CODE></BLOCKQUOTE><P> returns the output <CODE>cut</CODE>. </P></DD><DT><CODE>one<SPAN class="keyword">.</SPAN>iter</CODE> <A name="label64"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>iter&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>one<SPAN class="keyword">.</SPAN>iterS</CODE> <A name="label66"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>iterS&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Spaces</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>one<SPAN class="keyword">.</SPAN>iterP</CODE> <A name="label68"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>iterP&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ps</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>returns a singleton list containing the first solution of the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by iterative deepening depth-first search. If no solution exists, <CODE>nil</CODE> is returned.</P><P>Iterative deepening applies <CODE>Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>bound</CODE> to <CODE>+<I>ScriptP</I></CODE> with depth-bounds 1, 2, 4, 8, ... until either a solution is found or <CODE>Search<SPAN class="keyword">.</SPAN>one<SPAN class="keyword">.</SPAN>bound</CODE> returns <CODE>nil</CODE>.</P></DD></DL><P></P><H3><A name="label69">4.2.2 All Solution Search</A></H3><P></P><DL><DT><CODE>all</CODE> <A name="label71"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>all&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>allS</CODE> <A name="label73"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>allS&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Spaces</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>allP</CODE> <A name="label75"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>allP&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ps</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>returns the list of all solutions of the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by depth-first search. </P><P>The output is a list of solutions (<CODE>Search<SPAN class="keyword">.</SPAN>all</CODE>), a list of succeeded spaces (<CODE>Search<SPAN class="keyword">.</SPAN>allS</CODE>), or a list of procedures (<CODE>Search<SPAN class="keyword">.</SPAN>allP</CODE>).</P></DD></DL><P></P><DIV id="section.best.solution.search"><H3><A name="section.best.solution.search">4.2.3 Best Solution Search</A></H3><P><A name="label77"></A> </P><DL><DT><CODE>best<SPAN class="keyword">.</SPAN>bab</CODE> <A name="label79"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>best<SPAN class="keyword">.</SPAN>bab&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>OrderP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>best<SPAN class="keyword">.</SPAN>babS</CODE> <A name="label81"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>best<SPAN class="keyword">.</SPAN>babS&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>OrderP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Spaces</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>best<SPAN class="keyword">.</SPAN>babP</CODE> <A name="label83"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>best<SPAN class="keyword">.</SPAN>babP&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>OrderP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ps</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>returns a singleton list containing the best solution with respect to the order <CODE>+<I>OrderP</I></CODE> (a binary procedure) of the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by branch and bound search. If no solution does exist, <CODE>nil</CODE> is returned.</P><P>The branch and bound strategy works as follows. When a solution is found, all the remaining alternatives are constrained to be <EM>better</EM> with respect to the order <CODE>+<I>OrderP</I></CODE>. The binary procedure <CODE>+<I>OrderP</I></CODE> is applied with its first argument being the previous solution, and its second argument the root variable of a space for one of the remaining alternatives. </P></DD><DT><CODE>best<SPAN class="keyword">.</SPAN>restart</CODE> <A name="label85"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>best<SPAN class="keyword">.</SPAN>restart&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>OrderP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>best<SPAN class="keyword">.</SPAN>restartS</CODE> <A name="label87"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>best<SPAN class="keyword">.</SPAN>restartS&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>OrderP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Spaces</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>best<SPAN class="keyword">.</SPAN>restartP</CODE> <A name="label89"></A></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Search<SPAN class="keyword">.</SPAN>best<SPAN class="keyword">.</SPAN>restartP&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>OrderP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RcdI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KillP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ps</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>returns a singleton list containing the best solution with respect to the order <CODE>+<I>OrderP</I></CODE> (a binary procedure) of the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by branch and bound search. If no solution does exist, <CODE>nil</CODE> is returned.</P><P>The restart strategy works as follows. When a solution is found, search is restarted for <CODE>+<I>ScriptP</I></CODE> with the additional constraint stating that the solution must be better with respect to the order <CODE>+<I>OrderP</I></CODE>. The binary procedure <CODE>+<I>OrderP</I></CODE> is applied with the previous solution as first argument, and the root variable of the script <CODE>+<I>ScriptP</I></CODE> as its second argument.</P></DD></DL><P></P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node10.html#vanillasearch">&lt;&lt; Prev</A></TD><TD><A href="node9.html">- Up -</A></TD><TD><A href="node12.html#sec.search.object">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A>, <A href="http://www.ps.uni-sb.de/~homik/">Martin&nbsp;Homik</A>, <A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A>, <A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
