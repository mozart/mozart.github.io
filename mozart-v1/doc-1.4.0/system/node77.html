<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>24 Error Formatting: Error</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node58.html#chapter.property">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node78.html#chapter.errorformatters">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.error"><H1><A name="chapter.error">24 Error Formatting: <CODE>Error</CODE></A></H1><P> The <CODE>Error</CODE> module is concerned with various tasks related to error reporting. This encompasses the following: </P><UL><LI><P>Reporting errors as represented by data-structures called <A name="label840"></A><EM>error messages</EM>. </P></LI><LI><P>Constructing error messages from run-time error conditions in the form of exceptions. </P></LI><LI><P>Registering error formatters in the <A name="label841"></A><EM>error registry</EM>. </P></LI></UL><P> At boot time, the system installs a default exception handler processing all uncaught exceptions. This involves printing out the exception with the mechanisms mentioned above and executing a handler as given by the properties <CODE><SPAN class="string">'errors.toplevel'</SPAN></CODE> and <CODE><SPAN class="string">'errors.subordinate'</SPAN></CODE>, which see. </P><H2><A name="label842">24.1 Data Structures</A></H2><P> The central data structure used in this module is the error message. The general format is as follows: </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>message</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>message label</I>&gt;<CODE>(</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;</CODE>[<CODE>kind:&nbsp;</CODE>&lt;<I>extended virtual string</I>&gt;] </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% origin subsystem or component</I></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;</CODE>[<CODE>msg:&nbsp;</CODE>&lt;<I>extended virtual string</I>&gt;] </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% main message</I></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;</CODE>[<CODE>items:&nbsp;[</CODE>&lt;<I>line</I>&gt;<CODE>]</CODE>] </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% additional information</I></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;</CODE>...<CODE>)</CODE> </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% internal fields</I></TD></TR></TABLE></BLOCKQUOTE><P> All fields of the record are optional and specify information as indicated by the comments (wherever applicable). It is recommended that both <CODE>kind</CODE> and <CODE>msg</CODE> start with a lower-case letter and do not end in a period. </P><P> The label of the record is currently ignored by the procedures from the <CODE>Error</CODE> module, but other system modules expect it to be either <CODE>error</CODE> or <CODE>warn</CODE>, depending on the severity of the condition. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>message label</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>error</CODE> | <CODE>warn</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><P> The <CODE>items</CODE> describe a sequence of lines meant to give additional hints about the error, but one should make sure that the error message is comprehensible without this information. All keys should start with a capital letter. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>line</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>hint(</CODE>[<CODE>l:&nbsp;</CODE>&lt;<I>extended virtual string</I>&gt;]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>[<CODE>m:&nbsp;</CODE>&lt;<I>extended virtual string</I>&gt;]) </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% key/value pair</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>coordinates</I>&gt; </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% source code error relates to</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>line(</CODE>&lt;<I>extended virtual string</I>&gt;<CODE>)</CODE> </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% full line of text</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">unit</SPAN></CODE> </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% empty line (separator)</I></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>coordinates</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>pos(</CODE>&lt;<I>atom</I>&gt; </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% file name; <CODE><SPAN class="string">''</SPAN></CODE> if not known</I></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>int</I>&gt; </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% line number; required</I></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>)</CODE> </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% column number; <CODE><SPAN class="keyword">~</SPAN>1</CODE> if not known</I></TD></TR></TABLE></BLOCKQUOTE><P> </P><P> An &lt;<I>extended virtual string</I>&gt; is a virtual string that may contain, for convenience, embedded records with special interpretation. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>extended virtual string</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom</I>&gt; | &lt;<I>int</I>&gt; | &lt;<I>float</I>&gt; | &lt;<I>string</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="string">'#'</SPAN>(</CODE>&lt;<I>extended virtual string</I>&gt; ... &lt;<I>extended virtual string</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>oz(</CODE>&lt;<I>value</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>pn(</CODE>&lt;<I>atom</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>coordinates</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>apply(</CODE>&lt;<I>procedure or print name</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>value</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>list([</CODE>&lt;<I>value</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>extended virtual string</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>procedure or print name</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>procedure</I>&gt; | &lt;<I>atom</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> The embedded records are translated to virtual strings as follows: </P><DL><DT><CODE>oz(</CODE><CODE><I>X</I></CODE><CODE>)</CODE></DT><DD><P>transforms <CODE><I>X</I></CODE> using <CODE>Value<SPAN class="keyword">.</SPAN>toVirtualString</CODE>, using the print depth and width given by the system properties <CODE><SPAN class="string">'errors.depth'</SPAN></CODE> and <CODE><SPAN class="string">'errors.width'</SPAN></CODE>, respectively. </P></DD><DT><CODE>pn(</CODE><CODE>+<I>A</I></CODE><CODE>)</CODE></DT><DD><P>considers <CODE><I>A</I></CODE> to be a variable print name, i.&nbsp;e., escapes non-printable characters according to variable concrete syntax if <CODE><I>A</I></CODE> is enclosed in backquotes. </P></DD><DT><CODE>pos(</CODE><CODE>+<I>A</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>)</CODE></DT><DD><P>prints out source coordinates, e.&nbsp;g., <CODE>in&nbsp;file&nbsp;</CODE><CODE><I>A</I></CODE><CODE>,&nbsp;line&nbsp;</CODE><CODE><I>I</I></CODE><CODE>,&nbsp;column&nbsp;</CODE><CODE><I>I</I></CODE> with the unspecified parts omitted. </P></DD><DT><CODE>apply(</CODE><CODE>+<I>X</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Ys</I></CODE><CODE>)</CODE></DT><DD><P>represents an Oz application of <CODE><I>X</I></CODE> to <CODE><I>Ys</I></CODE>. Output uses the usual brace notation. </P></DD><DT><CODE>list(</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>ExtendedVirtualString</I></CODE><CODE>)</CODE></DT><DD><P>outputs the values in <CODE><I>Xs</I></CODE> as if each was wrapped inside <CODE>oz(</CODE>...<CODE>)</CODE>, inserting <CODE><I>ExtendedVirtualString</I></CODE> between every pair of elements. </P></DD></DL><P> </P><H2><A name="label843">24.2 The Error Registry</A></H2><P> The <A name="label844"></A><EM>error registry</EM> has the purpose of storing so-called <A name="label845"></A><EM>error formatters</EM> under specific keys of type ``literal''. An error formatter&nbsp;<I>P</I> is a procedure with the signature </P><BLOCKQUOTE class="code"><CODE>{</CODE><I>P</I><CODE>&nbsp;</CODE><CODE>+<I>ExceptionR</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>MessageR</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> <I>P</I>&nbsp;must be capable of processing any exception having as label any of the keys under which <I>P</I> has been entered into the error registry and must return a &lt;<I>message</I>&gt; as defined above describing the condition. In the case of error or system exceptions, only the record found in the dispatch field of the exception is handed to the formatter. </P><P> Error formatters may be invoked by the default exception handler installed at boot time. Possibly dealing with serious conditions, formatters are required to be robust. In particular, the handler flags the thread executing the formatter to be <A name="label846"></A><EM>non-blocking</EM>, i.&nbsp;e., if it ever blocks on a logic variable, an exception is raised in this thread. This increases chances of any message being output at all. Note that it is allowed to block on futures though and that this flag is not inherited by any created child thread. </P><H2><A name="label847">24.3 Example Error Formatter</A></H2><P> The following piece of code illustrates how an error formatter might be registered and how it could behave. Assume a system component called <CODE>compiler</CODE>, which is given ``queries'' to process. If any query is ill-typed, an exception is raised, containing the query, the number of the ill-typed argument, and the expected argument type. Furthermore, an <CODE>internal</CODE> exception is raised when an internal programming assertion is violated. For robustness, an <CODE><SPAN class="keyword">else</SPAN></CODE> case is included to handle any other exceptions. The formatter simply prints out the exception record, since this might help more than no output at all. </P><BLOCKQUOTE class="code"><CODE>{Error<SPAN class="keyword">.</SPAN>registerFormatter&nbsp;compiler<BR>&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;E}<BR>&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;=&nbsp;<SPAN class="string">'compiler&nbsp;engine&nbsp;error'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;BugReport&nbsp;=&nbsp;<SPAN class="string">'please&nbsp;send&nbsp;a&nbsp;bug&nbsp;report&nbsp;to&nbsp;mozart-bugs@ps.uni-sb.de'</SPAN>&nbsp;<BR>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;E&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;compiler(internal&nbsp;X)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(kind:&nbsp;T<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg:&nbsp;<SPAN class="string">'Internal&nbsp;compiler&nbsp;error'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items:&nbsp;[hint(l:&nbsp;<SPAN class="string">'Additional&nbsp;information'</SPAN>&nbsp;m:&nbsp;oz(X))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line(BugReport)])<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">elseof</SPAN>&nbsp;compiler(invalidQuery&nbsp;M&nbsp;I&nbsp;A)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(kind:&nbsp;T<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg:&nbsp;<SPAN class="string">'Ill-typed&nbsp;query&nbsp;argument'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items:&nbsp;[hint(l:&nbsp;<SPAN class="string">'Query'</SPAN>&nbsp;m:&nbsp;oz(M))<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hint(l:&nbsp;<SPAN class="string">'At&nbsp;argument'</SPAN>&nbsp;m:&nbsp;I)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hint(l:&nbsp;<SPAN class="string">'Expected&nbsp;type'</SPAN>&nbsp;m:&nbsp;A)])<BR>&nbsp;&nbsp;&nbsp;&nbsp;</CODE>...<CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error(kind:&nbsp;T<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items:&nbsp;[line(oz(E))])<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> </P><H2><A name="label848">24.4 The Module</A></H2><P> </P><DL><DT><CODE>exceptionToMessage</CODE> <A name="label850"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Error<SPAN class="keyword">.</SPAN>exceptionToMessage&nbsp;</CODE><CODE>+<I>Exception</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Message</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>constructs a &lt;<I>message</I>&gt; from an exception, using the formatters defined in the error registry or a generic formatter if none is defined for the exception. The message returned by the formatter is enriched with additional fields copied from the exception. </P></DD><DT><CODE>messageToVirtualString</CODE> <A name="label852"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Error<SPAN class="keyword">.</SPAN>messageToVirtualString&nbsp;</CODE><CODE>+<I>Message</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>V</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>converts a &lt;<I>message</I>&gt; to a virtual string using the standard layout. This can span several lines and includes the final newline. </P></DD><DT><CODE>extendedVSToVS</CODE> <A name="label854"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Error<SPAN class="keyword">.</SPAN>extendedVSToVS&nbsp;</CODE><CODE>+<I>ExtendedVirtualString</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>V</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>converts an &lt;<I>extended virtual string</I>&gt; to a &lt;<I>virtual string</I>&gt;. </P></DD><DT><CODE>printException</CODE> <A name="label856"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Error<SPAN class="keyword">.</SPAN>printException&nbsp;</CODE><CODE>+<I>Exception</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>converts an exception to a message and this to a virtual string, printing the result on standard error (using <CODE>System<SPAN class="keyword">.</SPAN>printError</CODE>). </P></DD><DT><CODE>registerFormatter</CODE> <A name="label858"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Error<SPAN class="keyword">.</SPAN>registerFormatter&nbsp;</CODE><CODE>+<I>L</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>enters a formatter for exceptions with label&nbsp;<CODE><I>L</I></CODE> into the error registry, quietly replacing a possibly existing formatter for&nbsp;<CODE><I>L</I></CODE>. </P></DD></DL><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node58.html#chapter.property">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node78.html#chapter.errorformatters">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A>, <A href="http://www.ps.uni-sb.de/~homik/">Martin&nbsp;Homik</A>, <A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A>, <A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
