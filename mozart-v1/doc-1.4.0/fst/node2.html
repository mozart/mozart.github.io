<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2 The Steiner Problem</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#fset.tutorial.intro">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#fset.examples.hamming">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="fset.examples.steiner"><H1><A name="fset.examples.steiner">2 The Steiner Problem</A></H1><P class="margin">Problem Specification</P><P> The ternary Steiner problem of order <IMG alt="n" src="latex30.png"> asks for <IMG alt="n(n-1)/6" src="latex31.png"> sets <IMG alt="s_i
\subset \{1,\ldots,n\}" src="latex32.png"> with cardinality 3 such that every two of them share at most one element. The mathematical properties of the problem require that <IMG alt="n \bmod 6" src="latex33.png"> has to be either 1 or 3 <A href="bib.html#lindnerrosa:80">[LR80]</A>. </P><P class="margin">Model</P><P> We create a list <CODE>Ss</CODE> of <IMG alt="n(n-1)/6" src="latex31.png"> set variables and constrain every set to have a cardinality of 3 and to have an upper bound of <IMG alt="\{1,\ldots,n\}" src="latex34.png">. Further we require that the cardinality of the intersection of every two distinct sets in <CODE>Ss</CODE> must not exceed 1. </P><P class="margin">Distribution Strategy</P><P> Distribution simply takes the sets as they occur in <CODE>Ss</CODE> and adds resp. removes elements from them starting from the smallest element. </P><P class="margin">Solver</P><P> The solver is created by a function <CODE>Steiner</CODE> that takes the order of the Steiner problem as argument and checks if it is a valid order. In case it is valid it returns the actual solver with the list of solution sets as formal argument. </P><P>First, the list <CODE>Ss</CODE> is created and its elements' upper bounds and cardinalities are appropriately constrained. The nested loops built with <CODE>ForAllTail</CODE> and <CODE>ForAll</CODE> impose the constraint that every two sets share at most one element by stating that the cardinality of the intersection of two sets is in <IMG alt="\{0,1\}" src="latex35.png">. Distribution is straightforward and uses the provided library abstraction <CODE>FS<SPAN class="keyword">.</SPAN>distribute</CODE> for naive distribution.. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Steiner</SPAN>&nbsp;N}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp;<SPAN class="keyword">mod</SPAN>&nbsp;6&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;1&nbsp;<SPAN class="keyword">orelse</SPAN>&nbsp;N&nbsp;<SPAN class="keyword">mod</SPAN>&nbsp;6&nbsp;<SPAN class="keyword">==</SPAN>&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;Ss}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{FS<SPAN class="keyword">.</SPAN>var<SPAN class="keyword">.</SPAN>list<SPAN class="keyword">.</SPAN>upperBound&nbsp;(N<SPAN class="keyword">*</SPAN>(N<SPAN class="keyword">-</SPAN>1))&nbsp;<SPAN class="keyword">div</SPAN>&nbsp;6&nbsp;[1<SPAN class="keyword">#</SPAN>N]&nbsp;Ss}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;Ss&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;S}&nbsp;{FS<SPAN class="keyword">.</SPAN>card&nbsp;S&nbsp;3}&nbsp;<SPAN class="keyword">end</SPAN>}&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAllTail&nbsp;Ss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;S1<SPAN class="keyword">|</SPAN>Sr}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;Sr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;S2}&nbsp;S3&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S3&nbsp;=&nbsp;{FS<SPAN class="keyword">.</SPAN>intersect&nbsp;S1&nbsp;S2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{FS<SPAN class="keyword">.</SPAN>cardRange&nbsp;0&nbsp;1&nbsp;S3}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{FS<SPAN class="keyword">.</SPAN>distribute&nbsp;naive&nbsp;Ss}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;_}&nbsp;<SPAN class="keyword">fail</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR>&nbsp;<BR></PRE></BLOCKQUOTE><P> </P><P>Solving the Steiner problem of order 9 by invoking the Oz Explorer </P><BLOCKQUOTE class="code"><CODE>{ExploreOne&nbsp;{Steiner&nbsp;9}}</CODE></BLOCKQUOTE><P> yields as solution </P><BLOCKQUOTE class="code"><CODE>[{1<SPAN class="keyword">#</SPAN>3}<SPAN class="keyword">#</SPAN>3&nbsp;{1&nbsp;4<SPAN class="keyword">#</SPAN>5}<SPAN class="keyword">#</SPAN>3&nbsp;{1&nbsp;6<SPAN class="keyword">#</SPAN>7}<SPAN class="keyword">#</SPAN>3&nbsp;{1&nbsp;8<SPAN class="keyword">#</SPAN>9}<SPAN class="keyword">#</SPAN>3&nbsp;{2&nbsp;4&nbsp;6}<SPAN class="keyword">#</SPAN>3&nbsp;{2&nbsp;5&nbsp;8}<SPAN class="keyword">#</SPAN>3&nbsp;&nbsp;<BR>&nbsp;&nbsp;{2&nbsp;7&nbsp;9}<SPAN class="keyword">#</SPAN>3&nbsp;{3<SPAN class="keyword">#</SPAN>4&nbsp;9}<SPAN class="keyword">#</SPAN>3&nbsp;{3&nbsp;5&nbsp;7}<SPAN class="keyword">#</SPAN>3&nbsp;{3&nbsp;6&nbsp;8}<SPAN class="keyword">#</SPAN>3&nbsp;{4&nbsp;7<SPAN class="keyword">#</SPAN>8}<SPAN class="keyword">#</SPAN>3&nbsp;{5<SPAN class="keyword">#</SPAN>6&nbsp;9}<SPAN class="keyword">#</SPAN>3]<SPAN class="keyword">.</SPAN></CODE></BLOCKQUOTE><P> The search tree has depth 50, 4545 choice nodes, and 4521 failure nodes. </P><DIV align="center"><IMG alt="" src="fset_steiner_naive.gif" id="pic.fset_steiner_naive"></DIV><P> </P><P class="margin">Improving the Model</P><P> A promising way to improve the efficiency of a constraint model (where the corresponding problem does not have a unique solution) is to break symmetries and thus to improve constraint propagation. Breaking symmetries can be achieved by imposing an order, in our case, an order on the set variables in <CODE>Ss</CODE>. We can simply interpret every set as a number with three digits to the base <IMG alt="(n+1)" src="latex36.png">. A set with three elements <IMG alt="\{x_1,x_2,x_3\}" src="latex37.png"> can be mapped to an integer by <IMG alt="(n+1)^2x_1+(n+1)x_2+x_3" src="latex38.png">. </P><P class="margin">Extending the Solver</P><P> The finite set library provides <CODE>FS<SPAN class="keyword">.</SPAN>int<SPAN class="keyword">.</SPAN>match</CODE> to match the elements of a set <IMG alt="s" src="latex5.png"> with a fixed number of elements to a vector of size <IMG alt="\#s" src="latex39.png"> of finite domain variables. This library constraint in conjunction with <CODE>Map</CODE> is used to convert the list of sets <CODE>Ss</CODE> to a list of finite domain lists with 3 finite domains per list. Finally the order between adjacent sets is imposed by </P><BLOCKQUOTE class="code"><CODE>N1N1<SPAN class="keyword">*</SPAN>X1&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;N1<SPAN class="keyword">*</SPAN>X2&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;X3&nbsp;<SPAN class="keyword">&lt;:</SPAN>&nbsp;N1N1<SPAN class="keyword">*</SPAN>Y1<SPAN class="keyword">+</SPAN>&nbsp;N1<SPAN class="keyword">*</SPAN>Y2&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;Y3</CODE></BLOCKQUOTE><P> employing a <CODE>ForAllTail</CODE> loop. </P><BLOCKQUOTE class="linenumbers"><PRE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;N1&nbsp;=&nbsp;N<SPAN class="keyword">+</SPAN>1&nbsp;&nbsp;N1N1&nbsp;=&nbsp;N1<SPAN class="keyword">*</SPAN>N1<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{ForAllTail&nbsp;{Map&nbsp;Ss&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{FD<SPAN class="keyword">.</SPAN>list&nbsp;3&nbsp;1<SPAN class="keyword">#</SPAN>N}&nbsp;=&nbsp;{FS<SPAN class="keyword">.</SPAN>int<SPAN class="keyword">.</SPAN>match&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;[X1&nbsp;X2&nbsp;X3]<SPAN class="keyword">|</SPAN>[Y1&nbsp;Y2&nbsp;Y3]<SPAN class="keyword">|</SPAN>_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N1N1<SPAN class="keyword">*</SPAN>X1&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;N1<SPAN class="keyword">*</SPAN>X2&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;X3&nbsp;<SPAN class="keyword">&lt;:</SPAN>&nbsp;N1N1<SPAN class="keyword">*</SPAN>Y1&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;N1<SPAN class="keyword">*</SPAN>Y2&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;Y3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR></PRE></BLOCKQUOTE><P> This code is to be inserted right before the distribution. Solving the Steiner problem of order 9 results in the following search tree. </P><DIV align="center"><IMG alt="" src="fset_steiner_order.gif" id="pic.fset_steiner_order"></DIV><P> We see that the number of choice nodes decreases from 4545 to 565 and the number of failure nodes decreases from 4521 to 54. This reduction of the search space gives us a speed-up of about 7 and reduces the memory consumption by about 5.5. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#fset.tutorial.intro">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#fset.examples.hamming">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
